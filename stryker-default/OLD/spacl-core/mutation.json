{"files":{"src/matcher.ts":{"language":"typescript","mutants":[{"id":"0","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","testsCompleted":1,"location":{"end":{"column":66,"line":11},"start":{"column":61,"line":11}}},{"id":"1","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of w\nildcard segments correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      114 |       super(regex);\n      115 |       this.spec = spec;\n    > 116 |       this.props = props;\n          |                 ^\n      117 |     }\n      118 |   }\n      119 |   [Symbol.match](string: string): RegExpMatchArray | null {\n\n      at new Matcher (src/matcher.ts:116:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.541 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":36},"start":{"column":68,"line":11}}},{"id":"2","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains invalid characters\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |        \n   stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.544 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":55,"line":12},"start":{"column":9,"line":12}}},{"id":"3","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (1 ms)\n    ✓ answers queries correctly\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✕ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with invalid characters\n\n    expected path spec '/ ' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.513 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":55,"line":12},"start":{"column":9,"line":12}}},{"id":"4","mutatorName":"EqualityOperator","replacement":"spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✕ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains invalid characters\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with invalid characters\n\n    expected path spec '/ ' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.m\natch(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/rule.ts\n  rule\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       30 failed, 8 passed, 38 total\nSnapshots:   0 total\nTime:        1.539 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":55,"line":12},"start":{"column":9,"line":12}}},{"id":"5","mutatorName":"Regex","replacement":"/[a-zA-Z0-9_/:~.$+*-]*$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✕ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with invalid characters\n\n    expected path spec '/ ' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.578 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":12},"start":{"column":20,"line":12}}},{"id":"6","mutatorName":"Regex","replacement":"/^[a-zA-Z0-9_/:~.$+*-]*/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (1 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✕ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with invalid characters\n\n    expected path spec '/ ' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.531 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":12},"start":{"column":20,"line":12}}},{"id":"7","mutatorName":"Regex","replacement":"/^[a-zA-Z0-9_/:~.$+*-]$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/+' to be accepted: Path contains invalid characters\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |       \n    stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.607 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":12},"start":{"column":20,"line":12}}},{"id":"8","mutatorName":"Regex","replacement":"/^[^a-zA-Z0-9_/:~.$+*-]*$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains invalid characters\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |        \n   stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains invalid characters\n\n      65 |         } else {\n      66 |           stryCov_9fa48(\"9\");\n    > 67 |           throw new Error(stryMutAct_9fa48(\"10\") ? \"\" : (stryCov_9fa48(\"10\"), 'Path contains invalid characters'));\n         |                 ^\n      68 |         }\n      69 |       }\n      70 |       if (stryMutAct_9fa48(\"13\") ? spec.match(/^\\//) !== null : stryMutAct_9fa48(\"12\") ? false : stryMutAct_9fa48(\"11\") ? true : (stryCov_9fa48(\"11\", \"12\", \"13\"), spec.match(stryMutAct_9fa48(\"14\") ? /\\// : (stryCov_9fa48(\"14\"), /^\\//)) === null)) {\n\n      at new Matcher (src/matcher.ts:67:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.581 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":12},"start":{"column":20,"line":12}}},{"id":"9","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✕ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with invalid characters\n\n    expected path spec '/ ' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.524 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":14},"start":{"column":57,"line":12}}},{"id":"10","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","testsCompleted":1,"location":{"end":{"column":57,"line":13},"start":{"column":23,"line":13}}},{"id":"11","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path must begin with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test\n/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.634 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":15},"start":{"column":9,"line":15}}},{"id":"12","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✕ rejects empty paths\n    ✕ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects empty paths\n\n    expected path spec '' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths without leading slashes\n\n    expected path spec '+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.575 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":15},"start":{"column":9,"line":15}}},{"id":"13","mutatorName":"EqualityOperator","replacement":"spec.match(/^\\//) !== null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths\n\n    ✕ rejects empty paths (1 ms)\n\n    ✕ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path must begin with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects empty paths\n\n    expected path spec '' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths without leading slashes\n\n    expected path spec '+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n  \n    78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path must begin with a slash\n\n      73 |         } else {\n      74 |           stryCov_9fa48(\"15\");\n    > 75 |           throw new Error(stryMutAct_9fa48(\"16\") ? \"\" : (stryCov_9fa48(\"16\"), 'Path must begin with a slash'));\n         |                 ^\n      76 |         }\n      77 |       }\n      78 |       if (stryMutAct_9fa48(\"19\") ? spec.match(/\\/\\//) === null : stryMutAct_9fa48(\"18\") ? false : stryMutAct_9fa48(\"17\") ? true : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(/\\/\\//) !== null)) {\n\n      at new Matcher (src/matcher.ts:75:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nTest Suites: 4 failed, 4 total\nTests:       31 failed, 7 passed, 38 total\nSnapshots:   0 total\nTime:        1.631 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":15},"start":{"column":9,"line":15}}},{"id":"14","mutatorName":"Regex","replacement":"/\\//","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✕ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths without leading slashes\n\n    expected path spec '+/foo' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (2 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.561 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":25,"line":15},"start":{"column":20,"line":15}}},{"id":"15","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (1 ms)\n    ✕ rejects empty paths\n    ✕ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects empty paths\n\n    expected path spec '' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths without leading slashes\n\n    expected path spec '+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.583 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":17},"start":{"column":37,"line":15}}},{"id":"16","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","testsCompleted":1,"location":{"end":{"column":53,"line":16},"start":{"column":23,"line":16}}},{"id":"17","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \n\"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains empty segments\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\\n*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\n\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\"\n, \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa4\n8(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.479 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":36,"line":18},"start":{"column":9,"line":18}}},{"id":"18","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✕ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n  ● matcher › rejects paths with empty segments\n\n    expected path spec '//+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.466 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":36,"line":18},"start":{"column":9,"line":18}}},{"id":"19","mutatorName":"EqualityOperator","replacement":"spec.match(/\\/\\//) === null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa4\n8(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes (4 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✕ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains empty segments\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with empty segments\n\n    expected path spec '//+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\n\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"3\n0\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ?\n /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<a\nnonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains empty segments\n\n      81 |         } else {\n      82 |           stryCov_9fa48(\"20\");\n    > 83 |           throw new Error(stryMutAct_9fa48(\"21\") ? \"\" : (stryCov_9fa48(\"21\"), 'Path contains empty segments'));\n         |                 ^\n      84 |         }\n      85 |       }\n      86 |       if (stryMutAct_9fa48(\"24\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : stryMutAct_9fa48(\"23\") ? false : stryMutAct_9fa48(\"22\") ? true : (stryCov_9fa48(\"22\", \"23\", \"24\"), spec.match((stryMutAct_9fa48(\"27\") ? version === '1' && version === '1.0' : stryMutAct_9fa48(\"26\") ? false : stryMutAct_9fa48(\"25\") ? true : (stryCov_9fa48(\"25\", \"26\", \"27\"), (stryMutAct_9fa48(\"29\") ? version !== '1' : stryMutAct_9fa48(\"28\") ? false : (stryCov_9fa48(\"28\", \"29\"), version === (stryMutAct_9fa48(\"30\") ? \"\" : (stryCov_9fa48(\"30\"), '1')))) || (stryMutAct_9fa48(\"32\") ? version !== '1.0' : stryMutAct_9fa48(\"31\") ? false : (stryCov_9fa48(\"31\", \"32\"), version === (stryMutAct_9fa48(\"33\") ? \"\" : (stryCov_9fa48(\"33\"), '1.0')))))) ? stryMutAct_9fa48(\"37\") ? /[*+][^/]|[^/][^*+]/ : stryMutAct_9fa48(\"36\") ? /[*+][^/]|[/][*+]/ : stryMutAct_9fa48(\"35\") ? /[*+][/]|[^/][*+]/ : stryMutAct_9fa48(\"34\") ? /[^*+][^/]|[^/][*+]/ : (stryCov_9fa48(\"34\", \"35\", \"36\", \"37\"), /[*+][^/]|[^/][*+]/) : stryMutAct_9fa48(\"41\") ? /\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"40\") ? /\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"39\") ? /\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : stryMutAct_9fa48(\"38\") ? /\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/ : (stryCov_9fa48(\"38\", \"39\", \"40\", \"41\"), /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:83:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nTest Suites: 4 failed, 4 total\nTests:       30 failed, 8 passed, 38 total\nSnapshots:   0 total\nTime:        1.52 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":36,"line":18},"start":{"column":9,"line":18}}},{"id":"20","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✕ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › rejects paths with empty segments\n\n    expected path spec '//+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.771 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":20},"start":{"column":38,"line":18}}},{"id":"21","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","testsCompleted":1,"location":{"end":{"column":53,"line":19},"start":{"column":23,"line":19}}},{"id":"22","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n  matcher\n    ✕ accepts valid paths (1 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (1 ms)\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains malformed wildcards\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n    \n     |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.581 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":66,"line":23},"start":{"column":9,"line":21}}},{"id":"23","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n\nPASS test/policy.ts\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✕ rejects paths with malformed wildcards (1 ms)\n\n    ✕ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✕ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✕ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with malformed wildcards\n\n    expected path spec '/foo+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:foo+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › when using version 1 › rejects specs with match-one-or-none wildcards\n\n    expected path spec '/++' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › when using version 1 › rejects specs with match-many-or-none wildcards\n\n    expected path spec '/**' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.524 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":66,"line":23},"start":{"column":9,"line":21}}},{"id":"24","mutatorName":"EqualityOperator","replacement":"spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✕ rejects paths with malformed wildcards (1 ms)\n\n    ✕ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✕ rejects specs with match-one-or-none wildcards\n      ✕ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains malformed wildcards\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with malformed wildcards\n\n    expected path spec '/foo+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:foo+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |\n           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › when using version 1 › rejects specs with match-one-or-none wildcards\n\n    expected path spec '/++' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › when using version 1 › rejects specs with match-many-or-none wildcards\n\n    expected path spec '/**' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       33 failed, 5 passed, 38 total\nSnapshots:   0 total\nTime:        1.519 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":66,"line":23},"start":{"column":9,"line":21}}},{"id":"25","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/++' to be accepted: Path contains malformed wildcards\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.486 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":21},"start":{"column":20,"line":21}}},{"id":"26","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✕ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✕ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › when using version 1 › rejects specs with match-one-or-none wildcards\n\n    expected path spec '/++' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › when using version 1 › rejects specs with match-many-or-none wildcards\n\n    expected path spec '/**' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.604 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":21},"start":{"column":20,"line":21}}},{"id":"27","mutatorName":"LogicalOperator","replacement":"version === '1' && version === '1.0'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✕ rejects specs with match-one-or-none wildcards\n      ✕ rejects specs with match-many-or-none wildcards\n\n  ● matcher › when using version 1 › rejects specs with match-one-or-none wildcards\n\n    expected path spec '/++' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › when using version 1 › rejects specs with match-many-or-none wildcards\n\n    expected path spec '/**' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.646 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":21},"start":{"column":20,"line":21}}},{"id":"28","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✕ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › when using version 1 › rejects specs with match-one-or-none wildcards\n\n    expected path spec '/++' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.582 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":21},"start":{"column":20,"line":21}}},{"id":"29","mutatorName":"EqualityOperator","replacement":"version !== '1'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✕ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/++' to be accepted: Path contains malformed wildcards\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › when using version 1 › rejects specs with match-one-or-none wildcards\n\n    expected path spec '/++' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.662 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":21},"start":{"column":20,"line":21}}},{"id":"30","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✕ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › when using version 1 › rejects specs with match-one-or-none wildcards\n\n    expected path spec '/++' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.484 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":21},"start":{"column":32,"line":21}}},{"id":"31","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✕ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › when using version 1 › rejects specs with match-many-or-none wildcards\n\n    expected path spec '/**' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.505 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":21},"start":{"column":39,"line":21}}},{"id":"32","mutatorName":"EqualityOperator","replacement":"version !== '1.0'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✕ rejects specs with match-many-or-none wildcards\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/++' to be accepted: Path contains malformed wildcards\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › when using version 1 › rejects specs with match-many-or-none wildcards\n\n    expected path spec '/**' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.495 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":21},"start":{"column":39,"line":21}}},{"id":"33","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly (2 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✕ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › when using version 1 › rejects specs with match-many-or-none wildcards\n\n    expected path spec '/**' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.491 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":21},"start":{"column":51,"line":21}}},{"id":"34","mutatorName":"Regex","replacement":"/[^*+][^/]|[^/][*+]/","status":"Survived","testsCompleted":1,"location":{"end":{"column":28,"line":22},"start":{"column":9,"line":22}}},{"id":"35","mutatorName":"Regex","replacement":"/[*+][/]|[^/][*+]/","status":"Survived","testsCompleted":1,"location":{"end":{"column":28,"line":22},"start":{"column":9,"line":22}}},{"id":"36","mutatorName":"Regex","replacement":"/[*+][^/]|[/][*+]/","status":"Survived","testsCompleted":1,"location":{"end":{"column":28,"line":22},"start":{"column":9,"line":22}}},{"id":"37","mutatorName":"Regex","replacement":"/[*+][^/]|[^/][^*+]/","status":"Survived","testsCompleted":1,"location":{"end":{"column":28,"line":22},"start":{"column":9,"line":22}}},{"id":"38","mutatorName":"Regex","replacement":"/\\*[*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:28:21)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✕ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/*/+' to be accepted: Path contains malformed wildcards\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with malformed wildcards\n\n    expected path spec '/*foo' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       11 failed, 27 passed, 38 total\nSnapshots:   0 total\nTime:        1.512 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":23},"start":{"column":9,"line":23}}},{"id":"39","mutatorName":"Regex","replacement":"/\\*[^*/]|\\+[+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (5 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✕ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/+/+' to be accepted: Path contains malformed wildcards\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with malformed wildcards\n\n    expected path spec '/+foo' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       10 failed, 28 passed, 38 total\nSnapshots:   0 total\nTime:        1.468 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":23},"start":{"column":9,"line":23}}},{"id":"40","mutatorName":"Regex","replacement":"/\\*[^*/]|\\+[^+/]|[/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:28:21)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✕ rejects paths with malformed wildcards\n\n    ✕ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/+/*' to be accepted: Path contains malformed wildcards\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with malformed wildcards\n\n    expected path spec '/foo*' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:foo*' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:60:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       14 failed, 24 passed, 38 total\nSnapshots:   0 total\nTime:        1.558 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":23},"start":{"column":9,"line":23}}},{"id":"41","mutatorName":"Regex","replacement":"/\\*[^*/]|\\+[^+/]|[^/*]\\*|[/+]\\+|\\*\\*\\*|\\+\\+\\+/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:20:21)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:22:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✕ rejects paths with malformed wildcards\n    ✕ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (2 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (2 ms)\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/+' to be accepted: Path contains malformed wildcards\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with malformed wildcards\n\n    expected path spec '/foo+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:foo+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      \n93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:18:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed wildcards\n\n      89 |         } else {\n      90 |           stryCov_9fa48(\"42\");\n    > 91 |           throw new Error(stryMutAct_9fa48(\"43\") ? \"\" : (stryCov_9fa48(\"43\"), 'Path contains malformed wildcards'));\n         |                 ^\n      92 |         }\n      93 |       }\n      94 |       if (stryMutAct_9fa48(\"46\") ? spec.match(/[^/]:|:\\/|:$/) === null : stryMutAct_9fa48(\"45\") ? false : stryMutAct_9fa48(\"44\") ? true : (stryCov_9fa48(\"44\", \"45\", \"46\"), spec.match(stryMutAct_9fa48(\"48\") ? /[^/]:|:\\/|:/ : stryMutAct_9fa48(\"47\") ? /[/]:|:\\/|:$/ : (stryCov_9fa48(\"47\", \"48\"), /[^/]:|:\\/|:$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:91:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:59:17)\n\n\nTest Suites: 4 failed, 4 total\nTests:       15 failed, 23 passed, 38 total\nSnapshots:   0 total\nTime:        1.482 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":23},"start":{"column":9,"line":23}}},{"id":"42","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (2 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✕ rejects paths with malformed wildcards\n    ✕ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✕ rejects specs with match-one-or-none wildcards\n\n      ✕ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with malformed wildcards\n\n    expected path spec '/foo+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:foo+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › when using version 1 › rejects specs with match-one-or-none wildcards\n\n    expected path spec '/++' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › when using version 1 › rejects specs with match-many-or-none wildcards\n\n    expected path spec '/**' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (1 ms)\n    ✓ answers queries correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.513 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":25},"start":{"column":68,"line":23}}},{"id":"43","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","testsCompleted":1,"location":{"end":{"column":58,"line":24},"start":{"column":23,"line":24}}},{"id":"44","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains malformed captures\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.522 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":44,"line":26},"start":{"column":9,"line":26}}},{"id":"45","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✕ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/policy.ts\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.485 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":44,"line":26},"start":{"column":9,"line":26}}},{"id":"46","mutatorName":"EqualityOperator","replacement":"spec.match(/[^/]:|:\\/|:$/) === null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✕ rejects paths with malformed captures (1 ms)\n\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains malformed captures\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9f\na48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       30 failed, 8 passed, 38 total\nSnapshots:   0 total\nTime:        1.574 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":44,"line":26},"start":{"column":9,"line":26}}},{"id":"47","mutatorName":"Regex","replacement":"/[/]:|:\\/|:$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (7 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/:foo' to be accepted: Path contains malformed captures\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:20:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:62:17)\n\n\nTest Suites: 4 failed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.897 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":26},"start":{"column":20,"line":26}}},{"id":"48","mutatorName":"Regex","replacement":"/[^/]:|:\\/|:/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:20:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:62:17)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/:foo' to be accepted: Path contains malformed captures\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed captures\n\n       97 |         } else {\n       98 |           stryCov_9fa48(\"49\");\n    >  99 |           throw new Error(stryMutAct_9fa48(\"50\") ? \"\" : (stryCov_9fa48(\"50\"), 'Path contains malformed captures'));\n          |                 ^\n      100 |         }\n      101 |       }\n      102 |       if (stryMutAct_9fa48(\"53\") ? spec.match(/^.+\\/$/) === null : stryMutAct_9fa48(\"52\") ? false : stryMutAct_9fa48(\"51\") ? true : (stryCov_9fa48(\"51\", \"52\", \"53\"), spec.match(stryMutAct_9fa48(\"56\") ? /^.\\/$/ : stryMutAct_9fa48(\"55\") ? /^.+\\// : stryMutAct_9fa48(\"54\") ? /.+\\/$/ : (stryCov_9fa48(\"54\", \"55\", \"56\"), /^.+\\/$/)) !== null)) {\n\n      at new Matcher (src/matcher.ts:99:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.601 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":26},"start":{"column":20,"line":26}}},{"id":"49","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✕ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.915 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":28},"start":{"column":46,"line":26}}},{"id":"50","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","testsCompleted":1,"location":{"end":{"column":57,"line":27},"start":{"column":23,"line":27}}},{"id":"51","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path must not end with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches \ncapture segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.697 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":29},"start":{"column":9,"line":29}}},{"id":"52","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✕ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with trailing slashes\n\n    expected path spec '/+/' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.703 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":29},"start":{"column":9,"line":29}}},{"id":"53","mutatorName":"EqualityOperator","replacement":"spec.match(/^.+\\/$/) === null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✕ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path must not end with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with trailing slashes\n\n    expected path spec '/+/' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n  \n  Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       30 failed, 8 passed, 38 total\nSnapshots:   0 total\nTime:        1.533 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":29},"start":{"column":9,"line":29}}},{"id":"54","mutatorName":"Regex","replacement":"/.+\\/$/","status":"Survived","testsCompleted":1,"location":{"end":{"column":28,"line":29},"start":{"column":20,"line":29}}},{"id":"55","mutatorName":"Regex","replacement":"/^.+\\//","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:15:17)\n\n  ● policymap › answers queries correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:55:17)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:22:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:43:17)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:28:21)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (1 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/+/+' to be accepted: Path must not end with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › match\nes capture segments correctly\n\n    Path must not end with a slash\n\n      105 |         } else {\n      106 |           stryCov_9fa48(\"57\");\n    > 107 |           throw new Error(stryMutAct_9fa48(\"58\") ? \"\" : (stryCov_9fa48(\"58\"), 'Path must not end with a slash'));\n          |                 ^\n      108 |         }\n      109 |       }\n      110 |       const {\n\n      at new Matcher (src/matcher.ts:107:17)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       20 failed, 18 passed, 38 total\nSnapshots:   0 total\nTime:        1.583 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":29},"start":{"column":20,"line":29}}},{"id":"56","mutatorName":"Regex","replacement":"/^.\\/$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✕ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › rejects paths with trailing slashes\n\n    expected path spec '/+/' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.663 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":29},"start":{"column":20,"line":29}}},{"id":"57","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✕ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › rejects paths with trailing slashes\n\n    expected path spec '/+/' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.613 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":31},"start":{"column":40,"line":29}}},{"id":"58","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","testsCompleted":1,"location":{"end":{"column":55,"line":30},"start":{"column":23,"line":30}}},{"id":"59","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading '1')\n\n      178 |               stryCov_9fa48(\"244\");\n      179 |               const prop = ctx[this.regex.props[index]];\n    > 180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n      183 |                 } else {\n\n      at Rule.matches (src/rule.ts:180:459)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading '1')\n\n      178 |               stryCov_9fa48(\"244\");\n      179 |               const prop = ctx[this.regex.props[index]];\n    > 180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n      183 |                 } else {\n\n      at Rule.matches (src/rule.ts:180:459)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading '1')\n\n      178 |               stryCov_9fa48(\"244\");\n      179 |               const prop = ctx[this.regex.props[index]];\n    > 180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n      183 |                 } else {\n\n      at Rule.matches (src/rule.ts:180:459)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading '1')\n\n      178 |               stryCov_9fa48(\"244\");\n      179 |               const prop = ctx[this.regex.props[index]];\n    > 180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n      183 |                 } else {\n\n      at Rule.matches (src/rule.ts:180:459)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✕ matches literal path segments correctly (3 ms)\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       18 failed, 20 passed, 38 total\nSnapshots:   0 total\nTime:        1.572 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":43},"start":{"column":60,"line":38}}},{"id":"60","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (11 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (2 ms)\n\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (5 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (3 ms)\n\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        1.541 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":50,"line":39},"start":{"column":9,"line":39}}},{"id":"61","mutatorName":"ConditionalExpression","replacement":"false","status":"Survived","testsCompleted":1,"location":{"end":{"column":50,"line":39},"start":{"column":9,"line":39}}},{"id":"62","mutatorName":"LogicalOperator","replacement":"string.length > 1 || string.endsWith('/')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (2 ms)\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        1.609 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":50,"line":39},"start":{"column":9,"line":39}}},{"id":"63","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly (3 ms)\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        1.687 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":26,"line":39},"start":{"column":9,"line":39}}},{"id":"64","mutatorName":"EqualityOperator","replacement":"string.length >= 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nFAIL test/matcher.ts\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly (3 ms)\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        1.687 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":26,"line":39},"start":{"column":9,"line":39}}},{"id":"65","mutatorName":"EqualityOperator","replacement":"string.length <= 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (3 ms)\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        1.65 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":26,"line":39},"start":{"column":9,"line":39}}},{"id":"66","mutatorName":"MethodExpression","replacement":"string.startsWith('/')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (6 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (5 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (3 ms)\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (5 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        1.641 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":50,"line":39},"start":{"column":30,"line":39}}},{"id":"67","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✕ matches literal path segments correctly (2 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        1.767 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":49,"line":39},"start":{"column":46,"line":39}}},{"id":"68","mutatorName":"BlockStatement","replacement":"{}","status":"Survived","testsCompleted":1,"location":{"end":{"column":6,"line":41},"start":{"column":52,"line":39}}},{"id":"69","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","testsCompleted":1,"location":{"end":{"column":65,"line":48},"start":{"column":60,"line":48}}},{"id":"70","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (1 ms)\n    ✕ rejects empty paths\n    ✕ rejects paths without leading slashes\n\n    ✕ rejects paths with trailing slashes (1 ms)\n\n    ✕ rejects paths with empty segments\n\n    ✕ rejects paths with invalid characters\n    ✕ rejects paths with malformed wildcards\n\n    ✕ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly (3 ms)\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✕ rejects specs with match-one-or-none wildcards\n\n      ✕ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects empty paths\n\n    expected path spec '' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths without leading slashes\n\n    expected path spec '+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths with trailing slashes\n\n    expected path spec '/+/' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths with empty segments\n\n    expected path spec '//' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths with invalid characters\n\n    expected path spec '/ ' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths with malformed wildcards\n\n    expected path spec '/+*' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'source')\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                         ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:25\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'source')\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                         ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:25\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'source')\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                         ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:25\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'source')\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                         ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:25\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'source')\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                         ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:25\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'source')\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                         ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:25\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'source')\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                         ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n\n      at test/matcher.ts:636:25\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › when using version 1 › rejects specs with match-one-or-none wildcards\n\n    expected path spec '/++' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › when using version 1 › rejects specs with match-many-or-none wildcards\n\n    expected path spec '/**' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       23 failed, 15 passed, 38 total\nSnapshots:   0 total\nTime:        1.615 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":50},"start":{"column":76,"line":48}}},{"id":"71","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot destructure property 'regex' of 'compile(...)' as it is undefined.\n\n      109 |       }\n      110 |       const {\n    > 111 |         regex,\n          |         ^\n      112 |         props\n      113 |       } = compile(spec);\n      114 |       super(regex);\n\n      at new Matcher (src/matcher.ts:111:9)\n      at new Rule (src/rule.ts:68:53)\n      at Function.for (src/rule.ts:224:14)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.605 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":2,"line":123},"start":{"column":3,"line":56}}},{"id":"72","mutatorName":"ArrayDeclaration","replacement":"[\"Stryker was here\"]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments (6 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (6 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly (6 ms)\n\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/Stryker was here$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/Stryker was here$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+Stryker was here$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+Stryker was here$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+Stryker was here$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+Stryker was here$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+Stryker was here$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+Stryker was here$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+Stryker was here$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+Stryker was here$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+Stryker was here$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+Stryker was here$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)Stryker was here$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)Stryker was here$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value\n to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.636 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":29,"line":57},"start":{"column":27,"line":57}}},{"id":"73","mutatorName":"ArrayDeclaration","replacement":"[\"Stryker was here\"]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (3 ms)\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"Stryker was here\"]\n\n    Message:\n      path spec '/' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"Stryker was here\",\n    + ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"Stryker was here\"]\n\n    Message:\n      path spec '/+' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"Stryker was here\",\n    + ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"Stryker was here\"]\n\n    Message:\n      path spec '/*' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"Stryker was here\",\n    + ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"Stryker was here\"]\n\n    Message:\n      path spec '/++' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"Stryker was here\",\n    + ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"Stryker was here\"]\n\n    Message:\n      path spec '/**' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"Stryker was here\",\n    + ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"Stryker was here\"]\n\n    Message:\n      path spec '/+' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"Stryker was here\",\n    + ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\"]\n    Received:\n      [\"foo\", \"Stryker was here\"]\n\n    Message:\n      path spec '/:foo' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n        \"foo\",\n    +   \"Stryker was here\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        1.622 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":29,"line":58},"start":{"column":27,"line":58}}},{"id":"74","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (2 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/foo(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+\\/foo(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/foo(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)*\\/foo(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Receiv\ned:\n      true\n\n    Message:\n      expected path spec '/*/bar' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**/boo' to not match '/boo/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/foo/bar/boo/baz'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/yeah/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       19 failed, 19 passed, 38 total\nSnapshots:   0 total\nTime:        1.536 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":18,"line":61},"start":{"column":13,"line":61}}},{"id":"75","mutatorName":"BooleanLiteral","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (2 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.551 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":17,"line":62},"start":{"column":13,"line":62}}},{"id":"76","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (7 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (3 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (9 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo(?:\\\\/[^/]+)?$\"\n    Received:\n      \"^\\\\/foo\\\\/[^/]+$\"\n\n    Message:\n      path spec '/foo/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo(?:\\/[^/]+)?$\n    + ^\\/foo\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo(?:\\\\/[^/]+)*$\"\n    Received:\n      \"^\\\\/foo(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/foo/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo(?:\\/[^/]+)*$\n    + ^\\/foo(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.588 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":43,"line":63},"start":{"column":38,"line":63}}},{"id":"77","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✕ compiles match-one wildcard segments correctly (2 ms)\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/([^/]+)\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !\n== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (2 ms)\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       18 failed, 20 passed, 38 total\nSnapshots:   0 total\nTime:        1.602 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":87},"start":{"column":51,"line":63}}},{"id":"78","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (2 ms)\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^(?:\\\\/[^/]+){0}\\\\/(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^(?:\\/[^/]+){0}\\/(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/foo(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+\\/foo(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/foo(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+\\/foo(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?\\\\/foo(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^(?:\\/[^/]+)?\\/foo(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/foo(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)*\\/foo(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^(?:\\\\/[^/]+){0}\\\\/([^/]+)(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^(?:\\/[^/]+){0}\\/([^/]+)(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.639 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":64},"start":{"column":9,"line":64}}},{"id":"79","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (3 ms)\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/([^/]+)\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n \n     659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       18 failed, 20 passed, 38 total\nSnapshots:   0 total\nTime:        1.563 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":64},"start":{"column":9,"line":64}}},{"id":"80","mutatorName":"LogicalOperator","replacement":"max > 0 && any","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (3 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/([^/]+)\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n \n     659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       18 failed, 20 passed, 38 total\nSnapshots:   0 total\nTime:        1.611 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":64},"start":{"column":9,"line":64}}},{"id":"81","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (4 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n\nFAIL test/rule.ts\n  rule\n\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✕ compiles match-one wildcard segments correctly (3 ms)\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       12 failed, 26 passed, 38 total\nSnapshots:   0 total\nTime:        1.591 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":16,"line":64},"start":{"column":9,"line":64}}},{"id":"82","mutatorName":"EqualityOperator","replacement":"max >= 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (4 ms)\n\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (2 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^(?:\\\\/[^/]+){0}\\\\/(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^(?:\\/[^/]+){0}\\/(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/foo(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+\\/foo(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/foo(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+\\/foo(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?\\\\/foo(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^(?:\\/[^/]+)?\\/foo(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/foo(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)*\\/foo(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^(?:\\\\/[^/]+){0}\\\\/([^/]+)(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^(?:\\/[^/]+){0}\\/([^/]+)(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.69 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":16,"line":64},"start":{"column":9,"line":64}}},{"id":"83","mutatorName":"EqualityOperator","replacement":"max <= 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (3 ms)\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly (2 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^(?:\\\\/[^/]+){0}\\\\/(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^(?:\\/[^/]+){0}\\/(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/foo(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+\\/foo(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/foo(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)*\\/foo(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^(?:\\\\/[^/]+){0}\\\\/([^/]+)(?:\\\\/[^/]+){0}$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^(?:\\/[^/]+){0}\\/([^/]+)(?:\\/[^/]+){0}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       15 failed, 23 passed, 38 total\nSnapshots:   0 total\nTime:        1.715 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":16,"line":64},"start":{"column":9,"line":64}}},{"id":"84","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly (3 ms)\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/([^/]+)\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n \n     659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       18 failed, 20 passed, 38 total\nSnapshots:   0 total\nTime:        1.571 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":83},"start":{"column":25,"line":64}}},{"id":"85","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly (3 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/foo$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^\\/[^/]+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== n\null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       12 failed, 26 passed, 38 total\nSnapshots:   0 total\nTime:        1.563 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":65},"start":{"column":11,"line":65}}},{"id":"86","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (2 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.58 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":65},"start":{"column":11,"line":65}}},{"id":"87","mutatorName":"LogicalOperator","replacement":"final && opt || min < 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✕ compiles match-one wildcard segments correctly (2 ms)\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/foo$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^\\/[^/]+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== n\null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       12 failed, 26 passed, 38 total\nSnapshots:   0 total\nTime:        1.587 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":65},"start":{"column":11,"line":65}}},{"id":"88","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (4 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (5 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/foo$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^\\/[^/]+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.534 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":65},"start":{"column":11,"line":65}}},{"id":"89","mutatorName":"LogicalOperator","replacement":"final || opt","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (1 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (4 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly (3 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/foo$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^\\/[^/]+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.556 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":65},"start":{"column":11,"line":65}}},{"id":"90","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (6 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (8 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (2 ms)\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.545 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":65},"start":{"column":27,"line":65}}},{"id":"91","mutatorName":"EqualityOperator","replacement":"min <= 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (7 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (3 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.55 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":65},"start":{"column":27,"line":65}}},{"id":"92","mutatorName":"EqualityOperator","replacement":"min >= 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly (4 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly (9 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661\n |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       12 failed, 26 passed, 38 total\nSnapshots:   0 total\nTime:        1.655 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":65},"start":{"column":27,"line":65}}},{"id":"93","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (3 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.776 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":8,"line":67},"start":{"column":36,"line":65}}},{"id":"94","mutatorName":"ConditionalExpression","replacement":"true","status":"Survived","testsCompleted":1,"location":{"end":{"column":25,"line":67},"start":{"column":18,"line":67}}},{"id":"95","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (12 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nFAIL test/rule.ts\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (4 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.658 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":25,"line":67},"start":{"column":18,"line":67}}},{"id":"96","mutatorName":"EqualityOperator","replacement":"min >= 0","status":"Survived","testsCompleted":1,"location":{"end":{"column":25,"line":67},"start":{"column":18,"line":67}}},{"id":"97","mutatorName":"EqualityOperator","replacement":"min <= 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (5 ms)\n    ✕ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.707 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":25,"line":67},"start":{"column":18,"line":67}}},{"id":"98","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (3 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.658 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":8,"line":69},"start":{"column":27,"line":67}}},{"id":"99","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly (4 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/$|^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/rule.ts\n  rule\n\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.714 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":20,"line":68},"start":{"column":15,"line":68}}},{"id":"100","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/*/*'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:27:5)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (4 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (2 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2,}$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/+/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2,}$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.115 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":18,"line":71},"start":{"column":11,"line":71}}},{"id":"101","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly (4 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+){1,}$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+){1,}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+){1,}$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+){1,}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/foo(?:\\\\/[^/]+){1,}$\"\n\n    Message:\n      path spec '/+/foo/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo(?:\\/[^/]+)+$\n    + ^\\/[^/]+\\/foo(?:\\/[^/]+){1,}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+){1,}\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+){1,}\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.777 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":18,"line":71},"start":{"column":11,"line":71}}},{"id":"102","mutatorName":"EqualityOperator","replacement":"min <= 2","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (2 ms)\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2,}$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/+/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2,}$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/*/*'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:27:5)\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.774 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":18,"line":71},"start":{"column":11,"line":71}}},{"id":"103","mutatorName":"EqualityOperator","replacement":"min >= 2","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly (2 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+){1,}$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+){1,}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+){1,}$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+){1,}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2,}$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/+/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2,}$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+){1,}\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+){1,}\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/*/*'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:27:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.688 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":18,"line":71},"start":{"column":11,"line":71}}},{"id":"104","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (8 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters (2 ms)\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (6 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/foo(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/+/foo/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo(?:\\/[^/]+)+$\n    + ^\\/[^/]+\\/foo(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)*\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)*\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.21 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":20,"line":72},"start":{"column":13,"line":72}}},{"id":"105","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (6 ms)\n    ✓ clones itself correctly\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (3 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.132 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":20,"line":72},"start":{"column":13,"line":72}}},{"id":"106","mutatorName":"EqualityOperator","replacement":"min <= 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (17 ms)\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (4 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/foo(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/+/foo/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo(?:\\/[^/]+)+$\n    + ^\\/[^/]+\\/foo(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)*\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)*\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.313 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":20,"line":72},"start":{"column":13,"line":72}}},{"id":"107","mutatorName":"EqualityOperator","replacement":"min >= 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/matcher.ts\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly (11 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/foo(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/+/foo/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo(?:\\/[^/]+)+$\n    + ^\\/[^/]+\\/foo(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)*\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)*\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.672 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":20,"line":72},"start":{"column":13,"line":72}}},{"id":"108","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (16 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (2 ms)\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^\\\\/foo$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/**' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.027 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":73},"start":{"column":15,"line":73}}},{"id":"109","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'boo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (3 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/foo$\"\n\n    Message:\n      path spec '/+/foo/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo(?:\\/[^/]+)+$\n    + ^\\/[^/]+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/[^/]+\\/([^/]+)\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       10 failed, 28 passed, 38 total\nSnapshots:   0 total\nTime:        1.632 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":74},"start":{"column":15,"line":74}}},{"id":"110","mutatorName":"StringLiteral","replacement":"``","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for rule '/*/*'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:27:5)\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (6 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly (8 ms)\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2,}$\"\n    Received:\n      \"^$\"\n\n    Message:\n      path spec '/+/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2,}$\n    + ^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.909 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":75},"start":{"column":13,"line":75}}},{"id":"111","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (3 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (2 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2}$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/+/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2}$\n    + ^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++/++' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.289 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":20,"line":76},"start":{"column":11,"line":76}}},{"id":"112","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (3 ms)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly (4 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+){1}$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^(?:\\/[^/]+){1}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+){1}$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+){1}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+){1}$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^(?:\\/[^/]+){1}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^(?:\\\\/[^/]+){1}\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^(?:\\/[^/]+){1}\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.807 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":20,"line":76},"start":{"column":11,"line":76}}},{"id":"113","mutatorName":"EqualityOperator","replacement":"max !== 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (7 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (7 ms)\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+){1}$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^(?:\\/[^/]+){1}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+){1}$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+){1}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+){1}$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^(?:\\/[^/]+){1}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^(?:\\\\/[^/]+){1}\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^(?:\\/[^/]+){1}\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++/++' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.878 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":20,"line":76},"start":{"column":11,"line":76}}},{"id":"114","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nPASS test/policy.ts\n  policy\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (2 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (6 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (3 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/foo$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^\\/[^/]+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.559 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":22,"line":77},"start":{"column":13,"line":77}}},{"id":"115","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✓ answers queries correctly (4 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (3 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^(?:\\/[^/]+)?\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.064 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":22,"line":77},"start":{"column":13,"line":77}}},{"id":"116","mutatorName":"EqualityOperator","replacement":"min !== 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (2 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^(?:\\/[^/]+)?\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.782 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":22,"line":77},"start":{"column":13,"line":77}}},{"id":"117","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly (4 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       11 failed, 27 passed, 38 total\nSnapshots:   0 total\nTime:        1.879 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":78},"start":{"column":15,"line":78}}},{"id":"118","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (8 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly (6 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^\\\\/foo$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.865 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":79},"start":{"column":15,"line":79}}},{"id":"119","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (3 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){1,2}$\"\n    Received:\n      \"^(?:\\\\/[^/]+){1}$\"\n\n    Message:\n      path spec '/++/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){1,2}$\n    + ^(?:\\/[^/]+){1}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++/++' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        1.774 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":24,"line":80},"start":{"column":13,"line":80}}},{"id":"120","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (4 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2}$\"\n    Received:\n      \"^(?:\\\\/[^/]+){2,2}$\"\n\n    Message:\n      path spec '/+/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2}$\n    + ^(?:\\/[^/]+){2,2}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.639 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":24,"line":80},"start":{"column":13,"line":80}}},{"id":"121","mutatorName":"EqualityOperator","replacement":"min !== max","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (2 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2}$\"\n    Received:\n      \"^(?:\\\\/[^/]+){2,2}$\"\n\n    Message:\n      path spec '/+/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2}$\n    + ^(?:\\/[^/]+){2,2}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++/++' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        1.625 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":24,"line":80},"start":{"column":13,"line":80}}},{"id":"122","mutatorName":"StringLiteral","replacement":"``","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (3 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (3 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2}$\"\n    Received:\n      \"^$\"\n\n    Message:\n      path spec '/+/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2}$\n    + ^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/+/+' to match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        1.645 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":81},"start":{"column":15,"line":81}}},{"id":"123","mutatorName":"StringLiteral","replacement":"``","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (28 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (3 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){1,2}$\"\n    Received:\n      \"^$\"\n\n    Message:\n      path spec '/++/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){1,2}$\n    + ^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        1.628 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":42,"line":82},"start":{"column":15,"line":82}}},{"id":"124","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/yeah/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (2 ms)\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^(?:\\/[^/]+)*\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^(?:\\/[^/]+)+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/foo(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/foo/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)*\\/foo(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^(?:\\/[^/]+)*\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo(?:\\\\/[^/]+)*$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/foo(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/foo/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo(?:\\/[^/]+)*$\n    + ^(?:\\/[^/]+)*\\/foo(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/foo\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^(?:\\/[^/]+)+\\/foo\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^(?:\\/[^/]+)*\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/++' to not match '/bar/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/**' to not match '/bar/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments corr\nectly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       11 failed, 27 passed, 38 total\nSnapshots:   0 total\nTime:        1.808 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":16,"line":86},"start":{"column":11,"line":86}}},{"id":"125","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (2 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"(?:)\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + (?:)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"(?:)\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + (?:)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"(?:)\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + (?:)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"(?:)\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + (?:)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"(?:)\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + (?:)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"(?:)\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + (?:)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"(?:)\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + (?:)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      \n659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       25 failed, 13 passed, 38 total\nSnapshots:   0 total\nTime:        1.756 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":91},"start":{"column":32,"line":88}}},{"id":"126","mutatorName":"BooleanLiteral","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly (4 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.804 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":17,"line":89},"start":{"column":13,"line":89}}},{"id":"127","mutatorName":"ArithmeticOperator","replacement":"(opt ? '^/$|^' : '^') - parts.reduce((acc, seg) => seg + acc, '$')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (2 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"NaN\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"NaN\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"NaN\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"NaN\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"NaN\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"NaN\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"NaN\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |         \n  `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.567 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":78,"line":90},"start":{"column":12,"line":90}}},{"id":"128","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (5 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly (3 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"\\\\/[^/]+$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + \\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + (?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"\\\\/[^/]+$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + \\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.541 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":26,"line":90},"start":{"column":19,"line":90}}},{"id":"129","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (4 ms)\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly (4 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly (2 ms)\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"\\\\/$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + \\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + \\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + (?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"(?:\\\\/[^/]+)?\\\\/foo$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + (?:\\/[^/]+)?\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"(?:\\\\/[^/]+)*\\\\/foo$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + (?:\\/[^/]+)*\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + \\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + \\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/++' to not match '/bar/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/**' to not match '/bar/foo'\n\n      656 |         const [expec\nted, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/foo/bar/boo/baz'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (1 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/yeah/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       14 failed, 24 passed, 38 total\nSnapshots:   0 total\nTime:        1.605 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":90},"start":{"column":29,"line":90}}},{"id":"130","mutatorName":"ArrowFunction","replacement":"() => undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (12 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (5 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly (6 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^undefined\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^undefined\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^undefined\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^undefined\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^undefined\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^undefined\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^undefined\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^undefined\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^undefined\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^undefined\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^undefined\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^undefined\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^undefined\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^undefined\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(\nregex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.565 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":72,"line":90},"start":{"column":49,"line":90}}},{"id":"131","mutatorName":"ArithmeticOperator","replacement":"seg - acc","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (2 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^NaN\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^NaN\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^NaN\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^NaN\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^NaN\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^NaN\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^NaN\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |      \n              ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.575 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":72,"line":90},"start":{"column":63,"line":90}}},{"id":"132","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/yeah/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (6 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (2 ms)\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match '/food'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*/bar' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         cons\nt match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**/boo' to not match '/boo/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/foo/bar/boo/baz'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       19 failed, 19 passed, 38 total\nSnapshots:   0 total\nTime:        1.571 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":77,"line":90},"start":{"column":74,"line":90}}},{"id":"133","mutatorName":"MethodExpression","replacement":"spec.split('/').slice(1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (8 ms)\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo\\\\/bar$\"\n    Received:\n      \"^\\\\/bar\\\\/foo$\"\n\n    Message:\n      path spec '/foo/bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo\\/bar$\n    + ^\\/bar\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/foo\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/foo\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^\\\\/foo(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^\\/foo(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^\\\\/foo(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^\\/foo(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^\\\\/foo(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^\\/foo(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/foo\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+\\/foo\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\", \"bar\"]\n    Received:\n      [\"bar\", \"foo\"]\n\n    Message:\n      path spec '/:foo/:bar' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"foo\",\n        \"bar\",\n    +   \"foo\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/bar' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/**' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"bar\", \"baz\"]\n    Received:\n      [\"foo\", \"boo\"]\n\n    Message:\n      path spec '/+/:a/*/:b' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"bar\",\n    -   \"baz\",\n    +   \"foo\",\n    +   \"boo\",\n      ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       17 failed, 21 passed, 38 total\nSnapshots:   0 total\nTime:        1.551 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":92},"start":{"column":22,"line":92}}},{"id":"134","mutatorName":"MethodExpression","replacement":"spec.split('/')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (12 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (2 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (2 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/\\\\/$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.s\ntrictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.647 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":46,"line":92},"start":{"column":22,"line":92}}},{"id":"135","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (15 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (6 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (2 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (2 ms)\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/\\\\/\\\\/f\\\\/o\\\\/o$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+\\/\\/\\/f\\/o\\/o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/\\\\/\\\\/f\\\\/o\\\\/o$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+\\/\\/\\/f\\/o\\/o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+){2}$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^(?:\\/[^/]+){2}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+){2,}$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+){2,}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2,}$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/\\\\/(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/+/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2,}$\n    + ^\\/[^/]+\\/\\/(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/:\\\\/f\\\\/o\\\\/o$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/:\\/f\\/o\\/o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      fal\nse\n\n    Message:\n      expected path spec '/*/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       27 failed, 11 passed, 38 total\nSnapshots:   0 total\nTime:        1.62 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":36,"line":92},"start":{"column":33,"line":92}}},{"id":"136","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (3 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), \nexpected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.859 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":118},"start":{"column":58,"line":92}}},{"id":"137","mutatorName":"ConditionalExpression","replacement":"case '+':","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (7 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (10 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^(?:\\/[^/]+)?\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (10 ms)\n    ✓ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.701 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":14,"line":97},"start":{"column":7,"line":94}}},{"id":"138","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('dynamic', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (3 ms)\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/:a/*/:b' to match '/foo/bar/boo/baz'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       11 failed, 27 passed, 38 total\nSnapshots:   0 total\nTime:        1.589 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":15,"line":94},"start":{"column":12,"line":94}}},{"id":"139","mutatorName":"UpdateOperator","replacement":"min--","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (8 ms)\n\n    ✓ matches context-dependent paths correctly (4 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly (2 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^(?:\\/[^/]+)?\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.626 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":14,"line":95},"start":{"column":9,"line":95}}},{"id":"140","mutatorName":"UpdateOperator","replacement":"max--","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n  rule\n\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (3 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       10 failed, 28 passed, 38 total\nSnapshots:   0 total\nTime:        1.773 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":14,"line":96},"start":{"column":9,"line":96}}},{"id":"141","mutatorName":"ConditionalExpression","replacement":"case '++':","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly (2 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.682 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":14,"line":100},"start":{"column":7,"line":98}}},{"id":"142","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (4 ms)\n\n    ✕ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/++' to be accepted: Invalid regular expression: /^/++$/: Nothing to repeat\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/++$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      112 |         props\n      113 |       } = compile(spec);\n    > 114 |       super(regex);\n          |       ^\n      115 |       this.spec = spec;\n      116 |       this.props = props;\n      117 |     }\n\n      at new Matcher (src/matcher.ts:114:7)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/++$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      112 |         props\n      113 |       } = compile(spec);\n    > 114 |       super(regex);\n          |       ^\n      115 |       this.spec = spec;\n      116 |       this.props = props;\n      117 |     }\n\n      at new Matcher (src/matcher.ts:114:7)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/++$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      112 |         props\n      113 |       } = compile(spec);\n    > 114 |       super(regex);\n          |       ^\n      115 |       this.spec = spec;\n      116 |       this.props = props;\n      117 |     }\n\n      at new Matcher (src/matcher.ts:114:7)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/++/[^/]+$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      112 |         props\n      113 |       } = compile(spec);\n    > 114 |       super(regex);\n          |       ^\n      115 |       this.spec = spec;\n      116 |       this.props = props;\n      117 |     }\n\n      at new Matcher (src/matcher.ts:114:7)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.675 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":16,"line":98},"start":{"column":12,"line":98}}},{"id":"143","mutatorName":"UpdateOperator","replacement":"max--","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly (3 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.766 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":14,"line":99},"start":{"column":9,"line":99}}},{"id":"144","mutatorName":"ConditionalExpression","replacement":"case '*':","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/*/*'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:27:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (3 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2,}$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/+/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2,}$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)*\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)*\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.752 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":14,"line":104},"start":{"column":7,"line":101}}},{"id":"145","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (9 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (3 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/*$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2,}$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/*$\"\n\n    Message:\n      path spec '/+/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2,}$\n    + ^\\/[^/]+\\/*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)\\\\/*\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/[^/]+\\/([^/]+)\\/*\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/*/*'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:27:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       10 failed, 28 passed, 38 total\nSnapshots:   0 total\nTime:        1.827 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":15,"line":101},"start":{"column":12,"line":101}}},{"id":"146","mutatorName":"UpdateOperator","replacement":"min--","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/*/*'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:27:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (4 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2,}$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/+/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2,}$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)*\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)*\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.792 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":14,"line":102},"start":{"column":9,"line":102}}},{"id":"147","mutatorName":"BooleanLiteral","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/*/*'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:27:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (3 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2,}$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/+/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2,}$\n    + ^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/[^/]+\\/([^/]+)\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.687 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":103},"start":{"column":15,"line":103}}},{"id":"148","mutatorName":"ConditionalExpression","replacement":"case '**':","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/**' to be accepted: Invalid regular expression: /^/**$/: Nothing to repeat\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/**$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      112 |         props\n      113 |       } = compile(spec);\n    > 114 |       super(regex);\n          |       ^\n      115 |       this.spec = spec;\n      116 |       this.props = props;\n      117 |     }\n\n      at new Matcher (src/matcher.ts:114:7)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/**$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      112 |         props\n      113 |       } = compile(spec);\n    > 114 |       super(regex);\n          |       ^\n      115 |       this.spec = spec;\n      116 |       this.props = props;\n      117 |     }\n\n      at new Matcher (src/matcher.ts:114:7)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/**$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      112 |         props\n      113 |       } = compile(spec);\n    > 114 |       super(regex);\n          |       ^\n      115 |       this.spec = spec;\n      116 |       this.props = props;\n      117 |     }\n\n      at new Matcher (src/matcher.ts:114:7)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/**/[^/]+$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      112 |         props\n      113 |       } = compile(spec);\n    > 114 |       super(regex);\n          |       ^\n      115 |       this.spec = spec;\n      116 |       this.props = props;\n      117 |     }\n\n      at new Matcher (src/matcher.ts:114:7)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.741 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":14,"line":107},"start":{"column":7,"line":105}}},{"id":"149","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (3 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/**' to be accepted: Invalid regular expression: /^/**$/: Nothing to repeat\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/**$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      112 |         props\n      113 |       } = compile(spec);\n    > 114 |       super(regex);\n          |       ^\n      115 |       this.spec = spec;\n      116 |       this.props = props;\n      117 |     }\n\n      at new Matcher (src/matcher.ts:114:7)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/**$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      112 |         props\n      113 |       } = compile(spec);\n    > 114 |       super(regex);\n          |       ^\n      115 |       this.spec = spec;\n      116 |       this.props = props;\n      117 |     }\n\n      at new Matcher (src/matcher.ts:114:7)\n      at Function.for (src/matcher.ts:144:14)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/**$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      112 |         props\n      113 |       } = compile(spec);\n    > 114 |       super(regex);\n          |       ^\n      115 |       this.spec = spec;\n      116 |       this.props = props;\n      117 |     }\n\n      at new Matcher (src/matcher.ts:114:7)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/**/[^/]+$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      112 |         props\n      113 |       } = compile(spec);\n    > 114 |       super(regex);\n          |       ^\n      115 |       this.spec = spec;\n      116 |       this.props = props;\n      117 |     }\n\n      at new Matcher (src/matcher.ts:114:7)\n      at Function.for (src/matcher.ts:144:14)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.669 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":16,"line":105},"start":{"column":12,"line":105}}},{"id":"150","mutatorName":"BooleanLiteral","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (2 ms)\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.608 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":106},"start":{"column":15,"line":106}}},{"id":"151","mutatorName":"ConditionalExpression","replacement":"default:","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✕ compiles literal path segments correctly (3 ms)\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (2 ms)\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+){2}$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^(?:\\/[^/]+){2}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/+' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/*' to not match \n'/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/++' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/**' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       26 failed, 12 passed, 38 total\nSnapshots:   0 total\nTime:        1.565 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":10,"line":116},"start":{"column":7,"line":108}}},{"id":"152","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (2 ms)\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^\\\\/$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/foo\\\\/[^/]+$\"\n\n    Message:\n      path spec '/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo\\/[^/]+$\n    + ^\\/$|^\\/foo\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^\\\\/foo(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/foo/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo(?:\\/[^/]+)+$\n    + ^\\/$|^\\/foo(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+\\\\/foo$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^\\/$|^\\/[^/]+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+\\\\/foo$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^\\/$|^(?:\\/[^/]+)+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$|^\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/$|^\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/++' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/**' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |        \n strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       16 failed, 22 passed, 38 total\nSnapshots:   0 total\nTime:        1.586 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":20,"line":110},"start":{"column":15,"line":110}}},{"id":"153","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (5 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (3 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^(?:\\/[^/]+)?\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)*\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^\\/[^/]+\\/([^/]+)\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match '/fo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"foo\"]\n\n    Message:\n      path spec '/foo/+' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"foo\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"foo\"]\n\n    Message:\n      path spec '/foo/*' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"foo\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n  \n    []\n    Received:\n      [\"foo\"]\n\n    Message:\n      path spec '/foo/++' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"foo\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"foo\"]\n\n    Message:\n      path spec '/foo/**' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"foo\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        1.715 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":39,"line":111},"start":{"column":13,"line":111}}},{"id":"154","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (3 ms)\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/:foo$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/:foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.658 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":39,"line":111},"start":{"column":13,"line":111}}},{"id":"155","mutatorName":"EqualityOperator","replacement":"part.match(/:.+/) === null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (8 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (2 ms)\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (3 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^(?:\\/[^/]+)?\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)*\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^\\/[^/]+\\/([^/]+)\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/:foo$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/:foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match '/fo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"foo\"]\n\n    Message:\n      path spec '/foo/+' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"foo\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.deep\nStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"foo\"]\n\n    Message:\n      path spec '/foo/*' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"foo\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"foo\"]\n\n    Message:\n      path spec '/foo/++' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"foo\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"foo\"]\n\n    Message:\n      path spec '/foo/**' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"foo\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       26 failed, 12 passed, 38 total\nSnapshots:   0 total\nTime:        1.705 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":39,"line":111},"start":{"column":13,"line":111}}},{"id":"156","mutatorName":"Regex","replacement":"/:./","status":"Survived","testsCompleted":1,"location":{"end":{"column":29,"line":111},"start":{"column":24,"line":111}}},{"id":"157","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (5 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.732 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":10,"line":114},"start":{"column":41,"line":111}}},{"id":"158","mutatorName":"MethodExpression","replacement":"part","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (8 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (2 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\"]\n    Received:\n      [\":foo\"]\n\n    Message:\n      path spec '/:foo' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"foo\",\n    +   \":foo\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.699 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":112},"start":{"column":22,"line":112}}},{"id":"159","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (4 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (4 ms)\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly (6 ms)\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.716 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":113},"start":{"column":22,"line":113}}},{"id":"160","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (13 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (5 ms)\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^\\/[^/]+\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/+' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected\n,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/**' to not match '/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        1.824 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":10,"line":116},"start":{"column":16,"line":114}}},{"id":"161","mutatorName":"StringLiteral","replacement":"``","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (3 ms)\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^\\/[^/]+\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/+' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected\n,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/**' to not match '/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (11 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        1.704 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":59,"line":115},"start":{"column":22,"line":115}}},{"id":"162","mutatorName":"Regex","replacement":"/([^.$])/g","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (8 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (2 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly (2 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo$\"\n    Received:\n      \"^\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo$\n    + ^\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^(?:\\/[^/]+)?\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)*\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/\\\\f\\\\o\\\\o\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^\\/[^/]+\\/\\f\\o\\o\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo'\n\n      656 |         const [expected, value, ...\nprops] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n\nTest Suites: 4 failed, 4 total\nTests:       19 failed, 19 passed, 38 total\nSnapshots:   0 total\nTime:        1.688 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":48,"line":115},"start":{"column":39,"line":115}}},{"id":"163","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (3 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/\\\\.foo$\"\n    Received:\n      \"^\\\\/foo$\"\n\n    Message:\n      path spec '/.foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/\\.foo$\n    + ^\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/.foo' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.662 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":115},"start":{"column":50,"line":115}}},{"id":"164","mutatorName":"ObjectLiteral","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                      ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:38)\n      at Policy.matches (src/policy.ts:133:117)\n      at PolicyMap.matches (src/policymap.ts:109:200)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                      ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:38)\n      at Rule.query (src/rule.ts:131:194)\n      at Policy.query (src/policy.ts:97:28)\n      at PolicyMap.query (src/policymap.ts:95:200)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✕ compiles literal path segments correctly (3 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (5 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"(?:)\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + (?:)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"(?:)\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + (?:)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"(?:)\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + (?:)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"(?:)\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + (?:)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"(?:)\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + (?:)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"(?:)\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + (?:)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"(?:)\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + (?:)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      \n659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                      ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:38)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                      ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:38)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                      ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:38)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                      ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:38)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                      ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:38)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                      ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:38)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                      ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:38)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                      ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:38)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                      ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:38)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                      ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:38)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                      ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:38)\n      at Rule.query (src/rule.ts:131:194)\n      at Object.<anonymous> (test/rule.ts:108:10)\n\n  ● rule › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                      ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:38)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.677 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":122},"start":{"column":10,"line":119}}},{"id":"165","mutatorName":"MethodExpression","replacement":"props","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (2 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\", \"bar\"]\n    Received:\n      [\"bar\", \"foo\"]\n\n    Message:\n      path spec '/:foo/:bar' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"foo\",\n        \"bar\",\n    +   \"foo\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.678 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":27,"line":121},"start":{"column":12,"line":121}}}],"source":"\n/** Extended regex for matching paths. */\nexport class Matcher extends RegExp {\n  /** Original path specification that produced this matcher. */\n  readonly spec: string\n  /** Context properties referenced by path specification. */\n  readonly props: string[]\n\n  /** @param spec Path specification.\n    * @param version Specification language version. */\n  constructor (spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    if (spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null) {\n      throw new Error('Path contains invalid characters')\n    }\n    if (spec.match(/^\\//) === null) {\n      throw new Error('Path must begin with a slash')\n    }\n    if (spec.match(/\\/\\//) !== null) {\n      throw new Error('Path contains empty segments')\n    }\n    if (spec.match(version === '1' || version === '1.0'\n      ? /[*+][^/]|[^/][*+]/\n      : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null) {\n      throw new Error('Path contains malformed wildcards')\n    }\n    if (spec.match(/[^/]:|:\\/|:$/) !== null) {\n      throw new Error('Path contains malformed captures')\n    }\n    if (spec.match(/^.+\\/$/) !== null) {\n      throw new Error('Path must not end with a slash')\n    }\n    const { regex, props } = compile(spec)\n    super(regex)\n    this.spec = spec\n    this.props = props\n  }\n\n  [Symbol.match] (string: string): RegExpMatchArray | null {\n    if (string.length > 1 && string.endsWith('/')) {\n      return null\n    }\n    return super[Symbol.match](string)\n  }\n\n  /** Static constructor function; returns a new Matcher.\n    * @param spec Path specification.\n    * @param version Specification language version. */\n  static for (spec: string, version: '1' | '1.0' | '1.1' = '1.1'): Matcher {\n    return new Matcher(spec, version)\n  }\n}\n\nfunction compile (spec: string): {\n  regex: string\n  props: string[]\n} {\n  const parts: string[] = []\n  const props: string[] = []\n  let min = 0\n  let max = 0\n  let any = false\n  let opt = true\n  function flatten (final: boolean = false): void {\n    if (max > 0 || any) {\n      if (final && opt && min < 1) {\n        min = 1\n      } else if (min > 0) {\n        opt = false\n      }\n      parts.push(any\n        ? min < 2\n          ? min < 1\n            ? '(?:/[^/]+)*'\n            : '(?:/[^/]+)+'\n          : `(?:/[^/]+){${min},}`\n        : max === 1\n          ? min === 1\n            ? '/[^/]+'\n            : '(?:/[^/]+)?'\n          : min === max\n            ? `(?:/[^/]+){${min}}`\n            : `(?:/[^/]+){${min},${max}}`)\n    }\n    min = 0\n    max = 0\n    any = false\n  }\n  function finalise (): string {\n    flatten(true)\n    return (opt ? '^/$|^' : '^') + parts.reduce((acc, seg) => seg + acc, '$')\n  }\n  for (const part of spec.split('/').slice(1).reverse()) {\n    switch (part) {\n      case '+':\n        min++\n        max++\n        break\n      case '++':\n        max++\n        break\n      case '*':\n        min++\n        any = true\n        break\n      case '**':\n        any = true\n        break\n      default:\n        flatten()\n        opt = false\n        if (part.match(/:.+/) !== null) {\n          props.push(part.slice(1))\n          parts.push('/([^/]+)')\n        } else {\n          parts.push(`/${part.replace(/([.$])/g, '\\\\$1')}`)\n        }\n    }\n  }\n  return {\n    regex: finalise(),\n    props: props.reverse()\n  }\n}\n"},"src/policy.ts":{"language":"typescript","mutants":[{"id":"166","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (4 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    TypeError: this.rules is not iterable\n\n      126 |     } else {\n      127 |       stryCov_9fa48(\"182\");\n    > 128 |       for (const rule of this.rules) {\n          |                               ^\n      129 |         if (stryMutAct_9fa48(\"183\")) {\n      130 |           {}\n      131 |         } else {\n\n      at Policy.matches (src/policy.ts:128:31)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:11:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: this.rules is not iterable\n\n      126 |     } else {\n      127 |       stryCov_9fa48(\"182\");\n    > 128 |       for (const rule of this.rules) {\n          |                               ^\n      129 |         if (stryMutAct_9fa48(\"183\")) {\n      130 |           {}\n      131 |         } else {\n\n      at Policy.matches (src/policy.ts:128:31)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: this.rules is not iterable\n\n      126 |     } else {\n      127 |       stryCov_9fa48(\"182\");\n    > 128 |       for (const rule of this.rules) {\n          |                               ^\n      129 |         if (stryMutAct_9fa48(\"183\")) {\n      130 |           {}\n      131 |         } else {\n\n      at Policy.matches (src/policy.ts:128:31)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: this.rules is not iterable\n\n      126 |     } else {\n      127 |       stryCov_9fa48(\"182\");\n    > 128 |       for (const rule of this.rules) {\n          |                               ^\n      129 |         if (stryMutAct_9fa48(\"183\")) {\n      130 |           {}\n      131 |         } else {\n\n      at Policy.matches (src/policy.ts:128:31)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: this.rules is not iterable\n\n      126 |     } else {\n      127 |       stryCov_9fa48(\"182\");\n    > 128 |       for (const rule of this.rules) {\n          |                               ^\n      129 |         if (stryMutAct_9fa48(\"183\")) {\n      130 |           {}\n      131 |         } else {\n\n      at Policy.matches (src/policy.ts:128:31)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: this.rules is not iterable (cannot read property undefined)\n\n      153 |     } else {\n      154 |       stryCov_9fa48(\"190\");\n    > 155 |       return deep ? new Policy(name, ...this.rules.map(stryMutAct_9fa48(\"191\") ? () => undefined : (stryCov_9fa48(\"191\"), rule => rule.clone()))) : new Policy(name, ...this.rules);\n          |                                                                                                                                                     ^\n      156 |     }\n      157 |   }\n      158 |\n\n      at Policy.clone (src/policy.ts:155:149)\n      at Object.<anonymous> (test/policy.ts:122:30)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.652 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":14},"start":{"column":48,"line":11}}},{"id":"167","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (2 ms)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.641 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":20},"start":{"column":35,"line":17}}},{"id":"168","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      undefined\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received undefined.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      undefined\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received undefined.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      undefined\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      undefined\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      undefined\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.661 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":42},"start":{"column":74,"line":30}}},{"id":"169","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (4 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (6 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.726 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":40},"start":{"column":36,"line":32}}},{"id":"170","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (7 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.684 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":24,"line":34},"start":{"column":11,"line":34}}},{"id":"171","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'boo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.67 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":24,"line":34},"start":{"column":11,"line":34}}},{"id":"172","mutatorName":"EqualityOperator","replacement":"res !== false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (6 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.678 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":24,"line":34},"start":{"column":11,"line":34}}},{"id":"173","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (5 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/bar', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.681 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":24,"line":34},"start":{"column":19,"line":34}}},{"id":"174","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'boo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.712 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":8,"line":36},"start":{"column":26,"line":34}}},{"id":"175","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (6 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'boo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.705 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":35},"start":{"column":16,"line":35}}},{"id":"176","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'shallow'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:138:5)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.648 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":37},"start":{"column":11,"line":37}}},{"id":"177","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.585 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":37},"start":{"column":11,"line":37}}},{"id":"178","mutatorName":"EqualityOperator","replacement":"res !== true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (2 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (5 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'shallow'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:138:5)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.536 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":37},"start":{"column":11,"line":37}}},{"id":"179","mutatorName":"BooleanLiteral","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (2 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (10 ms)\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.552 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":37},"start":{"column":19,"line":37}}},{"id":"180","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (5 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.672 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":8,"line":39},"start":{"column":25,"line":37}}},{"id":"181","mutatorName":"BooleanLiteral","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (18 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (2 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.586 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":38},"start":{"column":17,"line":38}}},{"id":"182","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (20 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      undefined\n\n    Message:\n      unexpected result from matches('static', '/')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      undefined\n\n    Message:\n      unexpected result from matches('/') for policy 'static'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:11:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      undefined\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      undefined\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      undefined\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      undefined\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      undefined\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.956 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":54},"start":{"column":55,"line":47}}},{"id":"183","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (8 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.657 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":52},"start":{"column":36,"line":48}}},{"id":"184","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.57 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":49},"start":{"column":11,"line":49}}},{"id":"185","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.53 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":49},"start":{"column":11,"line":49}}},{"id":"186","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.534 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":8,"line":51},"start":{"column":36,"line":49}}},{"id":"187","mutatorName":"BooleanLiteral","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.595 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":20,"line":50},"start":{"column":16,"line":50}}},{"id":"188","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'static'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:11:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        1.555 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":17,"line":53},"start":{"column":12,"line":53}}},{"id":"189","mutatorName":"BooleanLiteral","replacement":"false","status":"Survived","testsCompleted":1,"location":{"end":{"column":56,"line":59},"start":{"column":52,"line":59}}},{"id":"190","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                             ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.631 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":63},"start":{"column":66,"line":59}}},{"id":"191","mutatorName":"ArrowFunction","replacement":"() => undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      131 |         } else {\n      132 |           stryCov_9fa48(\"183\");\n    > 133 |           if (stryMutAct_9fa48(\"185\") ? false : stryMutAct_9fa48(\"184\") ? true : (stryCov_9fa48(\"184\", \"185\"), rule.matches(path, ctx))) {\n          |                                                                                                                     ^\n      134 |             if (stryMutAct_9fa48(\"186\")) {\n      135 |               {}\n      136 |             } else {\n\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.595 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":66,"line":61},"start":{"column":44,"line":61}}},{"id":"192","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'name')\n\n      56 |     } else {\n      57 |       stryCov_9fa48(\"193\");\n    > 58 |       super(policies.map(stryMutAct_9fa48(\"194\") ? () => undefined : (stryCov_9fa48(\"194\"), policy => stryMutAct_9fa48(\"195\") ? [] : (stryCov_9fa48(\"195\"), [policy.name, policy]))));\n         |                                                                                                                                                                     ^\n      59 |     }\n      60 |   }\n      61 |\n\n      at src/policymap.ts:58:165\n          at Array.map (<anonymous>)\n      at new PolicyMap (src/policymap.ts:58:22)\n      at Function.for (src/policymap.ts:119:14)\n      at Object.<anonymous> (test/policymap.ts:12:30)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'name')\n\n      56 |     } else {\n      57 |       stryCov_9fa48(\"193\");\n    > 58 |       super(policies.map(stryMutAct_9fa48(\"194\") ? () => undefined : (stryCov_9fa48(\"194\"), policy => stryMutAct_9fa48(\"195\") ? [] : (stryCov_9fa48(\"195\"), [policy.name, policy]))));\n         |                                                                                                                                                                     ^\n      59 |     }\n      60 |   }\n      61 |\n\n      at src/policymap.ts:58:165\n          at Array.map (<anonymous>)\n      at new PolicyMap (src/policymap.ts:58:22)\n      at Function.for (src/policymap.ts:119:14)\n      at Object.<anonymous> (test/policymap.ts:51:30)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                             ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:11:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                             ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                             ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                             ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                             ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'clone')\n\n      120 |     const rule = Rule.for('/test').allow('foo', 'bar')\n      121 |     const original = Policy.for('original', rule)\n    > 122 |     const shallow = original.clone('shallow', false)\n          |                              ^\n      123 |     const deep = original.clone('deep', true)\n      124 |     original.push(Rule.for('/test').allow('baz'))\n      125 |     rule.deny(\n\n      at Object.<anonymous> (test/policy.ts:122:30)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.682 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":68},"start":{"column":55,"line":66}}}],"source":"import { Rule } from './rule'\nimport { Queryable, QueryContext } from './queryable'\n\n/** Access-control policy. */\nexport class Policy implements Queryable {\n  /** Policy name. */\n  readonly name: string\n  /** Rules comprising policy. */\n  readonly rules: Rule[]\n\n  constructor (name: string, ...rules: Rule[]) {\n    this.name = name\n    this.rules = rules\n  }\n\n  /** Add rules to a policy. */\n  push (...rules: Rule[]): Policy {\n    this.rules.push(...rules)\n    return this\n  }\n\n  /** Check whether an action is allowed on a path.\n    * @param path Path to be acted on.\n    * @param verb Action to be performed.\n    * @param ctx Query context for resolving context-dependent paths.\n    * @returns Returns `true` if the action is explicitly allowed,\n    *          `false` if the action is explicitly denied, or\n    *          `null` if the combination of path and action\n    *          is not governed by this policy. */\n  query (path: string, verb: string, ctx?: QueryContext): boolean | null {\n    let allow = null\n    for (const rule of this.rules) {\n      const res = rule.query(path, verb, ctx)\n      if (res === false) {\n        return false\n      }\n      if (res === true) {\n        allow = true\n      }\n    }\n    return allow\n  }\n\n  /** Check whether a path is governed by this policy.\n    * @param path Path to be checked.\n    * @param ctx Query context for resolving context-dependent paths. */\n  matches (path: string, ctx?: QueryContext): boolean {\n    for (const rule of this.rules) {\n      if (rule.matches(path, ctx)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /** Create clone of a policy.\n    * @param name Replacement name for new policy.\n    * @param deep Deep copy; clone underlying rules as well. */\n  clone (name: string = this.name, deep: boolean = true): Policy {\n    return deep\n      ? new Policy(name, ...this.rules.map((rule) => rule.clone()))\n      : new Policy(name, ...this.rules)\n  }\n\n  /** Static constructor function; returns a new Policy. */\n  static for (name: string, ...rules: Rule[]): Policy {\n    return new Policy(name, ...rules)\n  }\n}\n"},"src/policymap.ts":{"language":"typescript","mutants":[{"id":"193","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      56 |     } else {\n      57 |       stryCov_9fa48(\"193\");\n    > 58 |       super(policies.map(stryMutAct_9fa48(\"194\") ? () => undefined : (stryCov_9fa48(\"194\"), policy => stryMutAct_9fa48(\"195\") ? [] : (stryCov_9fa48(\"195\"), [policy.name, policy]))));\n         |       ^\n      59 |     }\n      60 |   }\n      61 |\n\n      at new PolicyMap (src/policymap.ts:58:7)\n      at Function.for (src/policymap.ts:119:14)\n      at Object.<anonymous> (test/policymap.ts:12:30)\n\n  ● policymap › answers queries correctly\n\n    ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n      56 |     } else {\n      57 |       stryCov_9fa48(\"193\");\n    > 58 |       super(policies.map(stryMutAct_9fa48(\"194\") ? () => undefined : (stryCov_9fa48(\"194\"), policy => stryMutAct_9fa48(\"195\") ? [] : (stryCov_9fa48(\"195\"), [policy.name, policy]))));\n         |       ^\n      59 |     }\n      60 |   }\n      61 |\n\n      at new PolicyMap (src/policymap.ts:58:7)\n      at Function.for (src/policymap.ts:119:14)\n      at Object.<anonymous> (test/policymap.ts:51:30)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.652 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":8},"start":{"column":39,"line":6}}},{"id":"194","mutatorName":"ArrowFunction","replacement":"() => undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly\n\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: Iterator value undefined is not an entry object\n        at new Map (<anonymous>)\n\n      56 |     } else {\n      57 |       stryCov_9fa48(\"193\");\n    > 58 |       super(policies.map(stryMutAct_9fa48(\"194\") ? () => undefined : (stryCov_9fa48(\"194\"), policy => stryMutAct_9fa48(\"195\") ? [] : (stryCov_9fa48(\"195\"), [policy.name, policy]))));\n         |       ^\n      59 |     }\n      60 |   }\n      61 |\n\n      at new PolicyMap (src/policymap.ts:58:7)\n      at Function.for (src/policymap.ts:119:14)\n      at Object.<anonymous> (test/policymap.ts:12:30)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Iterator value undefined is not an entry object\n        at new Map (<anonymous>)\n\n      56 |     } else {\n      57 |       stryCov_9fa48(\"193\");\n    > 58 |       super(policies.map(stryMutAct_9fa48(\"194\") ? () => undefined : (stryCov_9fa48(\"194\"), policy => stryMutAct_9fa48(\"195\") ? [] : (stryCov_9fa48(\"195\"), [policy.name, policy]))));\n         |       ^\n      59 |     }\n      60 |   }\n      61 |\n\n      at new PolicyMap (src/policymap.ts:58:7)\n      at Function.for (src/policymap.ts:119:14)\n      at Object.<anonymous> (test/policymap.ts:51:30)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.706 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":57,"line":7},"start":{"column":24,"line":7}}},{"id":"195","mutatorName":"ArrayDeclaration","replacement":"[]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (7 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/policy.ts\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.702 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":57,"line":7},"start":{"column":36,"line":7}}},{"id":"196","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly (2 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                       ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'query')\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                       ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.766 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":16},"start":{"column":38,"line":11}}},{"id":"197","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.761 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":14},"start":{"column":36,"line":12}}},{"id":"198","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      undefined\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received undefined.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.674 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":32},"start":{"column":88,"line":27}}},{"id":"199","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'query')\n\n      93 |       stryCov_9fa48(\"198\");\n      94 |       const policy = this.get(name);\n    > 95 |       return (stryMutAct_9fa48(\"201\") ? policy === undefined : stryMutAct_9fa48(\"200\") ? false : stryMutAct_9fa48(\"199\") ? true : (stryCov_9fa48(\"199\", \"200\", \"201\"), policy !== undefined)) ? policy.query(path, verb, ctx) : null;\n         |                                                                                                                                                                                                        ^\n      96 |     }\n      97 |   }\n      98 |\n\n      at PolicyMap.query (src/policymap.ts:95:200)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.661 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":29},"start":{"column":12,"line":29}}},{"id":"200","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.698 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":29},"start":{"column":12,"line":29}}},{"id":"201","mutatorName":"EqualityOperator","replacement":"policy === undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.719 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":29},"start":{"column":12,"line":29}}},{"id":"202","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      undefined\n\n    Message:\n      unexpected result from matches('static', '/')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.761 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":43},"start":{"column":69,"line":38}}},{"id":"203","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      107 |       stryCov_9fa48(\"202\");\n      108 |       const policy = this.get(name);\n    > 109 |       return (stryMutAct_9fa48(\"205\") ? policy === undefined : stryMutAct_9fa48(\"204\") ? false : stryMutAct_9fa48(\"203\") ? true : (stryCov_9fa48(\"203\", \"204\", \"205\"), policy !== undefined)) ? policy.matches(path, ctx) : stryMutAct_9fa48(\"206\") ? true : (stryCov_9fa48(\"206\"), false);\n          |                                                                                                                                                                                                        ^\n      110 |     }\n      111 |   }\n      112 |\n\n      at PolicyMap.matches (src/policymap.ts:109:200)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.738 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":40},"start":{"column":12,"line":40}}},{"id":"204","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (8 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.684 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":40},"start":{"column":12,"line":40}}},{"id":"205","mutatorName":"EqualityOperator","replacement":"policy === undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✓ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.758 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":40},"start":{"column":12,"line":40}}},{"id":"206","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('unknown', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (3 ms)\n\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.636 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":14,"line":42},"start":{"column":9,"line":42}}},{"id":"207","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (5 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'push')\n\n      16 |       Policy.for('dynamic',\n      17 |         Rule.for('/yeah'),\n    > 18 |         Rule.for('/nah/+'))).push(\n         |                             ^\n      19 |       Policy.for('context',\n      20 |         Rule.for('/:maybe'),\n      21 |         Rule.for('/nah/:maybe')))\n\n      at Object.<anonymous> (test/policymap.ts:18:29)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'push')\n\n      57 |         Rule.for('/nah').deny('get'),\n      58 |         Rule.for('/yeah').allow('get'),\n    > 59 |         Rule.for('/nah/+').allow('get'))).push(\n         |                                          ^\n      60 |       Policy.for('context',\n      61 |         Rule.for('/nah').deny('get'),\n      62 |         Rule.for('/:maybe').allow('get'),\n\n      at Object.<anonymous> (test/policymap.ts:59:42)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.712 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":48},"start":{"column":49,"line":46}}}],"source":"import { Policy } from './policy'\nimport { QueryableMap, QueryContext } from './queryable'\n\n/** Queryable collection of policy documents. */\nexport class PolicyMap extends Map<string, Policy> implements QueryableMap {\n  constructor (...policies: Policy[]) {\n    super(policies.map((policy) => [policy.name, policy]))\n  }\n\n  /** Add policies to colllection. */\n  push (...policies: Policy[]): this {\n    for (const policy of policies) {\n      this.set(policy.name, policy)\n    }\n    return this\n  }\n\n  /** Check whether an action is allowed on a path.\n    * @param name Policy to be queried.\n    * @param path Path to be acted on.\n    * @param verb Action to be performed.\n    * @param ctx Query context for resolving context-dependent paths.\n    * @returns Returns `true` if the action is explicitly allowed,\n    *          `false` if the action is explicitly denied, or\n    *          `null` if the combination of policy, path and\n    *          action is not governed by this collection. */\n  query (name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n    const policy = this.get(name)\n    return policy !== undefined\n      ? policy.query(path, verb, ctx)\n      : null\n  }\n\n  /** Check whether a path is governed by a policy in this collection.\n    * @param name Policy to be queried.\n    * @param path Path to be checked.\n    * @param ctx Query context for resolving context-dependent paths. */\n  matches (name: string, path: string, ctx?: QueryContext): boolean {\n    const policy = this.get(name)\n    return policy !== undefined\n      ? policy.matches(path, ctx)\n      : false\n  }\n\n  /** Static constructor function; returns a new PolicyMap. */\n  static for (...policies: Policy[]): PolicyMap {\n    return new PolicyMap(...policies)\n  }\n}\n"},"src/rule.ts":{"language":"typescript","mutants":[{"id":"208","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'props')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:32)\n      at Policy.matches (src/policy.ts:133:117)\n      at PolicyMap.matches (src/policymap.ts:109:200)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'props')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:32)\n      at Rule.query (src/rule.ts:131:194)\n      at Policy.query (src/policy.ts:97:28)\n      at PolicyMap.query (src/policymap.ts:95:200)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'props')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:32)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'props')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:32)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'props')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:32)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'props')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:32)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'props')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:32)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'props')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:32)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'props')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:32)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'props')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:32)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'props')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:32)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'props')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:32)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'props')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:32)\n      at Rule.query (src/rule.ts:131:194)\n      at Object.<anonymous> (test/rule.ts:108:10)\n\n  ● rule › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'props')\n\n      158 |         }\n      159 |       }\n    > 160 |       const count = this.regex.props.length;\n          |                                ^\n      161 |       if (stryMutAct_9fa48(\"233\") ? count <= 0 : stryMutAct_9fa48(\"232\") ? count >= 0 : stryMutAct_9fa48(\"231\") ? false : stryMutAct_9fa48(\"230\") ? true : (stryCov_9fa48(\"230\", \"231\", \"232\", \"233\"), count > 0)) {\n      162 |         if (stryMutAct_9fa48(\"234\")) {\n      163 |           {}\n\n      at Rule.matches (src/rule.ts:160:32)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       14 failed, 24 passed, 38 total\nSnapshots:   0 total\nTime:        2.053 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":18},"start":{"column":40,"line":14}}},{"id":"209","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● rule › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                           ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                           ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'query')\n\n      104 |       Rule\n      105 |         .for('/test')\n    > 106 |         .deny('foo')\n          |             ^\n      107 |         .allow('foo')\n      108 |         .query('/test', 'foo'),\n      109 |       false)\n\n      at Object.<anonymous> (test/rule.ts:106:13)\n\n  ● rule › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'clone')\n\n      117 |   })\n      118 |   it('clones itself correctly', () => {\n    > 119 |     runTests({\n          |               ^\n      120 |       rule: Rule\n      121 |         .for('/nah')\n      122 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:119:17)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      131 |         } else {\n      132 |           stryCov_9fa48(\"183\");\n    > 133 |           if (stryMutAct_9fa48(\"185\") ? false : stryMutAct_9fa48(\"184\") ? true : (stryCov_9fa48(\"184\", \"185\"), rule.matches(path, ctx))) {\n          |                                                                                                                     ^\n      134 |             if (stryMutAct_9fa48(\"186\")) {\n      135 |               {}\n      136 |             } else {\n\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      131 |         } else {\n      132 |           stryCov_9fa48(\"183\");\n    > 133 |           if (stryMutAct_9fa48(\"185\") ? false : stryMutAct_9fa48(\"184\") ? true : (stryCov_9fa48(\"184\", \"185\"), rule.matches(path, ctx))) {\n          |                                                                                                                     ^\n      134 |             if (stryMutAct_9fa48(\"186\")) {\n      135 |               {}\n      136 |             } else {\n\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      131 |         } else {\n      132 |           stryCov_9fa48(\"183\");\n    > 133 |           if (stryMutAct_9fa48(\"185\") ? false : stryMutAct_9fa48(\"184\") ? true : (stryCov_9fa48(\"184\", \"185\"), rule.matches(path, ctx))) {\n          |                                                                                                                     ^\n      134 |             if (stryMutAct_9fa48(\"186\")) {\n      135 |               {}\n      136 |             } else {\n\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:109:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'clone')\n\n      153 |     } else {\n      154 |       stryCov_9fa48(\"190\");\n    > 155 |       return deep ? new Policy(name, ...this.rules.map(stryMutAct_9fa48(\"191\") ? () => undefined : (stryCov_9fa48(\"191\"), rule => rule.clone()))) : new Policy(name, ...this.rules);\n          |                                                                                                                                        ^\n      156 |     }\n      157 |   }\n      158 |\n\n      at src/policy.ts:155:136\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:155:52)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'query')\n\n       95 |         } else {\n       96 |           stryCov_9fa48(\"169\");\n    >  97 |           const res = rule.query(path, verb, ctx);\n          |                            ^\n       98 |           if (stryMutAct_9fa48(\"172\") ? res !== false : stryMutAct_9fa48(\"171\") ? false : stryMutAct_9fa48(\"170\") ? true : (stryCov_9fa48(\"170\", \"171\", \"172\"), res === (stryMutAct_9fa48(\"173\") ? true : (stryCov_9fa48(\"173\"), false)))) {\n       99 |             if (stryMutAct_9fa48(\"174\")) {\n      100 |               {}\n\n      at Policy.query (src/policy.ts:97:28)\n      at PolicyMap.query (src/policymap.ts:95:200)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.745 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":31},"start":{"column":36,"line":24}}},{"id":"210","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'bar') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.749 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":29},"start":{"column":31,"line":25}}},{"id":"211","mutatorName":"BooleanLiteral","replacement":"verb in this.verbs","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'bar') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (5 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.765 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":26},"start":{"column":11,"line":26}}},{"id":"212","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (2 ms)\n    ✓ clones itself correctly\n\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (3 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.596 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":26},"start":{"column":11,"line":26}}},{"id":"213","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'bar') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.628 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":26},"start":{"column":11,"line":26}}},{"id":"214","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'bar') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (3 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.876 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":8,"line":28},"start":{"column":34,"line":26}}},{"id":"215","mutatorName":"BooleanLiteral","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow (2 ms)\n    ✕ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (12 ms)\n    ✕ answers queries correctly (4 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (5 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/test', 'bar') for rule '/test'\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/:maybe'\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/yeah'\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (2 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.66 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":27},"start":{"column":28,"line":27}}},{"id":"216","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (8 ms)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      131 |         } else {\n      132 |           stryCov_9fa48(\"183\");\n    > 133 |           if (stryMutAct_9fa48(\"185\") ? false : stryMutAct_9fa48(\"184\") ? true : (stryCov_9fa48(\"184\", \"185\"), rule.matches(path, ctx))) {\n          |                                                                                                                     ^\n      134 |             if (stryMutAct_9fa48(\"186\")) {\n      135 |               {}\n      136 |             } else {\n\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'query')\n\n       95 |         } else {\n       96 |           stryCov_9fa48(\"169\");\n    >  97 |           const res = rule.query(path, verb, ctx);\n          |                            ^\n       98 |           if (stryMutAct_9fa48(\"172\") ? res !== false : stryMutAct_9fa48(\"171\") ? false : stryMutAct_9fa48(\"170\") ? true : (stryCov_9fa48(\"170\", \"171\", \"172\"), res === (stryMutAct_9fa48(\"173\") ? true : (stryCov_9fa48(\"173\"), false)))) {\n       99 |             if (stryMutAct_9fa48(\"174\")) {\n      100 |               {}\n\n      at Policy.query (src/policy.ts:97:28)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      131 |         } else {\n      132 |           stryCov_9fa48(\"183\");\n    > 133 |           if (stryMutAct_9fa48(\"185\") ? false : stryMutAct_9fa48(\"184\") ? true : (stryCov_9fa48(\"184\", \"185\"), rule.matches(path, ctx))) {\n          |                                                                                                                     ^\n      134 |             if (stryMutAct_9fa48(\"186\")) {\n      135 |               {}\n      136 |             } else {\n\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (2 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● rule › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'allow')\n\n      58 |       rule: Rule\n      59 |         .for('/test')\n    > 60 |         .deny('foo')\n         |                 ^\n      61 |         .allow('bar'),\n      62 |       tests: [\n      63 |         ['/',     false, 'foo', null],\n\n      at Object.<anonymous> (test/rule.ts:60:17)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'allow')\n\n      74 |       rule: Rule\n      75 |         .for('/:maybe')\n    > 76 |         .deny('foo')\n         |                 ^\n      77 |         .allow('bar'),\n      78 |       tests: [\n      79 |         ['/nah', false, 'foo', null],\n\n      at Object.<anonymous> (test/rule.ts:76:17)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'allow')\n\n      103 |     strictEqual(\n      104 |       Rule\n    > 105 |         .for('/test')\n          |             ^\n      106 |         .deny('foo')\n      107 |         .allow('foo')\n      108 |         .query('/test', 'foo'),\n\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'allow')\n\n      116 |       false)\n      117 |   })\n    > 118 |   it('clones itself correctly', () => {\n          |                 ^\n      119 |     runTests({\n      120 |       rule: Rule\n      121 |         .for('/nah')\n\n      at Object.<anonymous> (test/rule.ts:118:17)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'query')\n\n       95 |         } else {\n       96 |           stryCov_9fa48(\"169\");\n    >  97 |           const res = rule.query(path, verb, ctx);\n          |                            ^\n       98 |           if (stryMutAct_9fa48(\"172\") ? res !== false : stryMutAct_9fa48(\"171\") ? false : stryMutAct_9fa48(\"170\") ? true : (stryCov_9fa48(\"170\", \"171\", \"172\"), res === (stryMutAct_9fa48(\"173\") ? true : (stryCov_9fa48(\"173\"), false)))) {\n       99 |             if (stryMutAct_9fa48(\"174\")) {\n      100 |               {}\n\n      at Policy.query (src/policy.ts:97:28)\n      at PolicyMap.query (src/policymap.ts:95:200)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.309 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":39},"start":{"column":35,"line":34}}},{"id":"217","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'boo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.663 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":37},"start":{"column":31,"line":35}}},{"id":"218","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (5 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'boo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.889 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":31,"line":36},"start":{"column":26,"line":36}}},{"id":"219","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (3 ms)\n\n    ✕ answers context-dependent queries correctly (2 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      undefined\n\n    Message:\n      unexpected result from query('/', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received undefined.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      undefined\n\n    Message:\n      unexpected result from query('/nah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received undefined.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      undefined\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      undefined\n\n    Message:\n      unexpected result from query('/', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received undefined.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.659 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":54},"start":{"column":74,"line":49}}},{"id":"220","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/nah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.566 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":54,"line":50},"start":{"column":9,"line":50}}},{"id":"221","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (2 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (5 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.533 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":54,"line":50},"start":{"column":9,"line":50}}},{"id":"222","mutatorName":"LogicalOperator","replacement":"this.matches(path, ctx) || verb in this.verbs","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (2 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/nah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (1 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.546 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":54,"line":50},"start":{"column":9,"line":50}}},{"id":"223","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (5 ms)\n    ✕ answers queries correctly (5 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.518 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":52},"start":{"column":56,"line":50}}},{"id":"224","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (5 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      undefined\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      undefined\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      undefined\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      undefined\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      undefined\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received undefined.\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (7 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       14 failed, 24 passed, 38 total\nSnapshots:   0 total\nTime:        1.672 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":77},"start":{"column":55,"line":59}}},{"id":"225","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly (5 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       14 failed, 24 passed, 38 total\nSnapshots:   0 total\nTime:        1.668 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":61},"start":{"column":9,"line":61}}},{"id":"226","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of null (reading '1')\n\n      178 |               stryCov_9fa48(\"244\");\n      179 |               const prop = ctx[this.regex.props[index]];\n    > 180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n      183 |                 } else {\n\n      at Rule.matches (src/rule.ts:180:459)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of null (reading '1')\n\n      178 |               stryCov_9fa48(\"244\");\n      179 |               const prop = ctx[this.regex.props[index]];\n    > 180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n      183 |                 } else {\n\n      at Rule.matches (src/rule.ts:180:459)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (3 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.623 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":61},"start":{"column":9,"line":61}}},{"id":"227","mutatorName":"EqualityOperator","replacement":"match !== null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n  rule\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (5 ms)\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of null (reading '1')\n\n      178 |               stryCov_9fa48(\"244\");\n      179 |               const prop = ctx[this.regex.props[index]];\n    > 180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n      183 |                 } else {\n\n      at Rule.matches (src/rule.ts:180:459)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of null (reading '1')\n\n      178 |               stryCov_9fa48(\"244\");\n      179 |               const prop = ctx[this.regex.props[index]];\n    > 180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n      183 |                 } else {\n\n      at Rule.matches (src/rule.ts:180:459)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       14 failed, 24 passed, 38 total\nSnapshots:   0 total\nTime:        1.563 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":61},"start":{"column":9,"line":61}}},{"id":"228","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of null (reading '1')\n\n      178 |               stryCov_9fa48(\"244\");\n      179 |               const prop = ctx[this.regex.props[index]];\n    > 180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n      183 |                 } else {\n\n      at Rule.matches (src/rule.ts:180:459)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of null (reading '1')\n\n      178 |               stryCov_9fa48(\"244\");\n      179 |               const prop = ctx[this.regex.props[index]];\n    > 180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n      183 |                 } else {\n\n      at Rule.matches (src/rule.ts:180:459)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.681 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":63},"start":{"column":25,"line":61}}},{"id":"229","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (4 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nPASS test/matcher.ts\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.607 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":62},"start":{"column":14,"line":62}}},{"id":"230","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly (5 ms)\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.555 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":18,"line":65},"start":{"column":9,"line":65}}},{"id":"231","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.663 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":18,"line":65},"start":{"column":9,"line":65}}},{"id":"232","mutatorName":"EqualityOperator","replacement":"count >= 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.676 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":18,"line":65},"start":{"column":9,"line":65}}},{"id":"233","mutatorName":"EqualityOperator","replacement":"count <= 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (4 ms)\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       13 failed, 25 passed, 38 total\nSnapshots:   0 total\nTime:        1.649 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":18,"line":65},"start":{"column":9,"line":65}}},{"id":"234","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (9 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.597 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":75},"start":{"column":20,"line":65}}},{"id":"235","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.671 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":66},"start":{"column":11,"line":66}}},{"id":"236","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      177 |             } else {\n      178 |               stryCov_9fa48(\"244\");\n    > 179 |               const prop = ctx[this.regex.props[index]];\n          |                               ^\n      180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n\n      at Rule.matches (src/rule.ts:179:31)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      177 |             } else {\n      178 |               stryCov_9fa48(\"244\");\n    > 179 |               const prop = ctx[this.regex.props[index]];\n          |                               ^\n      180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n\n      at Rule.matches (src/rule.ts:179:31)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      177 |             } else {\n      178 |               stryCov_9fa48(\"244\");\n    > 179 |               const prop = ctx[this.regex.props[index]];\n          |                               ^\n      180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n\n      at Rule.matches (src/rule.ts:179:31)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        1.634 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":66},"start":{"column":11,"line":66}}},{"id":"237","mutatorName":"EqualityOperator","replacement":"ctx !== undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      177 |             } else {\n      178 |               stryCov_9fa48(\"244\");\n    > 179 |               const prop = ctx[this.regex.props[index]];\n          |                               ^\n      180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n\n      at Rule.matches (src/rule.ts:179:31)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      177 |             } else {\n      178 |               stryCov_9fa48(\"244\");\n    > 179 |               const prop = ctx[this.regex.props[index]];\n          |                               ^\n      180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n\n      at Rule.matches (src/rule.ts:179:31)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      177 |             } else {\n      178 |               stryCov_9fa48(\"244\");\n    > 179 |               const prop = ctx[this.regex.props[index]];\n          |                               ^\n      180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n\n      at Rule.matches (src/rule.ts:179:31)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.611 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":66},"start":{"column":11,"line":66}}},{"id":"238","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      177 |             } else {\n      178 |               stryCov_9fa48(\"244\");\n    > 179 |               const prop = ctx[this.regex.props[index]];\n          |                               ^\n      180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n\n      at Rule.matches (src/rule.ts:179:31)\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      177 |             } else {\n      178 |               stryCov_9fa48(\"244\");\n    > 179 |               const prop = ctx[this.regex.props[index]];\n          |                               ^\n      180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n\n      at Rule.matches (src/rule.ts:179:31)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      177 |             } else {\n      178 |               stryCov_9fa48(\"244\");\n    > 179 |               const prop = ctx[this.regex.props[index]];\n          |                               ^\n      180 |               if (stryMutAct_9fa48(\"247\") ? prop === undefined && match[index + 1] !== prop : stryMutAct_9fa48(\"246\") ? false : stryMutAct_9fa48(\"245\") ? true : (stryCov_9fa48(\"245\", \"246\", \"247\"), (stryMutAct_9fa48(\"249\") ? prop !== undefined : stryMutAct_9fa48(\"248\") ? false : (stryCov_9fa48(\"248\", \"249\"), prop === undefined)) || (stryMutAct_9fa48(\"251\") ? match[index + 1] === prop : stryMutAct_9fa48(\"250\") ? false : (stryCov_9fa48(\"250\", \"251\"), match[stryMutAct_9fa48(\"252\") ? index - 1 : (stryCov_9fa48(\"252\"), index + 1)] !== prop)))) {\n      181 |                 if (stryMutAct_9fa48(\"253\")) {\n      182 |                   {}\n\n      at Rule.matches (src/rule.ts:179:31)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        1.725 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":8,"line":68},"start":{"column":30,"line":66}}},{"id":"239","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        1.678 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":67},"start":{"column":16,"line":67}}},{"id":"240","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (4 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.688 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":69},"start":{"column":27,"line":69}}},{"id":"241","mutatorName":"EqualityOperator","replacement":"index <= count","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.665 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":69},"start":{"column":27,"line":69}}},{"id":"242","mutatorName":"EqualityOperator","replacement":"index >= count","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.738 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":69},"start":{"column":27,"line":69}}},{"id":"243","mutatorName":"UpdateOperator","replacement":"index--","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (3 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.632 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":49,"line":69},"start":{"column":42,"line":69}}},{"id":"244","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.675 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":8,"line":74},"start":{"column":51,"line":69}}},{"id":"245","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.754 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":60,"line":71},"start":{"column":13,"line":71}}},{"id":"246","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.741 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":60,"line":71},"start":{"column":13,"line":71}}},{"id":"247","mutatorName":"LogicalOperator","replacement":"prop === undefined && match[index + 1] !== prop","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (8 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/rule.ts\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.755 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":60,"line":71},"start":{"column":13,"line":71}}},{"id":"248","mutatorName":"ConditionalExpression","replacement":"false","status":"Survived","testsCompleted":1,"location":{"end":{"column":31,"line":71},"start":{"column":13,"line":71}}},{"id":"249","mutatorName":"EqualityOperator","replacement":"prop !== undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.691 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":31,"line":71},"start":{"column":13,"line":71}}},{"id":"250","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (7 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/rule.ts\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.734 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":60,"line":71},"start":{"column":35,"line":71}}},{"id":"251","mutatorName":"EqualityOperator","replacement":"match[index + 1] === prop","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.755 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":60,"line":71},"start":{"column":35,"line":71}}},{"id":"252","mutatorName":"ArithmeticOperator","replacement":"index - 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (5 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (10 ms)\n\n    ✓ answers queries correctly (3 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.716 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":50,"line":71},"start":{"column":41,"line":71}}},{"id":"253","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (7 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.726 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":10,"line":73},"start":{"column":62,"line":71}}},{"id":"254","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (3 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly (3 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.739 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":72},"start":{"column":18,"line":72}}},{"id":"255","mutatorName":"BooleanLiteral","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (7 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (2 ms)\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       14 failed, 24 passed, 38 total\nSnapshots:   0 total\nTime:        1.799 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":16,"line":76},"start":{"column":12,"line":76}}},{"id":"256","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (3 ms)\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● rule › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                           ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      131 |         } else {\n      132 |           stryCov_9fa48(\"183\");\n    > 133 |           if (stryMutAct_9fa48(\"185\") ? false : stryMutAct_9fa48(\"184\") ? true : (stryCov_9fa48(\"184\", \"185\"), rule.matches(path, ctx))) {\n          |                                                                                                                     ^\n      134 |             if (stryMutAct_9fa48(\"186\")) {\n      135 |               {}\n      136 |             } else {\n\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.877 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":87},"start":{"column":53,"line":81}}},{"id":"257","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (2 ms)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (2 ms)\n\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.781 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":85},"start":{"column":36,"line":83}}},{"id":"258","mutatorName":"BlockStatement","replacement":"{}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      131 |         } else {\n      132 |           stryCov_9fa48(\"183\");\n    > 133 |           if (stryMutAct_9fa48(\"185\") ? false : stryMutAct_9fa48(\"184\") ? true : (stryCov_9fa48(\"184\", \"185\"), rule.matches(path, ctx))) {\n          |                                                                                                                     ^\n      134 |             if (stryMutAct_9fa48(\"186\")) {\n      135 |               {}\n      136 |             } else {\n\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      131 |         } else {\n      132 |           stryCov_9fa48(\"183\");\n    > 133 |           if (stryMutAct_9fa48(\"185\") ? false : stryMutAct_9fa48(\"184\") ? true : (stryCov_9fa48(\"184\", \"185\"), rule.matches(path, ctx))) {\n          |                                                                                                                     ^\n      134 |             if (stryMutAct_9fa48(\"186\")) {\n      135 |               {}\n      136 |             } else {\n\n      at Policy.matches (src/policy.ts:133:117)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'allow')\n\n      56 |     runTests({\n      57 |       policy: Policy.for('test',\n    > 58 |         Rule.for('/foo').allow('foo'),\n         |                         ^\n      59 |         Rule.for('/bar').allow('bar'),\n      60 |         Rule.for('/*').deny('boo')),\n      61 |       tests: [\n\n      at Object.<anonymous> (test/policy.ts:58:25)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'allow')\n\n      78 |     runTests({\n      79 |       policy: Policy.for('test',\n    > 80 |         Rule.for('/:foo').allow('foo'),\n         |                          ^\n      81 |         Rule.for('/:bar').allow('bar'),\n      82 |         Rule.for('/:boo').deny('boo')),\n      83 |       ctx: {\n\n      at Object.<anonymous> (test/policy.ts:80:26)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'deny')\n\n      100 |     runTests({\n      101 |       policy: Policy.for('deny first',\n    > 102 |         Rule.for('/*').deny('foo'),\n          |                       ^\n      103 |         Rule.for('/foo').allow('foo')),\n      104 |       tests: [\n      105 |         ['/foo', true, 'foo', false],\n\n      at Object.<anonymous> (test/policy.ts:102:23)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'allow')\n\n      118 |   })\n      119 |   it('clones itself correctly', () => {\n    > 120 |     const rule = Rule.for('/test').allow('foo', 'bar')\n          |                                   ^\n      121 |     const original = Policy.for('original', rule)\n      122 |     const shallow = original.clone('shallow', false)\n      123 |     const deep = original.clone('deep', true)\n\n      at Object.<anonymous> (test/policy.ts:120:35)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (4 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                           ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                           ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'deny')\n\n      57 |     runTests({\n      58 |       rule: Rule\n    > 59 |         .for('/test')\n         |                 ^\n      60 |         .deny('foo')\n      61 |         .allow('bar'),\n      62 |       tests: [\n\n      at Object.<anonymous> (test/rule.ts:59:17)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'deny')\n\n      73 |     runTests({\n      74 |       rule: Rule\n    > 75 |         .for('/:maybe')\n         |                 ^\n      76 |         .deny('foo')\n      77 |         .allow('bar'),\n      78 |       tests: [\n\n      at Object.<anonymous> (test/rule.ts:75:17)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'deny')\n\n      102 |   it('prioritises deny over allow', () => {\n      103 |     strictEqual(\n    > 104 |       Rule\n          |           ^\n      105 |         .for('/test')\n      106 |         .deny('foo')\n      107 |         .allow('foo')\n\n      at Object.<anonymous> (test/rule.ts:104:13)\n\n  ● rule › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'deny')\n\n      115 |         .query('/test', 'foo'),\n      116 |       false)\n    > 117 |   })\n          |     ^\n      118 |   it('clones itself correctly', () => {\n      119 |     runTests({\n      120 |       rule: Rule\n\n      at Object.<anonymous> (test/rule.ts:117:17)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'matches')\n\n      131 |         } else {\n      132 |           stryCov_9fa48(\"183\");\n    > 133 |           if (stryMutAct_9fa48(\"185\") ? false : stryMutAct_9fa48(\"184\") ? true : (stryCov_9fa48(\"184\", \"185\"), rule.matches(path, ctx))) {\n          |                                                                                                                     ^\n      134 |             if (stryMutAct_9fa48(\"186\")) {\n      135 |               {}\n      136 |             } else {\n\n      at Policy.matches (src/policy.ts:133:117)\n      at PolicyMap.matches (src/policymap.ts:109:200)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'deny')\n\n      51 |     const map = PolicyMap.for(\n      52 |       Policy.for('static',\n    > 53 |         Rule.for('/nah').deny('get'),\n         |                         ^\n      54 |         Rule.for('/yeah').allow('get'),\n      55 |         Rule.for('/nah/yeah').allow('get')),\n      56 |       Policy.for('dynamic',\n\n      at Object.<anonymous> (test/policymap.ts:53:25)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       14 failed, 24 passed, 38 total\nSnapshots:   0 total\nTime:        1.747 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":94},"start":{"column":45,"line":92}}}],"source":"import { Matcher } from './matcher'\nimport { Queryable, QueryContext } from './queryable'\n\n/** Access-control rule for a single path. */\nexport class Rule implements Queryable {\n  /** Pattern for determining which paths are governed by this rule. */\n  readonly regex: Matcher\n  /** Set of verbs governed by this rule; allowed verbs\n    * are marked as `true`, denied verbs as `false`. */\n  readonly verbs: { [index: string]: boolean } = {}\n\n  /** @param spec Path specification or pre-compiled matcher for\n    *             determining which paths this rule will apply to. */\n  constructor (spec: string | Matcher) {\n    this.regex = spec instanceof Matcher\n      ? spec\n      : new Matcher(spec)\n  }\n\n  /** Mark one or more verbs as allowed.\n    * @note Deny overrides allow within SPACL policies;\n    *       this method will have no effect on verbs\n    *       previously marked as denied. */\n  allow (...verbs: string[]): Rule {\n    for (const verb of verbs) {\n      if (!(verb in this.verbs)) {\n        this.verbs[verb] = true\n      }\n    }\n    return this\n  }\n\n  /** Mark one or more verbs as denied. */\n  deny (...verbs: string[]): Rule {\n    for (const verb of verbs) {\n      this.verbs[verb] = false\n    }\n    return this\n  }\n\n  /** Check whether an action is allowed on a path.\n    * @param path Path to be acted on.\n    * @param verb Action to be performed.\n    * @param ctx Query context for resolving context-dependent paths.\n    * @returns Returns `true` if the action is explicitly allowed,\n    *          `false` if the action is explicitly denied, or\n    *          `null` if the combination of path and action\n    *          is not governed by this rule. */\n  query (path: string, verb: string, ctx?: QueryContext): boolean | null {\n    if (this.matches(path, ctx) && verb in this.verbs) {\n      return this.verbs[verb]\n    }\n    return null\n  }\n\n  /** Check whether a path is governed by this rule.\n    * @param path Path to be checked.\n    * @param ctx Query context for resolving context-dependent paths. */\n  matches (path: string, ctx?: QueryContext): boolean {\n    const match = path.match(this.regex)\n    if (match === null) {\n      return false\n    }\n    const count = this.regex.props.length\n    if (count > 0) {\n      if (ctx === undefined) {\n        return false\n      }\n      for (let index = 0; index < count; index++) {\n        const prop = ctx[this.regex.props[index]]\n        if (prop === undefined || match[index + 1] !== prop) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  /** Create clone of a rule.\n    * @param spec Replacement path specification for the new rule. */\n  clone (spec: string | Matcher = this.regex): Rule {\n    const rule = new Rule(spec)\n    for (const verb in this.verbs) {\n      rule.verbs[verb] = this.verbs[verb]\n    }\n    return rule\n  }\n\n  /** Static constructor function; returns a new Rule.\n    * @param spec Path specification or pre-compiled matcher for\n    *             determining which paths this rule will apply to. */\n  static for (spec: string | Matcher): Rule {\n    return new Rule(spec)\n  }\n}\n"}},"schemaVersion":"1.0","thresholds":{"high":80,"low":60,"break":null},"testFiles":{"":{"tests":[{"id":"0","name":"All tests"}]}},"projectRoot":"/Users/jon/Documents/NEU/Projects/llm-mutation-testing/projects/spacl-core","config":{"concurrency":1,"mutate":["src/index.ts","src/matcher.ts","src/policy.ts","src/policymap.ts","src/queryable.ts","src/rule.ts"],"reporters":["json","html","progress"],"allowConsoleColors":true,"checkers":[],"checkerNodeArgs":[],"commandRunner":{"command":"npm test"},"coverageAnalysis":"perTest","clearTextReporter":{"allowColor":true,"allowEmojis":false,"logTests":true,"maxTestsToLog":3,"reportTests":true,"reportMutants":true,"reportScoreTable":true},"dashboard":{"baseUrl":"https://dashboard.stryker-mutator.io/api/reports","reportType":"full"},"dryRunOnly":false,"eventReporter":{"baseDir":"reports/mutation/events"},"ignorePatterns":[],"ignoreStatic":false,"incremental":false,"incrementalFile":"reports/stryker-incremental.json","force":false,"fileLogLevel":"off","inPlace":false,"logLevel":"info","maxConcurrentTestRunners":9007199254740991,"maxTestRunnerReuse":0,"mutator":{"plugins":null,"excludedMutations":[]},"plugins":["@stryker-mutator/*"],"appendPlugins":[],"htmlReporter":{"fileName":"reports/mutation/mutation.html"},"jsonReporter":{"fileName":"reports/mutation/mutation.json"},"disableTypeChecks":true,"symlinkNodeModules":true,"tempDirName":".stryker-tmp","cleanTempDir":true,"testRunner":"command","testRunnerNodeArgs":[],"thresholds":{"high":80,"low":60,"break":null},"timeoutFactor":1.5,"timeoutMS":5000,"dryRunTimeoutMinutes":5,"tsconfigFile":"tsconfig.json","warnings":true,"disableBail":false,"allowEmpty":false,"ignorers":[],"cucumber":{},"jest":{"projectType":"custom","enableFindRelatedTests":true},"mochaOptions":{},"tap":{"testFiles":["{**/@(test|tests|__test__|__tests__)/**,**/*.@(test|tests|spec)}.@(cjs|mjs|js|jsx|ts|tsx|mts|cts)"],"nodeArgs":["-r","{{hookFile}}","{{testFile}}"],"forceBail":true},"vitest":{}},"framework":{"name":"StrykerJS","version":"8.2.5","branding":{"homepageUrl":"https://stryker-mutator.io","imageUrl":"data:image/svg+xml;utf8,%3Csvg viewBox='0 0 1458 1458' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' clip-rule='evenodd' stroke-linejoin='round' stroke-miterlimit='2'%3E%3Cpath fill='none' d='M0 0h1458v1458H0z'/%3E%3CclipPath id='a'%3E%3Cpath d='M0 0h1458v1458H0z'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23a)'%3E%3Cpath d='M1458 729c0 402.655-326.345 729-729 729S0 1131.655 0 729C0 326.445 326.345 0 729 0s729 326.345 729 729' fill='%23e74c3c' fill-rule='nonzero'/%3E%3Cpath d='M778.349 1456.15L576.6 1254.401l233-105 85-78.668v-64.332l-257-257-44-187-50-208 251.806-82.793L1076.6 389.401l380.14 379.15c-19.681 367.728-311.914 663.049-678.391 687.599z' fill-opacity='.3'/%3E%3Cpath d='M753.4 329.503c41.79 0 74.579 7.83 97.925 25.444 23.571 18.015 41.69 43.956 55.167 77.097l11.662 28.679 165.733-58.183-14.137-32.13c-26.688-60.655-64.896-108.61-114.191-144.011-49.329-35.423-117.458-54.302-204.859-54.302-50.78 0-95.646 7.376-134.767 21.542-40.093 14.671-74.09 34.79-102.239 60.259-28.84 26.207-50.646 57.06-65.496 92.701-14.718 35.052-22.101 72.538-22.101 112.401 0 72.536 20.667 133.294 61.165 182.704 38.624 47.255 98.346 88.037 179.861 121.291 42.257 17.475 78.715 33.125 109.227 46.994 27.193 12.361 49.294 26.124 66.157 41.751 15.309 14.186 26.497 30.584 33.63 49.258 7.721 20.214 11.16 45.69 11.16 76.402 0 28.021-4.251 51.787-13.591 71.219-8.832 18.374-20.171 33.178-34.523 44.219-14.787 11.374-31.193 19.591-49.393 24.466-19.68 5.359-39.14 7.993-58.69 7.993-29.359 0-54.387-3.407-75.182-10.747-20.112-7.013-37.144-16.144-51.259-27.486-13.618-11.009-24.971-23.766-33.744-38.279-9.64-15.8-17.272-31.924-23.032-48.408l-10.965-31.376-161.669 60.585 10.734 30.124c10.191 28.601 24.197 56.228 42.059 82.748 18.208 27.144 41.322 51.369 69.525 72.745 27.695 21.075 60.904 38.218 99.481 51.041 37.777 12.664 82.004 19.159 132.552 19.159 49.998 0 95.818-8.321 137.611-24.622 42.228-16.471 78.436-38.992 108.835-67.291 30.719-28.597 54.631-62.103 71.834-100.642 17.263-38.56 25.923-79.392 25.923-122.248 0-54.339-8.368-100.37-24.208-138.32-16.29-38.759-38.252-71.661-65.948-98.797-26.965-26.418-58.269-48.835-93.858-67.175-33.655-17.241-69.196-33.11-106.593-47.533-35.934-13.429-65.822-26.601-89.948-39.525-22.153-11.868-40.009-24.21-53.547-37.309-11.429-11.13-19.83-23.678-24.718-37.664-5.413-15.49-7.98-33.423-7.98-53.577 0-40.883 11.293-71.522 37.086-90.539 28.443-20.825 64.985-30.658 109.311-30.658z' fill='%23f1c40f' fill-rule='nonzero'/%3E%3Cpath d='M720 0h18v113h-18zM1458 738v-18h-113v18h113zM720 1345h18v113h-18zM113 738v-18H0v18h113z'/%3E%3C/g%3E%3C/svg%3E"},"dependencies":{"@stryker-mutator/mocha-runner":"8.2.5","@stryker-mutator/karma-runner":"8.2.5","@stryker-mutator/jasmine-runner":"8.2.5","@stryker-mutator/jest-runner":"8.2.5","mocha":"10.4.0","jasmine-core":"5.1.2","jest":"27.5.1","typescript":"4.9.5","ts-jest":"27.1.5"}}}