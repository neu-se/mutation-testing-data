[32m13:05:59 (2224) INFO ConfigReader[39m No config file specified. Running with command line arguments.
[32m13:05:59 (2224) INFO ConfigReader[39m Use `stryker init` command to generate your config file.
[33m13:05:59 (2224) WARN PluginLoader[39m Error during loading "@stryker-mutator/karma-runner" plugin:
  Cannot find module 'karma'
Require stack:
- /home/runner/work/llm-mutation-testing/llm-mutation-testing/q/node_modules/@stryker-mutator/util/dist/src/require-resolve.js
[32m13:05:59 (2224) INFO ProjectReader[39m Found 2 of 47 file(s) to be mutated.
*** using standard mutators ***
Mutant 0 in q.js: {
  "use strict";

  // This file will function properly as a <script> tag, or a module
  // using CommonJS and NodeJS or RequireJS module formats.  In
  // Common/Node/RequireJS, the module exports the Q API and when
  // executed as a simple <script>, it creates a Q global instead.

  // Montage Require
  if (typeof bootstrap === "function") {
    bootstrap("promise", definition);

    // CommonJS
  } else if (typeof exports === "object" && typeof module === "object") {
    module.exports = definition();

    // RequireJS
  } else if (typeof define === "function" && define.amd) {
    define(definition);

    // SES (Secure EcmaScript)
  } else if (typeof ses !== "undefined") {
    if (!ses.ok()) {
      return;
    } else {
      ses.makeQ = definition;
    }

    // <script>
  } else if (typeof window !== "undefined" || typeof self !== "undefined") {
    // Prefer window over self for add-on scripts. Use self for
    // non-windowed contexts.
    var global = typeof window !== "undefined" ? window : self;

    // Get the `window` object, save the previous Q global
    // and initialize Q as a global.
    var previousQ = global.Q;
    global.Q = definition();

    // Add a noConflict function so Q can be removed from the
    // global namespace.
    global.Q.noConflict = function () {
      global.Q = previousQ;
      return this;
    };
  } else {
    throw new Error("This environment was not anticipated by Q. Please file a bug.");
  }
} replaced with {}
Mutant 1 in q.js: typeof bootstrap === "function" replaced with true
Mutant 2 in q.js: typeof bootstrap === "function" replaced with false
Mutant 3 in q.js: typeof bootstrap === "function" replaced with typeof bootstrap !== "function"
Mutant 4 in q.js: "function" replaced with ""
Mutant 5 in q.js: {
  bootstrap("promise", definition);

  // CommonJS
} replaced with {}
Mutant 6 in q.js: "promise" replaced with ""
Mutant 7 in q.js: typeof exports === "object" && typeof module === "object" replaced with true
Mutant 8 in q.js: typeof exports === "object" && typeof module === "object" replaced with false
Mutant 9 in q.js: typeof exports === "object" && typeof module === "object" replaced with typeof exports === "object" || typeof module === "object"
Mutant 10 in q.js: typeof exports === "object" replaced with true
Mutant 11 in q.js: typeof exports === "object" replaced with typeof exports !== "object"
Mutant 12 in q.js: "object" replaced with ""
Mutant 13 in q.js: typeof module === "object" replaced with true
Mutant 14 in q.js: typeof module === "object" replaced with typeof module !== "object"
Mutant 15 in q.js: "object" replaced with ""
Mutant 16 in q.js: {
  module.exports = definition();

  // RequireJS
} replaced with {}
Mutant 17 in q.js: typeof define === "function" && define.amd replaced with true
Mutant 18 in q.js: typeof define === "function" && define.amd replaced with false
Mutant 19 in q.js: typeof define === "function" && define.amd replaced with typeof define === "function" || define.amd
Mutant 20 in q.js: typeof define === "function" replaced with true
Mutant 21 in q.js: typeof define === "function" replaced with typeof define !== "function"
Mutant 22 in q.js: "function" replaced with ""
Mutant 23 in q.js: {
  define(definition);

  // SES (Secure EcmaScript)
} replaced with {}
Mutant 24 in q.js: typeof ses !== "undefined" replaced with true
Mutant 25 in q.js: typeof ses !== "undefined" replaced with false
Mutant 26 in q.js: typeof ses !== "undefined" replaced with typeof ses === "undefined"
Mutant 27 in q.js: "undefined" replaced with ""
Mutant 28 in q.js: {
  if (!ses.ok()) {
    return;
  } else {
    ses.makeQ = definition;
  }

  // <script>
} replaced with {}
Mutant 29 in q.js: !ses.ok() replaced with ses.ok()
Mutant 30 in q.js: !ses.ok() replaced with true
Mutant 31 in q.js: !ses.ok() replaced with false
Mutant 32 in q.js: {
  return;
} replaced with {}
Mutant 33 in q.js: {
  ses.makeQ = definition;
} replaced with {}
Mutant 34 in q.js: typeof window !== "undefined" || typeof self !== "undefined" replaced with true
Mutant 35 in q.js: typeof window !== "undefined" || typeof self !== "undefined" replaced with false
Mutant 36 in q.js: typeof window !== "undefined" || typeof self !== "undefined" replaced with typeof window !== "undefined" && typeof self !== "undefined"
Mutant 37 in q.js: typeof window !== "undefined" replaced with false
Mutant 38 in q.js: typeof window !== "undefined" replaced with typeof window === "undefined"
Mutant 39 in q.js: "undefined" replaced with ""
Mutant 40 in q.js: typeof self !== "undefined" replaced with false
Mutant 41 in q.js: typeof self !== "undefined" replaced with typeof self === "undefined"
Mutant 42 in q.js: "undefined" replaced with ""
Mutant 43 in q.js: {
  // Prefer window over self for add-on scripts. Use self for
  // non-windowed contexts.
  var global = typeof window !== "undefined" ? window : self;

  // Get the `window` object, save the previous Q global
  // and initialize Q as a global.
  var previousQ = global.Q;
  global.Q = definition();

  // Add a noConflict function so Q can be removed from the
  // global namespace.
  global.Q.noConflict = function () {
    global.Q = previousQ;
    return this;
  };
} replaced with {}
Mutant 44 in q.js: typeof window !== "undefined" replaced with true
Mutant 45 in q.js: typeof window !== "undefined" replaced with false
Mutant 46 in q.js: typeof window !== "undefined" replaced with typeof window === "undefined"
Mutant 47 in q.js: "undefined" replaced with ""
Mutant 48 in q.js: {
  global.Q = previousQ;
  return this;
} replaced with {}
Mutant 49 in q.js: {
  throw new Error("This environment was not anticipated by Q. Please file a bug.");
} replaced with {}
Mutant 50 in q.js: "This environment was not anticipated by Q. Please file a bug." replaced with ""
Mutant 51 in q.js: {
  "use strict";

  var hasStacks = false;
  try {
    throw new Error();
  } catch (e) {
    hasStacks = !!e.stack;
  }

  // All code after this point will be filtered from stack traces reported
  // by Q.
  var qStartingLine = captureLine();
  var qFileName;

  // shims

  // used for fallback in "allResolved"
  var noop = function () {};

  // Use the fastest possible means to execute a task in a future turn
  // of the event loop.
  var nextTick = function () {
    // linked list of tasks (single, with head node)
    var head = {
      task: void 0,
      next: null
    };
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];
    function flush() {
      /* jshint loopfunc: true */
      var task, domain;
      while (head.next) {
        head = head.next;
        task = head.task;
        head.task = void 0;
        domain = head.domain;
        if (domain) {
          head.domain = void 0;
          domain.enter();
        }
        runSingle(task, domain);
      }
      while (laterQueue.length) {
        task = laterQueue.pop();
        runSingle(task);
      }
      flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
      try {
        task();
      } catch (e) {
        if (isNodeJS) {
          // In node, uncaught exceptions are considered fatal errors.
          // Re-throw them synchronously to interrupt flushing!

          // Ensure continuation if the uncaught exception is suppressed
          // listening "uncaughtException" events (as domains does).
          // Continue in next event to avoid tick recursion.
          if (domain) {
            domain.exit();
          }
          setTimeout(flush, 0);
          if (domain) {
            domain.enter();
          }
          throw e;
        } else {
          // In browsers, uncaught exceptions are not fatal.
          // Re-throw them asynchronously to avoid slow-downs.
          setTimeout(function () {
            throw e;
          }, 0);
        }
      }
      if (domain) {
        domain.exit();
      }
    }
    nextTick = function (task) {
      tail = tail.next = {
        task: task,
        domain: isNodeJS && process.domain,
        next: null
      };
      if (!flushing) {
        flushing = true;
        requestTick();
      }
    };
    if (typeof process === "object" && process.toString() === "[object process]" && process.nextTick) {
      // Ensure Q is in a real Node environment, with a `process.nextTick`.
      // To see through fake Node environments:
      // * Mocha test runner - exposes a `process` global without a `nextTick`
      // * Browserify - exposes a `process.nexTick` function that uses
      //   `setTimeout`. In this case `setImmediate` is preferred because
      //    it is faster. Browserify's `process.toString()` yields
      //   "[object Object]", while in a real Node environment
      //   `process.toString()` yields "[object process]".
      isNodeJS = true;
      requestTick = function () {
        process.nextTick(flush);
      };
    } else if (typeof setImmediate === "function") {
      // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
      if (typeof window !== "undefined") {
        requestTick = setImmediate.bind(window, flush);
      } else {
        requestTick = function () {
          setImmediate(flush);
        };
      }
    } else if (typeof MessageChannel !== "undefined") {
      // modern browsers
      // http://www.nonblocking.io/2011/06/windownexttick.html
      var channel = new MessageChannel();
      // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
      // working message ports the first time a page loads.
      channel.port1.onmessage = function () {
        requestTick = requestPortTick;
        channel.port1.onmessage = flush;
        flush();
      };
      var requestPortTick = function () {
        // Opera requires us to provide a message payload, regardless of
        // whether we use it.
        channel.port2.postMessage(0);
      };
      requestTick = function () {
        setTimeout(flush, 0);
        requestPortTick();
      };
    } else {
      // old browsers
      requestTick = function () {
        setTimeout(flush, 0);
      };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
      laterQueue.push(task);
      if (!flushing) {
        flushing = true;
        requestTick();
      }
    };
    return nextTick;
  }();

  // Attempt to make generics safe in the face of downstream
  // modifications.
  // There is no situation where this is necessary.
  // If you need a security guarantee, these primordials need to be
  // deeply frozen anyway, and if you don’t need a security guarantee,
  // this is just plain paranoid.
  // However, this **might** have the nice side-effect of reducing the size of
  // the minified code by reducing x.call() to merely x()
  // See Mark Miller’s explanation of what this does.
  // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  var call = Function.call;
  function uncurryThis(f) {
    return function () {
      return call.apply(f, arguments);
    };
  }
  // This is equivalent, but slower:
  // uncurryThis = Function_bind.bind(Function_bind.call);
  // http://jsperf.com/uncurrythis

  var array_slice = uncurryThis(Array.prototype.slice);
  var array_reduce = uncurryThis(Array.prototype.reduce || function (callback, basis) {
    var index = 0,
      length = this.length;
    // concerning the initial value, if one is not provided
    if (arguments.length === 1) {
      // seek to the first value in the array, accounting
      // for the possibility that is is a sparse array
      do {
        if (index in this) {
          basis = this[index++];
          break;
        }
        if (++index >= length) {
          throw new TypeError();
        }
      } while (1);
    }
    // reduce
    for (; index < length; index++) {
      // account for the possibility that the array is sparse
      if (index in this) {
        basis = callback(basis, this[index], index);
      }
    }
    return basis;
  });
  var array_indexOf = uncurryThis(Array.prototype.indexOf || function (value) {
    // not a very good shim, but good enough for our one use of it
    for (var i = 0; i < this.length; i++) {
      if (this[i] === value) {
        return i;
      }
    }
    return -1;
  });
  var array_map = uncurryThis(Array.prototype.map || function (callback, thisp) {
    var self = this;
    var collect = [];
    array_reduce(self, function (undefined, value, index) {
      collect.push(callback.call(thisp, value, index, self));
    }, void 0);
    return collect;
  });
  var object_create = Object.create || function (prototype) {
    function Type() {}
    Type.prototype = prototype;
    return new Type();
  };
  var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
    obj[prop] = descriptor.value;
    return obj;
  };
  var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
  var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
      if (object_hasOwnProperty(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  var object_toString = uncurryThis(Object.prototype.toString);
  function isObject(value) {
    return value === Object(value);
  }

  // generator related shims

  // FIXME: Remove this function once ES6 generators are in SpiderMonkey.
  function isStopIteration(exception) {
    return object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue;
  }

  // FIXME: Remove this helper and Q.return once ES6 generators are in
  // SpiderMonkey.
  var QReturnValue;
  if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
  } else {
    QReturnValue = function (value) {
      this.value = value;
    };
  }

  // long stack traces

  var STACK_JUMP_SEPARATOR = "From previous event:";
  function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks && promise.stack && typeof error === "object" && error !== null && error.stack) {
      var stacks = [];
      for (var p = promise; !!p; p = p.source) {
        if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
          object_defineProperty(error, "__minimumStackCounter__", {
            value: p.stackCounter,
            configurable: true
          });
          stacks.unshift(p.stack);
        }
      }
      stacks.unshift(error.stack);
      var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
      var stack = filterStackString(concatedStacks);
      object_defineProperty(error, "stack", {
        value: stack,
        configurable: true
      });
    }
  }
  function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
      var line = lines[i];
      if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
        desiredLines.push(line);
      }
    }
    return desiredLines.join("\n");
  }
  function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
  }
  function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
      return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
      return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
      return [attempt3[1], Number(attempt3[2])];
    }
  }
  function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
    if (!fileNameAndLineNumber) {
      return false;
    }
    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];
    return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
  }

  // discover own file name and line number range for filtering stack
  // traces
  function captureLine() {
    if (!hasStacks) {
      return;
    }
    try {
      throw new Error();
    } catch (e) {
      var lines = e.stack.split("\n");
      var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
      var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
      if (!fileNameAndLineNumber) {
        return;
      }
      qFileName = fileNameAndLineNumber[0];
      return fileNameAndLineNumber[1];
    }
  }
  function deprecate(callback, name, alternative) {
    return function () {
      if (typeof console !== "undefined" && typeof console.warn === "function") {
        console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
      }
      return callback.apply(callback, arguments);
    };
  }

  // end of shims
  // beginning of real work

  /**
   * Constructs a promise for an immediate reference, passes promises through, or
   * coerces promises from different systems.
   * @param value immediate reference or promise
   */
  function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
      return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
      return coerce(value);
    } else {
      return fulfill(value);
    }
  }
  Q.resolve = Q;

  /**
   * Performs a task in a future turn of the event loop.
   * @param {Function} task
   */
  Q.nextTick = nextTick;

  /**
   * Controls whether or not long stack traces will be on
   */
  Q.longStackSupport = false;

  /**
   * The counter is used to determine the stopping point for building
   * long stack traces. In makeStackTraceLong we walk backwards through
   * the linked list of promises, only stacks which were created before
   * the rejection are concatenated.
   */
  var longStackCounter = 1;

  // enable long stacks if Q_DEBUG is set
  if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
  }

  /**
   * Constructs a {promise, resolve, reject} object.
   *
   * `resolve` is a callback to invoke with a more resolved value for the
   * promise. To fulfill the promise, invoke `resolve` with any value that is
   * not a thenable. To reject the promise, invoke `resolve` with a rejected
   * thenable, or invoke `reject` with the reason directly. To resolve the
   * promise to another thenable, thus putting it in the same state, invoke
   * `resolve` with that other thenable.
   */
  Q.defer = defer;
  function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [],
      progressListeners = [],
      resolvedPromise;
    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);
    promise.promiseDispatch = function (resolve, op, operands) {
      var args = array_slice(arguments);
      if (messages) {
        messages.push(args);
        if (op === "when" && operands[1]) {
          // progress operand
          progressListeners.push(operands[1]);
        }
      } else {
        Q.nextTick(function () {
          resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
        });
      }
    };

    // XXX deprecated
    promise.valueOf = function () {
      if (messages) {
        return promise;
      }
      var nearerValue = nearer(resolvedPromise);
      if (isPromise(nearerValue)) {
        resolvedPromise = nearerValue; // shorten chain
      }
      return nearerValue;
    };
    promise.inspect = function () {
      if (!resolvedPromise) {
        return {
          state: "pending"
        };
      }
      return resolvedPromise.inspect();
    };
    if (Q.longStackSupport && hasStacks) {
      try {
        throw new Error();
      } catch (e) {
        // NOTE: don't try to use `Error.captureStackTrace` or transfer the
        // accessor around; that causes memory leaks as per GH-111. Just
        // reify the stack trace as a string ASAP.
        //
        // At the same time, cut off the first line; it's always just
        // "[object Promise]\n", as per the `toString`.
        promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        promise.stackCounter = longStackCounter++;
      }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
      resolvedPromise = newPromise;
      if (Q.longStackSupport && hasStacks) {
        // Only hold a reference to the new promise if long stacks
        // are enabled to reduce memory usage
        promise.source = newPromise;
      }
      array_reduce(messages, function (undefined, message) {
        Q.nextTick(function () {
          newPromise.promiseDispatch.apply(newPromise, message);
        });
      }, void 0);
      messages = void 0;
      progressListeners = void 0;
    }
    deferred.promise = promise;
    deferred.resolve = function (value) {
      if (resolvedPromise) {
        return;
      }
      become(Q(value));
    };
    deferred.fulfill = function (value) {
      if (resolvedPromise) {
        return;
      }
      become(fulfill(value));
    };
    deferred.reject = function (reason) {
      if (resolvedPromise) {
        return;
      }
      become(reject(reason));
    };
    deferred.notify = function (progress) {
      if (resolvedPromise) {
        return;
      }
      array_reduce(progressListeners, function (undefined, progressListener) {
        Q.nextTick(function () {
          progressListener(progress);
        });
      }, void 0);
    };
    return deferred;
  }

  /**
   * Creates a Node-style callback that will resolve or reject the deferred
   * promise.
   * @returns a nodeback
   */
  defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
      if (error) {
        self.reject(error);
      } else if (arguments.length > 2) {
        self.resolve(array_slice(arguments, 1));
      } else {
        self.resolve(value);
      }
    };
  };

  /**
   * @param resolver {Function} a function that returns nothing and accepts
   * the resolve, reject, and notify functions for a deferred.
   * @returns a promise that may be resolved with the given resolve and reject
   * functions, or rejected by a thrown exception in resolver
   */
  Q.Promise = promise; // ES6
  Q.promise = promise;
  function promise(resolver) {
    if (typeof resolver !== "function") {
      throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
      resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
      deferred.reject(reason);
    }
    return deferred.promise;
  }
  promise.race = race; // ES6
  promise.all = all; // ES6
  promise.reject = reject; // ES6
  promise.resolve = Q; // ES6

  // XXX experimental.  This method is a way to denote that a local value is
  // serializable and should be immediately dispatched to a remote upon request,
  // instead of passing a reference.
  Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
  };
  Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
  };

  /**
   * If two promises eventually fulfill to the same value, promises that value,
   * but otherwise rejects.
   * @param x {Any*}
   * @param y {Any*}
   * @returns {Any*} a promise for x and y if they are the same, but a rejection
   * otherwise.
   *
   */
  Q.join = function (x, y) {
    return Q(x).join(y);
  };
  Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
      if (x === y) {
        // TODO: "===" should be Object.is or equiv
        return x;
      } else {
        throw new Error("Q can't join: not the same: " + x + " " + y);
      }
    });
  };

  /**
   * Returns a promise for the first of an array of promises to become settled.
   * @param answers {Array[Any*]} promises to race
   * @returns {Any*} the first promise to be settled
   */
  Q.race = race;
  function race(answerPs) {
    return promise(function (resolve, reject) {
      // Switch to this once we can assume at least ES5
      // answerPs.forEach(function (answerP) {
      //     Q(answerP).then(resolve, reject);
      // });
      // Use this in the meantime
      for (var i = 0, len = answerPs.length; i < len; i++) {
        Q(answerPs[i]).then(resolve, reject);
      }
    });
  }
  Promise.prototype.race = function () {
    return this.then(Q.race);
  };

  /**
   * Constructs a Promise with a promise descriptor object and optional fallback
   * function.  The descriptor contains methods like when(rejected), get(name),
   * set(name, value), post(name, args), and delete(name), which all
   * return either a value, a promise for a value, or a rejection.  The fallback
   * accepts the operation name, a resolver, and any further arguments that would
   * have been forwarded to the appropriate method above had a method been
   * provided with the proper name.  The API makes no guarantees about the nature
   * of the returned object, apart from that it is usable wherever promises are
   * bought and sold.
   */
  Q.makePromise = Promise;
  function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
      fallback = function (op) {
        return reject(new Error("Promise does not support operation: " + op));
      };
    }
    if (inspect === void 0) {
      inspect = function () {
        return {
          state: "unknown"
        };
      };
    }
    var promise = object_create(Promise.prototype);
    promise.promiseDispatch = function (resolve, op, args) {
      var result;
      try {
        if (descriptor[op]) {
          result = descriptor[op].apply(promise, args);
        } else {
          result = fallback.call(promise, op, args);
        }
      } catch (exception) {
        result = reject(exception);
      }
      if (resolve) {
        resolve(result);
      }
    };
    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
      var inspected = inspect();
      if (inspected.state === "rejected") {
        promise.exception = inspected.reason;
      }
      promise.valueOf = function () {
        var inspected = inspect();
        if (inspected.state === "pending" || inspected.state === "rejected") {
          return promise;
        }
        return inspected.value;
      };
    }
    return promise;
  }
  Promise.prototype.toString = function () {
    return "[object Promise]";
  };
  Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false; // ensure the untrusted promise makes at most a
    // single call to one of the callbacks

    function _fulfilled(value) {
      try {
        return typeof fulfilled === "function" ? fulfilled(value) : value;
      } catch (exception) {
        return reject(exception);
      }
    }
    function _rejected(exception) {
      if (typeof rejected === "function") {
        makeStackTraceLong(exception, self);
        try {
          return rejected(exception);
        } catch (newException) {
          return reject(newException);
        }
      }
      return reject(exception);
    }
    function _progressed(value) {
      return typeof progressed === "function" ? progressed(value) : value;
    }
    Q.nextTick(function () {
      self.promiseDispatch(function (value) {
        if (done) {
          return;
        }
        done = true;
        deferred.resolve(_fulfilled(value));
      }, "when", [function (exception) {
        if (done) {
          return;
        }
        done = true;
        deferred.resolve(_rejected(exception));
      }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
      var newValue;
      var threw = false;
      try {
        newValue = _progressed(value);
      } catch (e) {
        threw = true;
        if (Q.onerror) {
          Q.onerror(e);
        } else {
          throw e;
        }
      }
      if (!threw) {
        deferred.notify(newValue);
      }
    }]);
    return deferred.promise;
  };
  Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
  };

  /**
   * Works almost like "finally", but not called for rejections.
   * Original resolution value is passed through callback unaffected.
   * Callback may return a promise that will be awaited for.
   * @param {Function} callback
   * @returns {Q.Promise}
   * @example
   * doSomething()
   *   .then(...)
   *   .tap(console.log)
   *   .then(...);
   */
  Promise.prototype.tap = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
      return callback.fcall(value).thenResolve(value);
    });
  };

  /**
   * Registers an observer on a promise.
   *
   * Guarantees:
   *
   * 1. that fulfilled and rejected will be called only once.
   * 2. that either the fulfilled callback or the rejected callback will be
   *    called, but not both.
   * 3. that fulfilled and rejected will not be called in this turn.
   *
   * @param value      promise or immediate reference to observe
   * @param fulfilled  function to be called with the fulfilled value
   * @param rejected   function to be called with the rejection exception
   * @param progressed function to be called on any progress notifications
   * @return promise for the return value from the invoked callback
   */
  Q.when = when;
  function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
  }
  Promise.prototype.thenResolve = function (value) {
    return this.then(function () {
      return value;
    });
  };
  Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
  };
  Promise.prototype.thenReject = function (reason) {
    return this.then(function () {
      throw reason;
    });
  };
  Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
  };

  /**
   * If an object is not a promise, it is as "near" as possible.
   * If a promise is rejected, it is as "near" as possible too.
   * If it’s a fulfilled promise, the fulfillment value is nearer.
   * If it’s a deferred promise and the deferred has been resolved, the
   * resolution is "nearer".
   * @param object
   * @returns most resolved (nearest) form of the object
   */

  // XXX should we re-do this?
  Q.nearer = nearer;
  function nearer(value) {
    if (isPromise(value)) {
      var inspected = value.inspect();
      if (inspected.state === "fulfilled") {
        return inspected.value;
      }
    }
    return value;
  }

  /**
   * @returns whether the given object is a promise.
   * Otherwise it is a fulfilled value.
   */
  Q.isPromise = isPromise;
  function isPromise(object) {
    return object instanceof Promise;
  }
  Q.isPromiseAlike = isPromiseAlike;
  function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
  }

  /**
   * @returns whether the given object is a pending promise, meaning not
   * fulfilled or rejected.
   */
  Q.isPending = isPending;
  function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
  }
  Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
  };

  /**
   * @returns whether the given object is a value or fulfilled
   * promise.
   */
  Q.isFulfilled = isFulfilled;
  function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
  }
  Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
  };

  /**
   * @returns whether the given object is a rejected promise.
   */
  Q.isRejected = isRejected;
  function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
  }
  Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
  };

  //// BEGIN UNHANDLED REJECTION TRACKING

  // This promise library consumes exceptions thrown in handlers so they can be
  // handled by a subsequent promise.  The exceptions get added to this array when
  // they are created, and removed when they are handled.  Note that in ES6 or
  // shimmed environments, this would naturally be a `Set`.
  var unhandledReasons = [];
  var unhandledRejections = [];
  var reportedUnhandledRejections = [];
  var trackUnhandledRejections = true;
  function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;
    if (!trackUnhandledRejections) {
      trackUnhandledRejections = true;
    }
  }
  function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
      return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
      Q.nextTick.runAfter(function () {
        if (array_indexOf(unhandledRejections, promise) !== -1) {
          process.emit("unhandledRejection", reason, promise);
          reportedUnhandledRejections.push(promise);
        }
      });
    }
    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
      unhandledReasons.push(reason.stack);
    } else {
      unhandledReasons.push("(no stack) " + reason);
    }
  }
  function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
      return;
    }
    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
      if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
          var atReport = array_indexOf(reportedUnhandledRejections, promise);
          if (atReport !== -1) {
            process.emit("rejectionHandled", unhandledReasons[at], promise);
            reportedUnhandledRejections.splice(atReport, 1);
          }
        });
      }
      unhandledRejections.splice(at, 1);
      unhandledReasons.splice(at, 1);
    }
  }
  Q.resetUnhandledRejections = resetUnhandledRejections;
  Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
  };
  Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
  };
  resetUnhandledRejections();

  //// END UNHANDLED REJECTION TRACKING

  /**
   * Constructs a rejected promise.
   * @param reason value describing the failure
   */
  Q.reject = reject;
  function reject(reason) {
    var rejection = Promise({
      "when": function (rejected) {
        // note that the error has been handled
        if (rejected) {
          untrackRejection(this);
        }
        return rejected ? rejected(reason) : this;
      }
    }, function fallback() {
      return this;
    }, function inspect() {
      return {
        state: "rejected",
        reason: reason
      };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);
    return rejection;
  }

  /**
   * Constructs a fulfilled promise for an immediate reference.
   * @param value immediate reference
   */
  Q.fulfill = fulfill;
  function fulfill(value) {
    return Promise({
      "when": function () {
        return value;
      },
      "get": function (name) {
        return value[name];
      },
      "set": function (name, rhs) {
        value[name] = rhs;
      },
      "delete": function (name) {
        delete value[name];
      },
      "post": function (name, args) {
        // Mark Miller proposes that post with no name should apply a
        // promised function.
        if (name === null || name === void 0) {
          return value.apply(void 0, args);
        } else {
          return value[name].apply(value, args);
        }
      },
      "apply": function (thisp, args) {
        return value.apply(thisp, args);
      },
      "keys": function () {
        return object_keys(value);
      }
    }, void 0, function inspect() {
      return {
        state: "fulfilled",
        value: value
      };
    });
  }

  /**
   * Converts thenables to Q promises.
   * @param promise thenable promise
   * @returns a Q promise
   */
  function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
      try {
        promise.then(deferred.resolve, deferred.reject, deferred.notify);
      } catch (exception) {
        deferred.reject(exception);
      }
    });
    return deferred.promise;
  }

  /**
   * Annotates an object such that it will never be
   * transferred away from this process over any promise
   * communication channel.
   * @param object
   * @returns promise a wrapping of that object that
   * additionally responds to the "isDef" message
   * without a rejection.
   */
  Q.master = master;
  function master(object) {
    return Promise({
      "isDef": function () {}
    }, function fallback(op, args) {
      return dispatch(object, op, args);
    }, function () {
      return Q(object).inspect();
    });
  }

  /**
   * Spreads the values of a promised array of arguments into the
   * fulfillment callback.
   * @param fulfilled callback that receives variadic arguments from the
   * promised array
   * @param rejected callback that receives the exception if the promise
   * is rejected.
   * @returns a promise for the return value or thrown exception of
   * either callback.
   */
  Q.spread = spread;
  function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
  }
  Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
      return fulfilled.apply(void 0, array);
    }, rejected);
  };

  /**
   * The async function is a decorator for generator functions, turning
   * them into asynchronous generators.  Although generators are only part
   * of the newest ECMAScript 6 drafts, this code does not cause syntax
   * errors in older engines.  This code should continue to work and will
   * in fact improve over time as the language improves.
   *
   * ES6 generators are currently part of V8 version 3.19 with the
   * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
   * for longer, but under an older Python-inspired form.  This function
   * works on both kinds of generators.
   *
   * Decorates a generator function such that:
   *  - it may yield promises
   *  - execution will continue when that promise is fulfilled
   *  - the value of the yield expression will be the fulfilled value
   *  - it returns a promise for the return value (when the generator
   *    stops iterating)
   *  - the decorated function returns a promise for the return value
   *    of the generator or the first rejected promise among those
   *    yielded.
   *  - if an error is thrown in the generator, it propagates through
   *    every following yield until it is caught, or until it escapes
   *    the generator function altogether, and is translated into a
   *    rejection for the promise returned by the decorated generator.
   */
  Q.async = async;
  function async(makeGenerator) {
    return function () {
      // when verb is "send", arg is a value
      // when verb is "throw", arg is an exception
      function continuer(verb, arg) {
        var result;

        // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
        // engine that has a deployed base of browsers that support generators.
        // However, SM's generators use the Python-inspired semantics of
        // outdated ES6 drafts.  We would like to support ES6, but we'd also
        // like to make it possible to use generators in deployed browsers, so
        // we also support Python-style generators.  At some point we can remove
        // this block.

        if (typeof StopIteration === "undefined") {
          // ES6 Generators
          try {
            result = generator[verb](arg);
          } catch (exception) {
            return reject(exception);
          }
          if (result.done) {
            return Q(result.value);
          } else {
            return when(result.value, callback, errback);
          }
        } else {
          // SpiderMonkey Generators
          // FIXME: Remove this case when SM does ES6 generators.
          try {
            result = generator[verb](arg);
          } catch (exception) {
            if (isStopIteration(exception)) {
              return Q(exception.value);
            } else {
              return reject(exception);
            }
          }
          return when(result, callback, errback);
        }
      }
      var generator = makeGenerator.apply(this, arguments);
      var callback = continuer.bind(continuer, "next");
      var errback = continuer.bind(continuer, "throw");
      return callback();
    };
  }

  /**
   * The spawn function is a small wrapper around async that immediately
   * calls the generator and also ends the promise chain, so that any
   * unhandled errors are thrown instead of forwarded to the error
   * handler. This is useful because it's extremely common to run
   * generators at the top-level to work with libraries.
   */
  Q.spawn = spawn;
  function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
  }

  // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
  /**
   * Throws a ReturnValue exception to stop an asynchronous generator.
   *
   * This interface is a stop-gap measure to support generator return
   * values in older Firefox/SpiderMonkey.  In browsers that support ES6
   * generators like Chromium 29, just use "return" in your generator
   * functions.
   *
   * @param value the return value for the surrounding generator
   * @throws ReturnValue exception with the value.
   * @example
   * // ES6 style
   * Q.async(function* () {
   *      var foo = yield getFooPromise();
   *      var bar = yield getBarPromise();
   *      return foo + bar;
   * })
   * // Older SpiderMonkey style
   * Q.async(function () {
   *      var foo = yield getFooPromise();
   *      var bar = yield getBarPromise();
   *      Q.return(foo + bar);
   * })
   */
  Q["return"] = _return;
  function _return(value) {
    throw new QReturnValue(value);
  }

  /**
   * The promised function decorator ensures that any promise arguments
   * are settled and passed as values (`this` is also settled and passed
   * as a value).  It will also ensure that the result of a function is
   * always a promise.
   *
   * @example
   * var add = Q.promised(function (a, b) {
   *     return a + b;
   * });
   * add(Q(a), Q(B));
   *
   * @param {function} callback The function to decorate
   * @returns {function} a function that has been decorated.
   */
  Q.promised = promised;
  function promised(callback) {
    return function () {
      return spread([this, all(arguments)], function (self, args) {
        return callback.apply(self, args);
      });
    };
  }

  /**
   * sends a message to a value in a future turn
   * @param object* the recipient
   * @param op the name of the message operation, e.g., "when",
   * @param args further arguments to be forwarded to the operation
   * @returns result {Promise} a promise for the result of the operation
   */
  Q.dispatch = dispatch;
  function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
  }
  Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
      self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
  };

  /**
   * Gets the value of a property in a future turn.
   * @param object    promise or immediate reference for target object
   * @param name      name of property to get
   * @return promise for the property value
   */
  Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
  };
  Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
  };

  /**
   * Sets the value of a property in a future turn.
   * @param object    promise or immediate reference for object object
   * @param name      name of property to set
   * @param value     new value of property
   * @return promise for the return value
   */
  Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
  };
  Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
  };

  /**
   * Deletes a property in a future turn.
   * @param object    promise or immediate reference for target object
   * @param name      name of property to delete
   * @return promise for the return value
   */
  Q.del =
  // XXX legacy
  Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
  };
  Promise.prototype.del =
  // XXX legacy
  Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
  };

  /**
   * Invokes a method in a future turn.
   * @param object    promise or immediate reference for target object
   * @param name      name of method to invoke
   * @param value     a value to post, typically an array of
   *                  invocation arguments for promises that
   *                  are ultimately backed with `resolve` values,
   *                  as opposed to those backed with URLs
   *                  wherein the posted value can be any
   *                  JSON serializable object.
   * @return promise for the return value
   */
  // bound locally because it is used by other methods
  Q.mapply =
  // XXX As proposed by "Redsandro"
  Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
  };
  Promise.prototype.mapply =
  // XXX As proposed by "Redsandro"
  Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
  };

  /**
   * Invokes a method in a future turn.
   * @param object    promise or immediate reference for target object
   * @param name      name of method to invoke
   * @param ...args   array of invocation arguments
   * @return promise for the return value
   */
  Q.send =
  // XXX Mark Miller's proposed parlance
  Q.mcall =
  // XXX As proposed by "Redsandro"
  Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
  };
  Promise.prototype.send =
  // XXX Mark Miller's proposed parlance
  Promise.prototype.mcall =
  // XXX As proposed by "Redsandro"
  Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
  };

  /**
   * Applies the promised function in a future turn.
   * @param object    promise or immediate reference for target function
   * @param args      array of application arguments
   */
  Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
  };
  Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
  };

  /**
   * Calls the promised function in a future turn.
   * @param object    promise or immediate reference for target function
   * @param ...args   array of application arguments
   */
  Q["try"] = Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
  };
  Promise.prototype.fcall = function /*...args*/
  () {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
  };

  /**
   * Binds the promised function, transforming return values into a fulfilled
   * promise and thrown errors into a rejected one.
   * @param object    promise or immediate reference for target function
   * @param ...args   array of application arguments
   */
  Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
      return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
    };
  };
  Promise.prototype.fbind = function /*...args*/
  () {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
      return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
    };
  };

  /**
   * Requests the names of the owned properties of a promised
   * object in a future turn.
   * @param object    promise or immediate reference for target object
   * @return promise for the keys of the eventually settled object
   */
  Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
  };
  Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
  };

  /**
   * Turns an array of promises into a promise for an array.  If any of
   * the promises gets rejected, the whole array is rejected immediately.
   * @param {Array*} an array (or promise for an array) of values (or
   * promises for values)
   * @returns a promise for an array of the corresponding values
   */
  // By Mark Miller
  // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
  Q.all = all;
  function all(promises) {
    return when(promises, function (promises) {
      var pendingCount = 0;
      var deferred = defer();
      array_reduce(promises, function (undefined, promise, index) {
        var snapshot;
        if (isPromise(promise) && (snapshot = promise.inspect()).state === "fulfilled") {
          promises[index] = snapshot.value;
        } else {
          ++pendingCount;
          when(promise, function (value) {
            promises[index] = value;
            if (--pendingCount === 0) {
              deferred.resolve(promises);
            }
          }, deferred.reject, function (progress) {
            deferred.notify({
              index: index,
              value: progress
            });
          });
        }
      }, void 0);
      if (pendingCount === 0) {
        deferred.resolve(promises);
      }
      return deferred.promise;
    });
  }
  Promise.prototype.all = function () {
    return all(this);
  };

  /**
   * Returns the first resolved promise of an array. Prior rejected promises are
   * ignored.  Rejects only if all promises are rejected.
   * @param {Array*} an array containing values or promises for values
   * @returns a promise fulfilled with the value of the first resolved promise,
   * or a rejected promise if all promises are rejected.
   */
  Q.any = any;
  function any(promises) {
    if (promises.length === 0) {
      return Q.resolve();
    }
    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
      var promise = promises[index];
      pendingCount++;
      when(promise, onFulfilled, onRejected, onProgress);
      function onFulfilled(result) {
        deferred.resolve(result);
      }
      function onRejected(err) {
        pendingCount--;
        if (pendingCount === 0) {
          var rejection = err || new Error("" + err);
          rejection.message = "Q can't get fulfillment value from any promise, all " + "promises were rejected. Last error message: " + rejection.message;
          deferred.reject(rejection);
        }
      }
      function onProgress(progress) {
        deferred.notify({
          index: index,
          value: progress
        });
      }
    }, undefined);
    return deferred.promise;
  }
  Promise.prototype.any = function () {
    return any(this);
  };

  /**
   * Waits for all promises to be settled, either fulfilled or
   * rejected.  This is distinct from `all` since that would stop
   * waiting at the first rejection.  The promise returned by
   * `allResolved` will never be rejected.
   * @param promises a promise for an array (or an array) of promises
   * (or values)
   * @return a promise for an array of promises
   */
  Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
  function allResolved(promises) {
    return when(promises, function (promises) {
      promises = array_map(promises, Q);
      return when(all(array_map(promises, function (promise) {
        return when(promise, noop, noop);
      })), function () {
        return promises;
      });
    });
  }
  Promise.prototype.allResolved = function () {
    return allResolved(this);
  };

  /**
   * @see Promise#allSettled
   */
  Q.allSettled = allSettled;
  function allSettled(promises) {
    return Q(promises).allSettled();
  }

  /**
   * Turns an array of promises into a promise for an array of their states (as
   * returned by `inspect`) when they have all settled.
   * @param {Array[Any*]} values an array (or promise for an array) of values (or
   * promises for values)
   * @returns {Array[State]} an array of states for the respective values.
   */
  Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
      return all(array_map(promises, function (promise) {
        promise = Q(promise);
        function regardless() {
          return promise.inspect();
        }
        return promise.then(regardless, regardless);
      }));
    });
  };

  /**
   * Captures the failure of a promise, giving an oportunity to recover
   * with a callback.  If the given promise is fulfilled, the returned
   * promise is fulfilled.
   * @param {Any*} promise for something
   * @param {Function} callback to fulfill the returned promise if the
   * given promise is rejected
   * @returns a promise for the return value of the callback
   */
  Q.fail =
  // XXX legacy
  Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
  };
  Promise.prototype.fail =
  // XXX legacy
  Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
  };

  /**
   * Attaches a listener that can respond to progress notifications from a
   * promise's originating deferred. This listener receives the exact arguments
   * passed to ``deferred.notify``.
   * @param {Any*} promise for something
   * @param {Function} callback to receive any progress notifications
   * @returns the given promise, unchanged
   */
  Q.progress = progress;
  function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
  }
  Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
  };

  /**
   * Provides an opportunity to observe the settling of a promise,
   * regardless of whether the promise is fulfilled or rejected.  Forwards
   * the resolution to the returned promise when the callback is done.
   * The callback can return a promise to defer completion.
   * @param {Any*} promise
   * @param {Function} callback to observe the resolution of the given
   * promise, takes no arguments.
   * @returns a promise for the resolution of the given promise when
   * ``fin`` is done.
   */
  Q.fin =
  // XXX legacy
  Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
  };
  Promise.prototype.fin =
  // XXX legacy
  Promise.prototype["finally"] = function (callback) {
    if (!callback || typeof callback.apply !== "function") {
      throw new Error("Q can't apply finally callback");
    }
    callback = Q(callback);
    return this.then(function (value) {
      return callback.fcall().then(function () {
        return value;
      });
    }, function (reason) {
      // TODO attempt to recycle the rejection with "this".
      return callback.fcall().then(function () {
        throw reason;
      });
    });
  };

  /**
   * Terminates a chain of promises, forcing rejections to be
   * thrown as exceptions.
   * @param {Any*} promise at the end of a chain of promises
   * @returns nothing
   */
  Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
  };
  Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
      // forward to a future turn so that ``when``
      // does not catch it and turn it into a rejection.
      Q.nextTick(function () {
        makeStackTraceLong(error, promise);
        if (Q.onerror) {
          Q.onerror(error);
        } else {
          throw error;
        }
      });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ? this.then(fulfilled, rejected, progress) : this;
    if (typeof process === "object" && process && process.domain) {
      onUnhandledError = process.domain.bind(onUnhandledError);
    }
    promise.then(void 0, onUnhandledError);
  };

  /**
   * Causes a promise to be rejected if it does not get fulfilled before
   * some milliseconds time out.
   * @param {Any*} promise
   * @param {Number} milliseconds timeout
   * @param {Any*} custom error message or Error object (optional)
   * @returns a promise for the resolution of the given promise if it is
   * fulfilled before the timeout, otherwise rejected.
   */
  Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
  };
  Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
      if (!error || "string" === typeof error) {
        error = new Error(error || "Timed out after " + ms + " ms");
        error.code = "ETIMEDOUT";
      }
      deferred.reject(error);
    }, ms);
    this.then(function (value) {
      clearTimeout(timeoutId);
      deferred.resolve(value);
    }, function (exception) {
      clearTimeout(timeoutId);
      deferred.reject(exception);
    }, deferred.notify);
    return deferred.promise;
  };

  /**
   * Returns a promise for the given value (or promised value), some
   * milliseconds after it resolved. Passes rejections immediately.
   * @param {Any*} promise
   * @param {Number} milliseconds
   * @returns a promise for the resolution of the given promise after milliseconds
   * time has elapsed since the resolution of the given promise.
   * If the given promise rejects, that is passed immediately.
   */
  Q.delay = function (object, timeout) {
    if (timeout === void 0) {
      timeout = object;
      object = void 0;
    }
    return Q(object).delay(timeout);
  };
  Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
      var deferred = defer();
      setTimeout(function () {
        deferred.resolve(value);
      }, timeout);
      return deferred.promise;
    });
  };

  /**
   * Passes a continuation to a Node function, which is called with the given
   * arguments provided as an array, and returns a promise.
   *
   *      Q.nfapply(FS.readFile, [__filename])
   *      .then(function (content) {
   *      })
   *
   */
  Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
  };
  Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
  };

  /**
   * Passes a continuation to a Node function, which is called with the given
   * arguments provided individually, and returns a promise.
   * @example
   * Q.nfcall(FS.readFile, __filename)
   * .then(function (content) {
   * })
   *
   */
  Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
  };
  Promise.prototype.nfcall = function /*...args*/
  () {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
  };

  /**
   * Wraps a NodeJS continuation passing function and returns an equivalent
   * version that returns a promise.
   * @example
   * Q.nfbind(FS.readFile, __filename)("utf-8")
   * .then(console.log)
   * .done()
   */
  Q.nfbind = Q.denodeify = function (callback /*...args*/) {
    if (callback === undefined) {
      throw new Error("Q can't wrap an undefined function");
    }
    var baseArgs = array_slice(arguments, 1);
    return function () {
      var nodeArgs = baseArgs.concat(array_slice(arguments));
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      Q(callback).fapply(nodeArgs).fail(deferred.reject);
      return deferred.promise;
    };
  };
  Promise.prototype.nfbind = Promise.prototype.denodeify = function /*...args*/
  () {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
  };
  Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
      var nodeArgs = baseArgs.concat(array_slice(arguments));
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      function bound() {
        return callback.apply(thisp, arguments);
      }
      Q(bound).fapply(nodeArgs).fail(deferred.reject);
      return deferred.promise;
    };
  };
  Promise.prototype.nbind = function /*thisp, ...args*/
  () {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
  };

  /**
   * Calls a method of a Node-style object that accepts a Node-style
   * callback with a given array of arguments, plus a provided callback.
   * @param object an object that has the named method
   * @param {String} name name of the method of object
   * @param {Array} args arguments to pass to the method; the callback
   * will be provided by Q and appended to these arguments.
   * @returns a promise for the value or error
   */
  Q.nmapply =
  // XXX As proposed by "Redsandro"
  Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
  };
  Promise.prototype.nmapply =
  // XXX As proposed by "Redsandro"
  Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
  };

  /**
   * Calls a method of a Node-style object that accepts a Node-style
   * callback, forwarding the given variadic arguments, plus a provided
   * callback argument.
   * @param object an object that has the named method
   * @param {String} name name of the method of object
   * @param ...args arguments to pass to the method; the callback will
   * be provided by Q and appended to these arguments.
   * @returns a promise for the value or error
   */
  Q.nsend =
  // XXX Based on Mark Miller's proposed "send"
  Q.nmcall =
  // XXX Based on "Redsandro's" proposal
  Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
  };
  Promise.prototype.nsend =
  // XXX Based on Mark Miller's proposed "send"
  Promise.prototype.nmcall =
  // XXX Based on "Redsandro's" proposal
  Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
  };

  /**
   * If a function would like to support both Node continuation-passing-style and
   * promise-returning-style, it can end its internal promise chain with
   * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
   * elects to use a nodeback, the result will be sent there.  If they do not
   * pass a nodeback, they will receive the result promise.
   * @param object a result (or a promise for a result)
   * @param {Function} nodeback a Node.js-style callback
   * @returns either the promise or nothing
   */
  Q.nodeify = nodeify;
  function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
  }
  Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
      this.then(function (value) {
        Q.nextTick(function () {
          nodeback(null, value);
        });
      }, function (error) {
        Q.nextTick(function () {
          nodeback(error);
        });
      });
    } else {
      return this;
    }
  };
  Q.noConflict = function () {
    throw new Error("Q.noConflict only works when Q is used as a global");
  };

  // All code before this point will be filtered from stack traces.
  var qEndingLine = captureLine();
  return Q;
} replaced with {}
Mutant 52 in q.js: false replaced with true
Mutant 53 in q.js: {
  throw new Error();
} replaced with {}
Mutant 54 in q.js: {
  hasStacks = !!e.stack;
} replaced with {}
Mutant 55 in q.js: !!e.stack replaced with !e.stack
Mutant 56 in q.js: !e.stack replaced with e.stack
Mutant 57 in q.js: {
  // linked list of tasks (single, with head node)
  var head = {
    task: void 0,
    next: null
  };
  var tail = head;
  var flushing = false;
  var requestTick = void 0;
  var isNodeJS = false;
  // queue for late tasks, used by unhandled rejection tracking
  var laterQueue = [];
  function flush() {
    /* jshint loopfunc: true */
    var task, domain;
    while (head.next) {
      head = head.next;
      task = head.task;
      head.task = void 0;
      domain = head.domain;
      if (domain) {
        head.domain = void 0;
        domain.enter();
      }
      runSingle(task, domain);
    }
    while (laterQueue.length) {
      task = laterQueue.pop();
      runSingle(task);
    }
    flushing = false;
  }
  // runs a single function in the async queue
  function runSingle(task, domain) {
    try {
      task();
    } catch (e) {
      if (isNodeJS) {
        // In node, uncaught exceptions are considered fatal errors.
        // Re-throw them synchronously to interrupt flushing!

        // Ensure continuation if the uncaught exception is suppressed
        // listening "uncaughtException" events (as domains does).
        // Continue in next event to avoid tick recursion.
        if (domain) {
          domain.exit();
        }
        setTimeout(flush, 0);
        if (domain) {
          domain.enter();
        }
        throw e;
      } else {
        // In browsers, uncaught exceptions are not fatal.
        // Re-throw them asynchronously to avoid slow-downs.
        setTimeout(function () {
          throw e;
        }, 0);
      }
    }
    if (domain) {
      domain.exit();
    }
  }
  nextTick = function (task) {
    tail = tail.next = {
      task: task,
      domain: isNodeJS && process.domain,
      next: null
    };
    if (!flushing) {
      flushing = true;
      requestTick();
    }
  };
  if (typeof process === "object" && process.toString() === "[object process]" && process.nextTick) {
    // Ensure Q is in a real Node environment, with a `process.nextTick`.
    // To see through fake Node environments:
    // * Mocha test runner - exposes a `process` global without a `nextTick`
    // * Browserify - exposes a `process.nexTick` function that uses
    //   `setTimeout`. In this case `setImmediate` is preferred because
    //    it is faster. Browserify's `process.toString()` yields
    //   "[object Object]", while in a real Node environment
    //   `process.toString()` yields "[object process]".
    isNodeJS = true;
    requestTick = function () {
      process.nextTick(flush);
    };
  } else if (typeof setImmediate === "function") {
    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
    if (typeof window !== "undefined") {
      requestTick = setImmediate.bind(window, flush);
    } else {
      requestTick = function () {
        setImmediate(flush);
      };
    }
  } else if (typeof MessageChannel !== "undefined") {
    // modern browsers
    // http://www.nonblocking.io/2011/06/windownexttick.html
    var channel = new MessageChannel();
    // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
    // working message ports the first time a page loads.
    channel.port1.onmessage = function () {
      requestTick = requestPortTick;
      channel.port1.onmessage = flush;
      flush();
    };
    var requestPortTick = function () {
      // Opera requires us to provide a message payload, regardless of
      // whether we use it.
      channel.port2.postMessage(0);
    };
    requestTick = function () {
      setTimeout(flush, 0);
      requestPortTick();
    };
  } else {
    // old browsers
    requestTick = function () {
      setTimeout(flush, 0);
    };
  }
  // runs a task after all other tasks have been run
  // this is useful for unhandled rejection tracking that needs to happen
  // after all `then`d tasks have been run.
  nextTick.runAfter = function (task) {
    laterQueue.push(task);
    if (!flushing) {
      flushing = true;
      requestTick();
    }
  };
  return nextTick;
} replaced with {}
Mutant 58 in q.js: {
  task: void 0,
  next: null
} replaced with {}
Mutant 59 in q.js: false replaced with true
Mutant 60 in q.js: false replaced with true
Mutant 61 in q.js: [] replaced with ["Stryker was here"]
Mutant 62 in q.js: {
  /* jshint loopfunc: true */
  var task, domain;
  while (head.next) {
    head = head.next;
    task = head.task;
    head.task = void 0;
    domain = head.domain;
    if (domain) {
      head.domain = void 0;
      domain.enter();
    }
    runSingle(task, domain);
  }
  while (laterQueue.length) {
    task = laterQueue.pop();
    runSingle(task);
  }
  flushing = false;
} replaced with {}
Mutant 63 in q.js: head.next replaced with false
Mutant 64 in q.js: {
  head = head.next;
  task = head.task;
  head.task = void 0;
  domain = head.domain;
  if (domain) {
    head.domain = void 0;
    domain.enter();
  }
  runSingle(task, domain);
} replaced with {}
Mutant 65 in q.js: domain replaced with true
Mutant 66 in q.js: domain replaced with false
Mutant 67 in q.js: {
  head.domain = void 0;
  domain.enter();
} replaced with {}
Mutant 68 in q.js: laterQueue.length replaced with false
Mutant 69 in q.js: {
  task = laterQueue.pop();
  runSingle(task);
} replaced with {}
Mutant 70 in q.js: false replaced with true
Mutant 71 in q.js: {
  try {
    task();
  } catch (e) {
    if (isNodeJS) {
      // In node, uncaught exceptions are considered fatal errors.
      // Re-throw them synchronously to interrupt flushing!

      // Ensure continuation if the uncaught exception is suppressed
      // listening "uncaughtException" events (as domains does).
      // Continue in next event to avoid tick recursion.
      if (domain) {
        domain.exit();
      }
      setTimeout(flush, 0);
      if (domain) {
        domain.enter();
      }
      throw e;
    } else {
      // In browsers, uncaught exceptions are not fatal.
      // Re-throw them asynchronously to avoid slow-downs.
      setTimeout(function () {
        throw e;
      }, 0);
    }
  }
  if (domain) {
    domain.exit();
  }
} replaced with {}
Mutant 72 in q.js: {
  task();
} replaced with {}
Mutant 73 in q.js: {
  if (isNodeJS) {
    // In node, uncaught exceptions are considered fatal errors.
    // Re-throw them synchronously to interrupt flushing!

    // Ensure continuation if the uncaught exception is suppressed
    // listening "uncaughtException" events (as domains does).
    // Continue in next event to avoid tick recursion.
    if (domain) {
      domain.exit();
    }
    setTimeout(flush, 0);
    if (domain) {
      domain.enter();
    }
    throw e;
  } else {
    // In browsers, uncaught exceptions are not fatal.
    // Re-throw them asynchronously to avoid slow-downs.
    setTimeout(function () {
      throw e;
    }, 0);
  }
} replaced with {}
Mutant 74 in q.js: isNodeJS replaced with true
Mutant 75 in q.js: isNodeJS replaced with false
Mutant 76 in q.js: {
  // In node, uncaught exceptions are considered fatal errors.
  // Re-throw them synchronously to interrupt flushing!

  // Ensure continuation if the uncaught exception is suppressed
  // listening "uncaughtException" events (as domains does).
  // Continue in next event to avoid tick recursion.
  if (domain) {
    domain.exit();
  }
  setTimeout(flush, 0);
  if (domain) {
    domain.enter();
  }
  throw e;
} replaced with {}
Mutant 77 in q.js: domain replaced with true
Mutant 78 in q.js: domain replaced with false
Mutant 79 in q.js: {
  domain.exit();
} replaced with {}
Mutant 80 in q.js: domain replaced with true
Mutant 81 in q.js: domain replaced with false
Mutant 82 in q.js: {
  domain.enter();
} replaced with {}
Mutant 83 in q.js: {
  // In browsers, uncaught exceptions are not fatal.
  // Re-throw them asynchronously to avoid slow-downs.
  setTimeout(function () {
    throw e;
  }, 0);
} replaced with {}
Mutant 84 in q.js: {
  throw e;
} replaced with {}
Mutant 85 in q.js: domain replaced with true
Mutant 86 in q.js: domain replaced with false
Mutant 87 in q.js: {
  domain.exit();
} replaced with {}
Mutant 88 in q.js: {
  tail = tail.next = {
    task: task,
    domain: isNodeJS && process.domain,
    next: null
  };
  if (!flushing) {
    flushing = true;
    requestTick();
  }
} replaced with {}
Mutant 89 in q.js: {
  task: task,
  domain: isNodeJS && process.domain,
  next: null
} replaced with {}
Mutant 90 in q.js: isNodeJS && process.domain replaced with true
Mutant 91 in q.js: isNodeJS && process.domain replaced with false
Mutant 92 in q.js: isNodeJS && process.domain replaced with isNodeJS || process.domain
Mutant 93 in q.js: !flushing replaced with flushing
Mutant 94 in q.js: !flushing replaced with true
Mutant 95 in q.js: !flushing replaced with false
Mutant 96 in q.js: {
  flushing = true;
  requestTick();
} replaced with {}
Mutant 97 in q.js: true replaced with false
Mutant 98 in q.js: typeof process === "object" && process.toString() === "[object process]" && process.nextTick replaced with true
Mutant 99 in q.js: typeof process === "object" && process.toString() === "[object process]" && process.nextTick replaced with false
Mutant 100 in q.js: typeof process === "object" && process.toString() === "[object process]" && process.nextTick replaced with typeof process === "object" && process.toString() === "[object process]" || process.nextTick
Mutant 101 in q.js: typeof process === "object" && process.toString() === "[object process]" replaced with true
Mutant 102 in q.js: typeof process === "object" && process.toString() === "[object process]" replaced with typeof process === "object" || process.toString() === "[object process]"
Mutant 103 in q.js: typeof process === "object" replaced with true
Mutant 104 in q.js: typeof process === "object" replaced with typeof process !== "object"
Mutant 105 in q.js: "object" replaced with ""
Mutant 106 in q.js: process.toString() === "[object process]" replaced with true
Mutant 107 in q.js: process.toString() === "[object process]" replaced with process.toString() !== "[object process]"
Mutant 108 in q.js: "[object process]" replaced with ""
Mutant 109 in q.js: {
  // Ensure Q is in a real Node environment, with a `process.nextTick`.
  // To see through fake Node environments:
  // * Mocha test runner - exposes a `process` global without a `nextTick`
  // * Browserify - exposes a `process.nexTick` function that uses
  //   `setTimeout`. In this case `setImmediate` is preferred because
  //    it is faster. Browserify's `process.toString()` yields
  //   "[object Object]", while in a real Node environment
  //   `process.toString()` yields "[object process]".
  isNodeJS = true;
  requestTick = function () {
    process.nextTick(flush);
  };
} replaced with {}
Mutant 110 in q.js: true replaced with false
Mutant 111 in q.js: {
  process.nextTick(flush);
} replaced with {}
Mutant 112 in q.js: typeof setImmediate === "function" replaced with true
Mutant 113 in q.js: typeof setImmediate === "function" replaced with false
Mutant 114 in q.js: typeof setImmediate === "function" replaced with typeof setImmediate !== "function"
Mutant 115 in q.js: "function" replaced with ""
Mutant 116 in q.js: {
  // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
  if (typeof window !== "undefined") {
    requestTick = setImmediate.bind(window, flush);
  } else {
    requestTick = function () {
      setImmediate(flush);
    };
  }
} replaced with {}
Mutant 117 in q.js: typeof window !== "undefined" replaced with true
Mutant 118 in q.js: typeof window !== "undefined" replaced with false
Mutant 119 in q.js: typeof window !== "undefined" replaced with typeof window === "undefined"
Mutant 120 in q.js: "undefined" replaced with ""
Mutant 121 in q.js: {
  requestTick = setImmediate.bind(window, flush);
} replaced with {}
Mutant 122 in q.js: {
  requestTick = function () {
    setImmediate(flush);
  };
} replaced with {}
Mutant 123 in q.js: {
  setImmediate(flush);
} replaced with {}
Mutant 124 in q.js: typeof MessageChannel !== "undefined" replaced with true
Mutant 125 in q.js: typeof MessageChannel !== "undefined" replaced with false
Mutant 126 in q.js: typeof MessageChannel !== "undefined" replaced with typeof MessageChannel === "undefined"
Mutant 127 in q.js: "undefined" replaced with ""
Mutant 128 in q.js: {
  // modern browsers
  // http://www.nonblocking.io/2011/06/windownexttick.html
  var channel = new MessageChannel();
  // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
  // working message ports the first time a page loads.
  channel.port1.onmessage = function () {
    requestTick = requestPortTick;
    channel.port1.onmessage = flush;
    flush();
  };
  var requestPortTick = function () {
    // Opera requires us to provide a message payload, regardless of
    // whether we use it.
    channel.port2.postMessage(0);
  };
  requestTick = function () {
    setTimeout(flush, 0);
    requestPortTick();
  };
} replaced with {}
Mutant 129 in q.js: {
  requestTick = requestPortTick;
  channel.port1.onmessage = flush;
  flush();
} replaced with {}
Mutant 130 in q.js: {
  // Opera requires us to provide a message payload, regardless of
  // whether we use it.
  channel.port2.postMessage(0);
} replaced with {}
Mutant 131 in q.js: {
  setTimeout(flush, 0);
  requestPortTick();
} replaced with {}
Mutant 132 in q.js: {
  // old browsers
  requestTick = function () {
    setTimeout(flush, 0);
  };
} replaced with {}
Mutant 133 in q.js: {
  setTimeout(flush, 0);
} replaced with {}
Mutant 134 in q.js: {
  laterQueue.push(task);
  if (!flushing) {
    flushing = true;
    requestTick();
  }
} replaced with {}
Mutant 135 in q.js: !flushing replaced with flushing
Mutant 136 in q.js: !flushing replaced with true
Mutant 137 in q.js: !flushing replaced with false
Mutant 138 in q.js: {
  flushing = true;
  requestTick();
} replaced with {}
Mutant 139 in q.js: true replaced with false
Mutant 140 in q.js: {
  return function () {
    return call.apply(f, arguments);
  };
} replaced with {}
Mutant 141 in q.js: {
  return call.apply(f, arguments);
} replaced with {}
Mutant 142 in q.js: Array.prototype.reduce || function (callback, basis) {
  var index = 0,
    length = this.length;
  // concerning the initial value, if one is not provided
  if (arguments.length === 1) {
    // seek to the first value in the array, accounting
    // for the possibility that is is a sparse array
    do {
      if (index in this) {
        basis = this[index++];
        break;
      }
      if (++index >= length) {
        throw new TypeError();
      }
    } while (1);
  }
  // reduce
  for (; index < length; index++) {
    // account for the possibility that the array is sparse
    if (index in this) {
      basis = callback(basis, this[index], index);
    }
  }
  return basis;
} replaced with true
Mutant 143 in q.js: Array.prototype.reduce || function (callback, basis) {
  var index = 0,
    length = this.length;
  // concerning the initial value, if one is not provided
  if (arguments.length === 1) {
    // seek to the first value in the array, accounting
    // for the possibility that is is a sparse array
    do {
      if (index in this) {
        basis = this[index++];
        break;
      }
      if (++index >= length) {
        throw new TypeError();
      }
    } while (1);
  }
  // reduce
  for (; index < length; index++) {
    // account for the possibility that the array is sparse
    if (index in this) {
      basis = callback(basis, this[index], index);
    }
  }
  return basis;
} replaced with false
Mutant 144 in q.js: Array.prototype.reduce || function (callback, basis) {
  var index = 0,
    length = this.length;
  // concerning the initial value, if one is not provided
  if (arguments.length === 1) {
    // seek to the first value in the array, accounting
    // for the possibility that is is a sparse array
    do {
      if (index in this) {
        basis = this[index++];
        break;
      }
      if (++index >= length) {
        throw new TypeError();
      }
    } while (1);
  }
  // reduce
  for (; index < length; index++) {
    // account for the possibility that the array is sparse
    if (index in this) {
      basis = callback(basis, this[index], index);
    }
  }
  return basis;
} replaced with Array.prototype.reduce && function (callback, basis) {
  var index = 0,
    length = this.length;
  // concerning the initial value, if one is not provided
  if (arguments.length === 1) {
    // seek to the first value in the array, accounting
    // for the possibility that is is a sparse array
    do {
      if (index in this) {
        basis = this[index++];
        break;
      }
      if (++index >= length) {
        throw new TypeError();
      }
    } while (1);
  }
  // reduce
  for (; index < length; index++) {
    // account for the possibility that the array is sparse
    if (index in this) {
      basis = callback(basis, this[index], index);
    }
  }
  return basis;
}
Mutant 145 in q.js: {
  var index = 0,
    length = this.length;
  // concerning the initial value, if one is not provided
  if (arguments.length === 1) {
    // seek to the first value in the array, accounting
    // for the possibility that is is a sparse array
    do {
      if (index in this) {
        basis = this[index++];
        break;
      }
      if (++index >= length) {
        throw new TypeError();
      }
    } while (1);
  }
  // reduce
  for (; index < length; index++) {
    // account for the possibility that the array is sparse
    if (index in this) {
      basis = callback(basis, this[index], index);
    }
  }
  return basis;
} replaced with {}
Mutant 146 in q.js: arguments.length === 1 replaced with true
Mutant 147 in q.js: arguments.length === 1 replaced with false
Mutant 148 in q.js: arguments.length === 1 replaced with arguments.length !== 1
Mutant 149 in q.js: {
  // seek to the first value in the array, accounting
  // for the possibility that is is a sparse array
  do {
    if (index in this) {
      basis = this[index++];
      break;
    }
    if (++index >= length) {
      throw new TypeError();
    }
  } while (1);
} replaced with {}
Mutant 150 in q.js: 1 replaced with false
Mutant 151 in q.js: {
  if (index in this) {
    basis = this[index++];
    break;
  }
  if (++index >= length) {
    throw new TypeError();
  }
} replaced with {}
Mutant 152 in q.js: index in this replaced with true
Mutant 153 in q.js: index in this replaced with false
Mutant 154 in q.js: {
  basis = this[index++];
  break;
} replaced with {}
Mutant 155 in q.js: index++ replaced with index--
Mutant 156 in q.js: ++index >= length replaced with true
Mutant 157 in q.js: ++index >= length replaced with false
Mutant 158 in q.js: ++index >= length replaced with ++index > length
Mutant 159 in q.js: ++index >= length replaced with ++index < length
Mutant 160 in q.js: ++index replaced with --index
Mutant 161 in q.js: {
  throw new TypeError();
} replaced with {}
Mutant 162 in q.js: index < length replaced with false
Mutant 163 in q.js: index < length replaced with index <= length
Mutant 164 in q.js: index < length replaced with index >= length
Mutant 165 in q.js: index++ replaced with index--
Mutant 166 in q.js: {
  // account for the possibility that the array is sparse
  if (index in this) {
    basis = callback(basis, this[index], index);
  }
} replaced with {}
Mutant 167 in q.js: index in this replaced with true
Mutant 168 in q.js: index in this replaced with false
Mutant 169 in q.js: {
  basis = callback(basis, this[index], index);
} replaced with {}
Mutant 170 in q.js: Array.prototype.indexOf || function (value) {
  // not a very good shim, but good enough for our one use of it
  for (var i = 0; i < this.length; i++) {
    if (this[i] === value) {
      return i;
    }
  }
  return -1;
} replaced with true
Mutant 171 in q.js: Array.prototype.indexOf || function (value) {
  // not a very good shim, but good enough for our one use of it
  for (var i = 0; i < this.length; i++) {
    if (this[i] === value) {
      return i;
    }
  }
  return -1;
} replaced with false
Mutant 172 in q.js: Array.prototype.indexOf || function (value) {
  // not a very good shim, but good enough for our one use of it
  for (var i = 0; i < this.length; i++) {
    if (this[i] === value) {
      return i;
    }
  }
  return -1;
} replaced with Array.prototype.indexOf && function (value) {
  // not a very good shim, but good enough for our one use of it
  for (var i = 0; i < this.length; i++) {
    if (this[i] === value) {
      return i;
    }
  }
  return -1;
}
Mutant 173 in q.js: {
  // not a very good shim, but good enough for our one use of it
  for (var i = 0; i < this.length; i++) {
    if (this[i] === value) {
      return i;
    }
  }
  return -1;
} replaced with {}
Mutant 174 in q.js: i < this.length replaced with false
Mutant 175 in q.js: i < this.length replaced with i <= this.length
Mutant 176 in q.js: i < this.length replaced with i >= this.length
Mutant 177 in q.js: i++ replaced with i--
Mutant 178 in q.js: {
  if (this[i] === value) {
    return i;
  }
} replaced with {}
Mutant 179 in q.js: this[i] === value replaced with true
Mutant 180 in q.js: this[i] === value replaced with false
Mutant 181 in q.js: this[i] === value replaced with this[i] !== value
Mutant 182 in q.js: {
  return i;
} replaced with {}
Mutant 183 in q.js: -1 replaced with +1
Mutant 184 in q.js: Array.prototype.map || function (callback, thisp) {
  var self = this;
  var collect = [];
  array_reduce(self, function (undefined, value, index) {
    collect.push(callback.call(thisp, value, index, self));
  }, void 0);
  return collect;
} replaced with true
Mutant 185 in q.js: Array.prototype.map || function (callback, thisp) {
  var self = this;
  var collect = [];
  array_reduce(self, function (undefined, value, index) {
    collect.push(callback.call(thisp, value, index, self));
  }, void 0);
  return collect;
} replaced with false
Mutant 186 in q.js: Array.prototype.map || function (callback, thisp) {
  var self = this;
  var collect = [];
  array_reduce(self, function (undefined, value, index) {
    collect.push(callback.call(thisp, value, index, self));
  }, void 0);
  return collect;
} replaced with Array.prototype.map && function (callback, thisp) {
  var self = this;
  var collect = [];
  array_reduce(self, function (undefined, value, index) {
    collect.push(callback.call(thisp, value, index, self));
  }, void 0);
  return collect;
}
Mutant 187 in q.js: {
  var self = this;
  var collect = [];
  array_reduce(self, function (undefined, value, index) {
    collect.push(callback.call(thisp, value, index, self));
  }, void 0);
  return collect;
} replaced with {}
Mutant 188 in q.js: [] replaced with ["Stryker was here"]
Mutant 189 in q.js: {
  collect.push(callback.call(thisp, value, index, self));
} replaced with {}
Mutant 190 in q.js: Object.create || function (prototype) {
  function Type() {}
  Type.prototype = prototype;
  return new Type();
} replaced with true
Mutant 191 in q.js: Object.create || function (prototype) {
  function Type() {}
  Type.prototype = prototype;
  return new Type();
} replaced with false
Mutant 192 in q.js: Object.create || function (prototype) {
  function Type() {}
  Type.prototype = prototype;
  return new Type();
} replaced with Object.create && function (prototype) {
  function Type() {}
  Type.prototype = prototype;
  return new Type();
}
Mutant 193 in q.js: {
  function Type() {}
  Type.prototype = prototype;
  return new Type();
} replaced with {}
Mutant 194 in q.js: Object.defineProperty || function (obj, prop, descriptor) {
  obj[prop] = descriptor.value;
  return obj;
} replaced with true
Mutant 195 in q.js: Object.defineProperty || function (obj, prop, descriptor) {
  obj[prop] = descriptor.value;
  return obj;
} replaced with false
Mutant 196 in q.js: Object.defineProperty || function (obj, prop, descriptor) {
  obj[prop] = descriptor.value;
  return obj;
} replaced with Object.defineProperty && function (obj, prop, descriptor) {
  obj[prop] = descriptor.value;
  return obj;
}
Mutant 197 in q.js: {
  obj[prop] = descriptor.value;
  return obj;
} replaced with {}
Mutant 198 in q.js: Object.keys || function (object) {
  var keys = [];
  for (var key in object) {
    if (object_hasOwnProperty(object, key)) {
      keys.push(key);
    }
  }
  return keys;
} replaced with true
Mutant 199 in q.js: Object.keys || function (object) {
  var keys = [];
  for (var key in object) {
    if (object_hasOwnProperty(object, key)) {
      keys.push(key);
    }
  }
  return keys;
} replaced with false
Mutant 200 in q.js: Object.keys || function (object) {
  var keys = [];
  for (var key in object) {
    if (object_hasOwnProperty(object, key)) {
      keys.push(key);
    }
  }
  return keys;
} replaced with Object.keys && function (object) {
  var keys = [];
  for (var key in object) {
    if (object_hasOwnProperty(object, key)) {
      keys.push(key);
    }
  }
  return keys;
}
Mutant 201 in q.js: {
  var keys = [];
  for (var key in object) {
    if (object_hasOwnProperty(object, key)) {
      keys.push(key);
    }
  }
  return keys;
} replaced with {}
Mutant 202 in q.js: [] replaced with ["Stryker was here"]
Mutant 203 in q.js: {
  if (object_hasOwnProperty(object, key)) {
    keys.push(key);
  }
} replaced with {}
Mutant 204 in q.js: object_hasOwnProperty(object, key) replaced with true
Mutant 205 in q.js: object_hasOwnProperty(object, key) replaced with false
Mutant 206 in q.js: {
  keys.push(key);
} replaced with {}
Mutant 207 in q.js: {
  return value === Object(value);
} replaced with {}
Mutant 208 in q.js: value === Object(value) replaced with true
Mutant 209 in q.js: value === Object(value) replaced with false
Mutant 210 in q.js: value === Object(value) replaced with value !== Object(value)
Mutant 211 in q.js: {
  return object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue;
} replaced with {}
Mutant 212 in q.js: object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue replaced with true
Mutant 213 in q.js: object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue replaced with false
Mutant 214 in q.js: object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue replaced with object_toString(exception) === "[object StopIteration]" && exception instanceof QReturnValue
Mutant 215 in q.js: object_toString(exception) === "[object StopIteration]" replaced with false
Mutant 216 in q.js: object_toString(exception) === "[object StopIteration]" replaced with object_toString(exception) !== "[object StopIteration]"
Mutant 217 in q.js: "[object StopIteration]" replaced with ""
Mutant 218 in q.js: typeof ReturnValue !== "undefined" replaced with true
Mutant 219 in q.js: typeof ReturnValue !== "undefined" replaced with false
Mutant 220 in q.js: typeof ReturnValue !== "undefined" replaced with typeof ReturnValue === "undefined"
Mutant 221 in q.js: "undefined" replaced with ""
Mutant 222 in q.js: {
  QReturnValue = ReturnValue;
} replaced with {}
Mutant 223 in q.js: {
  QReturnValue = function (value) {
    this.value = value;
  };
} replaced with {}
Mutant 224 in q.js: {
  this.value = value;
} replaced with {}
Mutant 225 in q.js: "From previous event:" replaced with ""
Mutant 226 in q.js: {
  // If possible, transform the error stack trace by removing Node and Q
  // cruft, then concatenating with the stack trace of `promise`. See #57.
  if (hasStacks && promise.stack && typeof error === "object" && error !== null && error.stack) {
    var stacks = [];
    for (var p = promise; !!p; p = p.source) {
      if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
        object_defineProperty(error, "__minimumStackCounter__", {
          value: p.stackCounter,
          configurable: true
        });
        stacks.unshift(p.stack);
      }
    }
    stacks.unshift(error.stack);
    var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
    var stack = filterStackString(concatedStacks);
    object_defineProperty(error, "stack", {
      value: stack,
      configurable: true
    });
  }
} replaced with {}
Mutant 227 in q.js: hasStacks && promise.stack && typeof error === "object" && error !== null && error.stack replaced with true
Mutant 228 in q.js: hasStacks && promise.stack && typeof error === "object" && error !== null && error.stack replaced with false
Mutant 229 in q.js: hasStacks && promise.stack && typeof error === "object" && error !== null && error.stack replaced with hasStacks && promise.stack && typeof error === "object" && error !== null || error.stack
Mutant 230 in q.js: hasStacks && promise.stack && typeof error === "object" && error !== null replaced with true
Mutant 231 in q.js: hasStacks && promise.stack && typeof error === "object" && error !== null replaced with hasStacks && promise.stack && typeof error === "object" || error !== null
Mutant 232 in q.js: hasStacks && promise.stack && typeof error === "object" replaced with true
Mutant 233 in q.js: hasStacks && promise.stack && typeof error === "object" replaced with hasStacks && promise.stack || typeof error === "object"
Mutant 234 in q.js: hasStacks && promise.stack replaced with true
Mutant 235 in q.js: hasStacks && promise.stack replaced with hasStacks || promise.stack
Mutant 236 in q.js: typeof error === "object" replaced with true
Mutant 237 in q.js: typeof error === "object" replaced with typeof error !== "object"
Mutant 238 in q.js: "object" replaced with ""
Mutant 239 in q.js: error !== null replaced with true
Mutant 240 in q.js: error !== null replaced with error === null
Mutant 241 in q.js: {
  var stacks = [];
  for (var p = promise; !!p; p = p.source) {
    if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
      object_defineProperty(error, "__minimumStackCounter__", {
        value: p.stackCounter,
        configurable: true
      });
      stacks.unshift(p.stack);
    }
  }
  stacks.unshift(error.stack);
  var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
  var stack = filterStackString(concatedStacks);
  object_defineProperty(error, "stack", {
    value: stack,
    configurable: true
  });
} replaced with {}
Mutant 242 in q.js: [] replaced with ["Stryker was here"]
Mutant 243 in q.js: !!p replaced with !p
Mutant 244 in q.js: !!p replaced with false
Mutant 245 in q.js: !p replaced with p
Mutant 246 in q.js: {
  if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
    object_defineProperty(error, "__minimumStackCounter__", {
      value: p.stackCounter,
      configurable: true
    });
    stacks.unshift(p.stack);
  }
} replaced with {}
Mutant 247 in q.js: p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter) replaced with true
Mutant 248 in q.js: p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter) replaced with false
Mutant 249 in q.js: p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter) replaced with p.stack || !error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter
Mutant 250 in q.js: !error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter replaced with true
Mutant 251 in q.js: !error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter replaced with !error.__minimumStackCounter__ && error.__minimumStackCounter__ > p.stackCounter
Mutant 252 in q.js: !error.__minimumStackCounter__ replaced with error.__minimumStackCounter__
Mutant 253 in q.js: error.__minimumStackCounter__ > p.stackCounter replaced with false
Mutant 254 in q.js: error.__minimumStackCounter__ > p.stackCounter replaced with error.__minimumStackCounter__ >= p.stackCounter
Mutant 255 in q.js: error.__minimumStackCounter__ > p.stackCounter replaced with error.__minimumStackCounter__ <= p.stackCounter
Mutant 256 in q.js: {
  object_defineProperty(error, "__minimumStackCounter__", {
    value: p.stackCounter,
    configurable: true
  });
  stacks.unshift(p.stack);
} replaced with {}
Mutant 257 in q.js: "__minimumStackCounter__" replaced with ""
Mutant 258 in q.js: {
  value: p.stackCounter,
  configurable: true
} replaced with {}
Mutant 259 in q.js: true replaced with false
Mutant 260 in q.js: "\n" replaced with ""
Mutant 261 in q.js: "\n" replaced with ""
Mutant 262 in q.js: "stack" replaced with ""
Mutant 263 in q.js: {
  value: stack,
  configurable: true
} replaced with {}
Mutant 264 in q.js: true replaced with false
Mutant 265 in q.js: {
  var lines = stackString.split("\n");
  var desiredLines = [];
  for (var i = 0; i < lines.length; ++i) {
    var line = lines[i];
    if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
      desiredLines.push(line);
    }
  }
  return desiredLines.join("\n");
} replaced with {}
Mutant 266 in q.js: "\n" replaced with ""
Mutant 267 in q.js: [] replaced with ["Stryker was here"]
Mutant 268 in q.js: i < lines.length replaced with false
Mutant 269 in q.js: i < lines.length replaced with i <= lines.length
Mutant 270 in q.js: i < lines.length replaced with i >= lines.length
Mutant 271 in q.js: ++i replaced with --i
Mutant 272 in q.js: {
  var line = lines[i];
  if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
    desiredLines.push(line);
  }
} replaced with {}
Mutant 273 in q.js: !isInternalFrame(line) && !isNodeFrame(line) && line replaced with true
Mutant 274 in q.js: !isInternalFrame(line) && !isNodeFrame(line) && line replaced with false
Mutant 275 in q.js: !isInternalFrame(line) && !isNodeFrame(line) && line replaced with !isInternalFrame(line) && !isNodeFrame(line) || line
Mutant 276 in q.js: !isInternalFrame(line) && !isNodeFrame(line) replaced with true
Mutant 277 in q.js: !isInternalFrame(line) && !isNodeFrame(line) replaced with !isInternalFrame(line) || !isNodeFrame(line)
Mutant 278 in q.js: !isInternalFrame(line) replaced with isInternalFrame(line)
Mutant 279 in q.js: !isNodeFrame(line) replaced with isNodeFrame(line)
Mutant 280 in q.js: {
  desiredLines.push(line);
} replaced with {}
Mutant 281 in q.js: "\n" replaced with ""
Mutant 282 in q.js: {
  return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
} replaced with {}
Mutant 283 in q.js: stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1 replaced with true
Mutant 284 in q.js: stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1 replaced with false
Mutant 285 in q.js: stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1 replaced with stackLine.indexOf("(module.js:") !== -1 && stackLine.indexOf("(node.js:") !== -1
Mutant 286 in q.js: stackLine.indexOf("(module.js:") !== -1 replaced with false
Mutant 287 in q.js: stackLine.indexOf("(module.js:") !== -1 replaced with stackLine.indexOf("(module.js:") === -1
Mutant 288 in q.js: "(module.js:" replaced with ""
Mutant 289 in q.js: -1 replaced with +1
Mutant 290 in q.js: stackLine.indexOf("(node.js:") !== -1 replaced with false
Mutant 291 in q.js: stackLine.indexOf("(node.js:") !== -1 replaced with stackLine.indexOf("(node.js:") === -1
Mutant 292 in q.js: "(node.js:" replaced with ""
Mutant 293 in q.js: -1 replaced with +1
Mutant 294 in q.js: {
  // Named functions: "at functionName (filename:lineNumber:columnNumber)"
  // In IE10 function name can have spaces ("Anonymous function") O_o
  var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
  if (attempt1) {
    return [attempt1[1], Number(attempt1[2])];
  }

  // Anonymous functions: "at filename:lineNumber:columnNumber"
  var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
  if (attempt2) {
    return [attempt2[1], Number(attempt2[2])];
  }

  // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
  var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
  if (attempt3) {
    return [attempt3[1], Number(attempt3[2])];
  }
} replaced with {}
Mutant 295 in q.js: /at .+ \((.+):(\d+):(?:\d+)\)$/ replaced with /at .+ \((.+):(\d+):(?:\d+)\)/
Mutant 296 in q.js: /at .+ \((.+):(\d+):(?:\d+)\)$/ replaced with /at . \((.+):(\d+):(?:\d+)\)$/
Mutant 297 in q.js: /at .+ \((.+):(\d+):(?:\d+)\)$/ replaced with /at .+ \((.):(\d+):(?:\d+)\)$/
Mutant 298 in q.js: /at .+ \((.+):(\d+):(?:\d+)\)$/ replaced with /at .+ \((.+):(\d):(?:\d+)\)$/
Mutant 299 in q.js: /at .+ \((.+):(\d+):(?:\d+)\)$/ replaced with /at .+ \((.+):(\D+):(?:\d+)\)$/
Mutant 300 in q.js: /at .+ \((.+):(\d+):(?:\d+)\)$/ replaced with /at .+ \((.+):(\d+):(?:\d)\)$/
Mutant 301 in q.js: /at .+ \((.+):(\d+):(?:\d+)\)$/ replaced with /at .+ \((.+):(\d+):(?:\D+)\)$/
Mutant 302 in q.js: attempt1 replaced with true
Mutant 303 in q.js: attempt1 replaced with false
Mutant 304 in q.js: {
  return [attempt1[1], Number(attempt1[2])];
} replaced with {}
Mutant 305 in q.js: [attempt1[1], Number(attempt1[2])] replaced with []
Mutant 306 in q.js: /at ([^ ]+):(\d+):(?:\d+)$/ replaced with /at ([^ ]+):(\d+):(?:\d+)/
Mutant 307 in q.js: /at ([^ ]+):(\d+):(?:\d+)$/ replaced with /at ([^ ]):(\d+):(?:\d+)$/
Mutant 308 in q.js: /at ([^ ]+):(\d+):(?:\d+)$/ replaced with /at ([ ]+):(\d+):(?:\d+)$/
Mutant 309 in q.js: /at ([^ ]+):(\d+):(?:\d+)$/ replaced with /at ([^ ]+):(\d):(?:\d+)$/
Mutant 310 in q.js: /at ([^ ]+):(\d+):(?:\d+)$/ replaced with /at ([^ ]+):(\D+):(?:\d+)$/
Mutant 311 in q.js: /at ([^ ]+):(\d+):(?:\d+)$/ replaced with /at ([^ ]+):(\d+):(?:\d)$/
Mutant 312 in q.js: /at ([^ ]+):(\d+):(?:\d+)$/ replaced with /at ([^ ]+):(\d+):(?:\D+)$/
Mutant 313 in q.js: attempt2 replaced with true
Mutant 314 in q.js: attempt2 replaced with false
Mutant 315 in q.js: {
  return [attempt2[1], Number(attempt2[2])];
} replaced with {}
Mutant 316 in q.js: [attempt2[1], Number(attempt2[2])] replaced with []
Mutant 317 in q.js: /.*@(.+):(\d+)$/ replaced with /.*@(.+):(\d+)/
Mutant 318 in q.js: /.*@(.+):(\d+)$/ replaced with /.@(.+):(\d+)$/
Mutant 319 in q.js: /.*@(.+):(\d+)$/ replaced with /.*@(.):(\d+)$/
Mutant 320 in q.js: /.*@(.+):(\d+)$/ replaced with /.*@(.+):(\d)$/
Mutant 321 in q.js: /.*@(.+):(\d+)$/ replaced with /.*@(.+):(\D+)$/
Mutant 322 in q.js: attempt3 replaced with true
Mutant 323 in q.js: attempt3 replaced with false
Mutant 324 in q.js: {
  return [attempt3[1], Number(attempt3[2])];
} replaced with {}
Mutant 325 in q.js: [attempt3[1], Number(attempt3[2])] replaced with []
Mutant 326 in q.js: {
  var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
  if (!fileNameAndLineNumber) {
    return false;
  }
  var fileName = fileNameAndLineNumber[0];
  var lineNumber = fileNameAndLineNumber[1];
  return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
} replaced with {}
Mutant 327 in q.js: !fileNameAndLineNumber replaced with fileNameAndLineNumber
Mutant 328 in q.js: !fileNameAndLineNumber replaced with true
Mutant 329 in q.js: !fileNameAndLineNumber replaced with false
Mutant 330 in q.js: {
  return false;
} replaced with {}
Mutant 331 in q.js: false replaced with true
Mutant 332 in q.js: fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine replaced with true
Mutant 333 in q.js: fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine replaced with false
Mutant 334 in q.js: fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine replaced with fileName === qFileName && lineNumber >= qStartingLine || lineNumber <= qEndingLine
Mutant 335 in q.js: fileName === qFileName && lineNumber >= qStartingLine replaced with true
Mutant 336 in q.js: fileName === qFileName && lineNumber >= qStartingLine replaced with fileName === qFileName || lineNumber >= qStartingLine
Mutant 337 in q.js: fileName === qFileName replaced with true
Mutant 338 in q.js: fileName === qFileName replaced with fileName !== qFileName
Mutant 339 in q.js: lineNumber >= qStartingLine replaced with true
Mutant 340 in q.js: lineNumber >= qStartingLine replaced with lineNumber > qStartingLine
Mutant 341 in q.js: lineNumber >= qStartingLine replaced with lineNumber < qStartingLine
Mutant 342 in q.js: lineNumber <= qEndingLine replaced with true
Mutant 343 in q.js: lineNumber <= qEndingLine replaced with lineNumber < qEndingLine
Mutant 344 in q.js: lineNumber <= qEndingLine replaced with lineNumber > qEndingLine
Mutant 345 in q.js: {
  if (!hasStacks) {
    return;
  }
  try {
    throw new Error();
  } catch (e) {
    var lines = e.stack.split("\n");
    var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
    var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
    if (!fileNameAndLineNumber) {
      return;
    }
    qFileName = fileNameAndLineNumber[0];
    return fileNameAndLineNumber[1];
  }
} replaced with {}
Mutant 346 in q.js: !hasStacks replaced with hasStacks
Mutant 347 in q.js: !hasStacks replaced with true
Mutant 348 in q.js: !hasStacks replaced with false
Mutant 349 in q.js: {
  return;
} replaced with {}
Mutant 350 in q.js: {
  throw new Error();
} replaced with {}
Mutant 351 in q.js: {
  var lines = e.stack.split("\n");
  var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
  var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
  if (!fileNameAndLineNumber) {
    return;
  }
  qFileName = fileNameAndLineNumber[0];
  return fileNameAndLineNumber[1];
} replaced with {}
Mutant 352 in q.js: "\n" replaced with ""
Mutant 353 in q.js: lines[0].indexOf("@") > 0 replaced with true
Mutant 354 in q.js: lines[0].indexOf("@") > 0 replaced with false
Mutant 355 in q.js: lines[0].indexOf("@") > 0 replaced with lines[0].indexOf("@") >= 0
Mutant 356 in q.js: lines[0].indexOf("@") > 0 replaced with lines[0].indexOf("@") <= 0
Mutant 357 in q.js: "@" replaced with ""
Mutant 358 in q.js: !fileNameAndLineNumber replaced with fileNameAndLineNumber
Mutant 359 in q.js: !fileNameAndLineNumber replaced with true
Mutant 360 in q.js: !fileNameAndLineNumber replaced with false
Mutant 361 in q.js: {
  return;
} replaced with {}
Mutant 362 in q.js: {
  return function () {
    if (typeof console !== "undefined" && typeof console.warn === "function") {
      console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
    }
    return callback.apply(callback, arguments);
  };
} replaced with {}
Mutant 363 in q.js: {
  if (typeof console !== "undefined" && typeof console.warn === "function") {
    console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
  }
  return callback.apply(callback, arguments);
} replaced with {}
Mutant 364 in q.js: typeof console !== "undefined" && typeof console.warn === "function" replaced with true
Mutant 365 in q.js: typeof console !== "undefined" && typeof console.warn === "function" replaced with false
Mutant 366 in q.js: typeof console !== "undefined" && typeof console.warn === "function" replaced with typeof console !== "undefined" || typeof console.warn === "function"
Mutant 367 in q.js: typeof console !== "undefined" replaced with true
Mutant 368 in q.js: typeof console !== "undefined" replaced with typeof console === "undefined"
Mutant 369 in q.js: "undefined" replaced with ""
Mutant 370 in q.js: typeof console.warn === "function" replaced with true
Mutant 371 in q.js: typeof console.warn === "function" replaced with typeof console.warn !== "function"
Mutant 372 in q.js: "function" replaced with ""
Mutant 373 in q.js: {
  console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
} replaced with {}
Mutant 374 in q.js: " is deprecated, use " replaced with ""
Mutant 375 in q.js: " instead." replaced with ""
Mutant 376 in q.js: "" replaced with "Stryker was here!"
Mutant 377 in q.js: {
  // If the object is already a Promise, return it directly.  This enables
  // the resolve function to both be used to created references from objects,
  // but to tolerably coerce non-promises to promises.
  if (value instanceof Promise) {
    return value;
  }

  // assimilate thenables
  if (isPromiseAlike(value)) {
    return coerce(value);
  } else {
    return fulfill(value);
  }
} replaced with {}
Mutant 378 in q.js: value instanceof Promise replaced with true
Mutant 379 in q.js: value instanceof Promise replaced with false
Mutant 380 in q.js: {
  return value;
} replaced with {}
Mutant 381 in q.js: isPromiseAlike(value) replaced with true
Mutant 382 in q.js: isPromiseAlike(value) replaced with false
Mutant 383 in q.js: {
  return coerce(value);
} replaced with {}
Mutant 384 in q.js: {
  return fulfill(value);
} replaced with {}
Mutant 385 in q.js: false replaced with true
Mutant 386 in q.js: typeof process === "object" && process && process.env && process.env.Q_DEBUG replaced with true
Mutant 387 in q.js: typeof process === "object" && process && process.env && process.env.Q_DEBUG replaced with false
Mutant 388 in q.js: typeof process === "object" && process && process.env && process.env.Q_DEBUG replaced with typeof process === "object" && process && process.env || process.env.Q_DEBUG
Mutant 389 in q.js: typeof process === "object" && process && process.env replaced with true
Mutant 390 in q.js: typeof process === "object" && process && process.env replaced with typeof process === "object" && process || process.env
Mutant 391 in q.js: typeof process === "object" && process replaced with true
Mutant 392 in q.js: typeof process === "object" && process replaced with typeof process === "object" || process
Mutant 393 in q.js: typeof process === "object" replaced with true
Mutant 394 in q.js: typeof process === "object" replaced with typeof process !== "object"
Mutant 395 in q.js: "object" replaced with ""
Mutant 396 in q.js: {
  Q.longStackSupport = true;
} replaced with {}
Mutant 397 in q.js: true replaced with false
Mutant 398 in q.js: {
  // if "messages" is an "Array", that indicates that the promise has not yet
  // been resolved.  If it is "undefined", it has been resolved.  Each
  // element of the messages array is itself an array of complete arguments to
  // forward to the resolved promise.  We coerce the resolution value to a
  // promise using the `resolve` function because it handles both fully
  // non-thenable values and other thenables gracefully.
  var messages = [],
    progressListeners = [],
    resolvedPromise;
  var deferred = object_create(defer.prototype);
  var promise = object_create(Promise.prototype);
  promise.promiseDispatch = function (resolve, op, operands) {
    var args = array_slice(arguments);
    if (messages) {
      messages.push(args);
      if (op === "when" && operands[1]) {
        // progress operand
        progressListeners.push(operands[1]);
      }
    } else {
      Q.nextTick(function () {
        resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
      });
    }
  };

  // XXX deprecated
  promise.valueOf = function () {
    if (messages) {
      return promise;
    }
    var nearerValue = nearer(resolvedPromise);
    if (isPromise(nearerValue)) {
      resolvedPromise = nearerValue; // shorten chain
    }
    return nearerValue;
  };
  promise.inspect = function () {
    if (!resolvedPromise) {
      return {
        state: "pending"
      };
    }
    return resolvedPromise.inspect();
  };
  if (Q.longStackSupport && hasStacks) {
    try {
      throw new Error();
    } catch (e) {
      // NOTE: don't try to use `Error.captureStackTrace` or transfer the
      // accessor around; that causes memory leaks as per GH-111. Just
      // reify the stack trace as a string ASAP.
      //
      // At the same time, cut off the first line; it's always just
      // "[object Promise]\n", as per the `toString`.
      promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
      promise.stackCounter = longStackCounter++;
    }
  }

  // NOTE: we do the checks for `resolvedPromise` in each method, instead of
  // consolidating them into `become`, since otherwise we'd create new
  // promises with the lines `become(whatever(value))`. See e.g. GH-252.

  function become(newPromise) {
    resolvedPromise = newPromise;
    if (Q.longStackSupport && hasStacks) {
      // Only hold a reference to the new promise if long stacks
      // are enabled to reduce memory usage
      promise.source = newPromise;
    }
    array_reduce(messages, function (undefined, message) {
      Q.nextTick(function () {
        newPromise.promiseDispatch.apply(newPromise, message);
      });
    }, void 0);
    messages = void 0;
    progressListeners = void 0;
  }
  deferred.promise = promise;
  deferred.resolve = function (value) {
    if (resolvedPromise) {
      return;
    }
    become(Q(value));
  };
  deferred.fulfill = function (value) {
    if (resolvedPromise) {
      return;
    }
    become(fulfill(value));
  };
  deferred.reject = function (reason) {
    if (resolvedPromise) {
      return;
    }
    become(reject(reason));
  };
  deferred.notify = function (progress) {
    if (resolvedPromise) {
      return;
    }
    array_reduce(progressListeners, function (undefined, progressListener) {
      Q.nextTick(function () {
        progressListener(progress);
      });
    }, void 0);
  };
  return deferred;
} replaced with {}
Mutant 399 in q.js: [] replaced with ["Stryker was here"]
Mutant 400 in q.js: [] replaced with ["Stryker was here"]
Mutant 401 in q.js: {
  var args = array_slice(arguments);
  if (messages) {
    messages.push(args);
    if (op === "when" && operands[1]) {
      // progress operand
      progressListeners.push(operands[1]);
    }
  } else {
    Q.nextTick(function () {
      resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
    });
  }
} replaced with {}
Mutant 402 in q.js: messages replaced with true
Mutant 403 in q.js: messages replaced with false
Mutant 404 in q.js: {
  messages.push(args);
  if (op === "when" && operands[1]) {
    // progress operand
    progressListeners.push(operands[1]);
  }
} replaced with {}
Mutant 405 in q.js: op === "when" && operands[1] replaced with true
Mutant 406 in q.js: op === "when" && operands[1] replaced with false
Mutant 407 in q.js: op === "when" && operands[1] replaced with op === "when" || operands[1]
Mutant 408 in q.js: op === "when" replaced with true
Mutant 409 in q.js: op === "when" replaced with op !== "when"
Mutant 410 in q.js: "when" replaced with ""
Mutant 411 in q.js: {
  // progress operand
  progressListeners.push(operands[1]);
} replaced with {}
Mutant 412 in q.js: {
  Q.nextTick(function () {
    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
  });
} replaced with {}
Mutant 413 in q.js: {
  resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
} replaced with {}
Mutant 414 in q.js: {
  if (messages) {
    return promise;
  }
  var nearerValue = nearer(resolvedPromise);
  if (isPromise(nearerValue)) {
    resolvedPromise = nearerValue; // shorten chain
  }
  return nearerValue;
} replaced with {}
Mutant 415 in q.js: messages replaced with true
Mutant 416 in q.js: messages replaced with false
Mutant 417 in q.js: {
  return promise;
} replaced with {}
Mutant 418 in q.js: isPromise(nearerValue) replaced with true
Mutant 419 in q.js: isPromise(nearerValue) replaced with false
Mutant 420 in q.js: {
  resolvedPromise = nearerValue; // shorten chain
} replaced with {}
Mutant 421 in q.js: {
  if (!resolvedPromise) {
    return {
      state: "pending"
    };
  }
  return resolvedPromise.inspect();
} replaced with {}
Mutant 422 in q.js: !resolvedPromise replaced with resolvedPromise
Mutant 423 in q.js: !resolvedPromise replaced with true
Mutant 424 in q.js: !resolvedPromise replaced with false
Mutant 425 in q.js: {
  return {
    state: "pending"
  };
} replaced with {}
Mutant 426 in q.js: {
  state: "pending"
} replaced with {}
Mutant 427 in q.js: "pending" replaced with ""
Mutant 428 in q.js: Q.longStackSupport && hasStacks replaced with true
Mutant 429 in q.js: Q.longStackSupport && hasStacks replaced with false
Mutant 430 in q.js: Q.longStackSupport && hasStacks replaced with Q.longStackSupport || hasStacks
Mutant 431 in q.js: {
  try {
    throw new Error();
  } catch (e) {
    // NOTE: don't try to use `Error.captureStackTrace` or transfer the
    // accessor around; that causes memory leaks as per GH-111. Just
    // reify the stack trace as a string ASAP.
    //
    // At the same time, cut off the first line; it's always just
    // "[object Promise]\n", as per the `toString`.
    promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
    promise.stackCounter = longStackCounter++;
  }
} replaced with {}
Mutant 432 in q.js: {
  throw new Error();
} replaced with {}
Mutant 433 in q.js: {
  // NOTE: don't try to use `Error.captureStackTrace` or transfer the
  // accessor around; that causes memory leaks as per GH-111. Just
  // reify the stack trace as a string ASAP.
  //
  // At the same time, cut off the first line; it's always just
  // "[object Promise]\n", as per the `toString`.
  promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
  promise.stackCounter = longStackCounter++;
} replaced with {}
Mutant 434 in q.js: e.stack.substring(e.stack.indexOf("\n") + 1) replaced with e.stack
Mutant 435 in q.js: e.stack.indexOf("\n") + 1 replaced with e.stack.indexOf("\n") - 1
Mutant 436 in q.js: "\n" replaced with ""
Mutant 437 in q.js: longStackCounter++ replaced with longStackCounter--
Mutant 438 in q.js: {
  resolvedPromise = newPromise;
  if (Q.longStackSupport && hasStacks) {
    // Only hold a reference to the new promise if long stacks
    // are enabled to reduce memory usage
    promise.source = newPromise;
  }
  array_reduce(messages, function (undefined, message) {
    Q.nextTick(function () {
      newPromise.promiseDispatch.apply(newPromise, message);
    });
  }, void 0);
  messages = void 0;
  progressListeners = void 0;
} replaced with {}
Mutant 439 in q.js: Q.longStackSupport && hasStacks replaced with true
Mutant 440 in q.js: Q.longStackSupport && hasStacks replaced with false
Mutant 441 in q.js: Q.longStackSupport && hasStacks replaced with Q.longStackSupport || hasStacks
Mutant 442 in q.js: {
  // Only hold a reference to the new promise if long stacks
  // are enabled to reduce memory usage
  promise.source = newPromise;
} replaced with {}
Mutant 443 in q.js: {
  Q.nextTick(function () {
    newPromise.promiseDispatch.apply(newPromise, message);
  });
} replaced with {}
Mutant 444 in q.js: {
  newPromise.promiseDispatch.apply(newPromise, message);
} replaced with {}
Mutant 445 in q.js: {
  if (resolvedPromise) {
    return;
  }
  become(Q(value));
} replaced with {}
Mutant 446 in q.js: resolvedPromise replaced with true
Mutant 447 in q.js: resolvedPromise replaced with false
Mutant 448 in q.js: {
  return;
} replaced with {}
Mutant 449 in q.js: {
  if (resolvedPromise) {
    return;
  }
  become(fulfill(value));
} replaced with {}
Mutant 450 in q.js: resolvedPromise replaced with true
Mutant 451 in q.js: resolvedPromise replaced with false
Mutant 452 in q.js: {
  return;
} replaced with {}
Mutant 453 in q.js: {
  if (resolvedPromise) {
    return;
  }
  become(reject(reason));
} replaced with {}
Mutant 454 in q.js: resolvedPromise replaced with true
Mutant 455 in q.js: resolvedPromise replaced with false
Mutant 456 in q.js: {
  return;
} replaced with {}
Mutant 457 in q.js: {
  if (resolvedPromise) {
    return;
  }
  array_reduce(progressListeners, function (undefined, progressListener) {
    Q.nextTick(function () {
      progressListener(progress);
    });
  }, void 0);
} replaced with {}
Mutant 458 in q.js: resolvedPromise replaced with true
Mutant 459 in q.js: resolvedPromise replaced with false
Mutant 460 in q.js: {
  return;
} replaced with {}
Mutant 461 in q.js: {
  Q.nextTick(function () {
    progressListener(progress);
  });
} replaced with {}
Mutant 462 in q.js: {
  progressListener(progress);
} replaced with {}
Mutant 463 in q.js: {
  var self = this;
  return function (error, value) {
    if (error) {
      self.reject(error);
    } else if (arguments.length > 2) {
      self.resolve(array_slice(arguments, 1));
    } else {
      self.resolve(value);
    }
  };
} replaced with {}
Mutant 464 in q.js: {
  if (error) {
    self.reject(error);
  } else if (arguments.length > 2) {
    self.resolve(array_slice(arguments, 1));
  } else {
    self.resolve(value);
  }
} replaced with {}
Mutant 465 in q.js: error replaced with true
Mutant 466 in q.js: error replaced with false
Mutant 467 in q.js: {
  self.reject(error);
} replaced with {}
Mutant 468 in q.js: arguments.length > 2 replaced with true
Mutant 469 in q.js: arguments.length > 2 replaced with false
Mutant 470 in q.js: arguments.length > 2 replaced with arguments.length >= 2
Mutant 471 in q.js: arguments.length > 2 replaced with arguments.length <= 2
Mutant 472 in q.js: {
  self.resolve(array_slice(arguments, 1));
} replaced with {}
Mutant 473 in q.js: {
  self.resolve(value);
} replaced with {}
Mutant 474 in q.js: {
  if (typeof resolver !== "function") {
    throw new TypeError("resolver must be a function.");
  }
  var deferred = defer();
  try {
    resolver(deferred.resolve, deferred.reject, deferred.notify);
  } catch (reason) {
    deferred.reject(reason);
  }
  return deferred.promise;
} replaced with {}
Mutant 475 in q.js: typeof resolver !== "function" replaced with true
Mutant 476 in q.js: typeof resolver !== "function" replaced with false
Mutant 477 in q.js: typeof resolver !== "function" replaced with typeof resolver === "function"
Mutant 478 in q.js: "function" replaced with ""
Mutant 479 in q.js: {
  throw new TypeError("resolver must be a function.");
} replaced with {}
Mutant 480 in q.js: "resolver must be a function." replaced with ""
Mutant 481 in q.js: {
  resolver(deferred.resolve, deferred.reject, deferred.notify);
} replaced with {}
Mutant 482 in q.js: {
  deferred.reject(reason);
} replaced with {}
Mutant 483 in q.js: {
  //freeze(object);
  //passByCopies.set(object, true);
  return object;
} replaced with {}
Mutant 484 in q.js: {
  //freeze(object);
  //passByCopies.set(object, true);
  return this;
} replaced with {}
Mutant 485 in q.js: {
  return Q(x).join(y);
} replaced with {}
Mutant 486 in q.js: {
  return Q([this, that]).spread(function (x, y) {
    if (x === y) {
      // TODO: "===" should be Object.is or equiv
      return x;
    } else {
      throw new Error("Q can't join: not the same: " + x + " " + y);
    }
  });
} replaced with {}
Mutant 487 in q.js: [this, that] replaced with []
Mutant 488 in q.js: {
  if (x === y) {
    // TODO: "===" should be Object.is or equiv
    return x;
  } else {
    throw new Error("Q can't join: not the same: " + x + " " + y);
  }
} replaced with {}
Mutant 489 in q.js: x === y replaced with true
Mutant 490 in q.js: x === y replaced with false
Mutant 491 in q.js: x === y replaced with x !== y
Mutant 492 in q.js: {
  // TODO: "===" should be Object.is or equiv
  return x;
} replaced with {}
Mutant 493 in q.js: {
  throw new Error("Q can't join: not the same: " + x + " " + y);
} replaced with {}
Mutant 494 in q.js: "Q can't join: not the same: " replaced with ""
Mutant 495 in q.js: " " replaced with ""
Mutant 496 in q.js: {
  return promise(function (resolve, reject) {
    // Switch to this once we can assume at least ES5
    // answerPs.forEach(function (answerP) {
    //     Q(answerP).then(resolve, reject);
    // });
    // Use this in the meantime
    for (var i = 0, len = answerPs.length; i < len; i++) {
      Q(answerPs[i]).then(resolve, reject);
    }
  });
} replaced with {}
Mutant 497 in q.js: {
  // Switch to this once we can assume at least ES5
  // answerPs.forEach(function (answerP) {
  //     Q(answerP).then(resolve, reject);
  // });
  // Use this in the meantime
  for (var i = 0, len = answerPs.length; i < len; i++) {
    Q(answerPs[i]).then(resolve, reject);
  }
} replaced with {}
Mutant 498 in q.js: i < len replaced with false
Mutant 499 in q.js: i < len replaced with i <= len
Mutant 500 in q.js: i < len replaced with i >= len
Mutant 501 in q.js: i++ replaced with i--
Mutant 502 in q.js: {
  Q(answerPs[i]).then(resolve, reject);
} replaced with {}
Mutant 503 in q.js: {
  return this.then(Q.race);
} replaced with {}
Mutant 504 in q.js: {
  if (fallback === void 0) {
    fallback = function (op) {
      return reject(new Error("Promise does not support operation: " + op));
    };
  }
  if (inspect === void 0) {
    inspect = function () {
      return {
        state: "unknown"
      };
    };
  }
  var promise = object_create(Promise.prototype);
  promise.promiseDispatch = function (resolve, op, args) {
    var result;
    try {
      if (descriptor[op]) {
        result = descriptor[op].apply(promise, args);
      } else {
        result = fallback.call(promise, op, args);
      }
    } catch (exception) {
      result = reject(exception);
    }
    if (resolve) {
      resolve(result);
    }
  };
  promise.inspect = inspect;

  // XXX deprecated `valueOf` and `exception` support
  if (inspect) {
    var inspected = inspect();
    if (inspected.state === "rejected") {
      promise.exception = inspected.reason;
    }
    promise.valueOf = function () {
      var inspected = inspect();
      if (inspected.state === "pending" || inspected.state === "rejected") {
        return promise;
      }
      return inspected.value;
    };
  }
  return promise;
} replaced with {}
Mutant 505 in q.js: fallback === void 0 replaced with true
Mutant 506 in q.js: fallback === void 0 replaced with false
Mutant 507 in q.js: fallback === void 0 replaced with fallback !== void 0
Mutant 508 in q.js: {
  fallback = function (op) {
    return reject(new Error("Promise does not support operation: " + op));
  };
} replaced with {}
Mutant 509 in q.js: {
  return reject(new Error("Promise does not support operation: " + op));
} replaced with {}
Mutant 510 in q.js: "Promise does not support operation: " replaced with ""
Mutant 511 in q.js: inspect === void 0 replaced with true
Mutant 512 in q.js: inspect === void 0 replaced with false
Mutant 513 in q.js: inspect === void 0 replaced with inspect !== void 0
Mutant 514 in q.js: {
  inspect = function () {
    return {
      state: "unknown"
    };
  };
} replaced with {}
Mutant 515 in q.js: {
  return {
    state: "unknown"
  };
} replaced with {}
Mutant 516 in q.js: {
  state: "unknown"
} replaced with {}
Mutant 517 in q.js: "unknown" replaced with ""
Mutant 518 in q.js: {
  var result;
  try {
    if (descriptor[op]) {
      result = descriptor[op].apply(promise, args);
    } else {
      result = fallback.call(promise, op, args);
    }
  } catch (exception) {
    result = reject(exception);
  }
  if (resolve) {
    resolve(result);
  }
} replaced with {}
Mutant 519 in q.js: {
  if (descriptor[op]) {
    result = descriptor[op].apply(promise, args);
  } else {
    result = fallback.call(promise, op, args);
  }
} replaced with {}
Mutant 520 in q.js: descriptor[op] replaced with true
Mutant 521 in q.js: descriptor[op] replaced with false
Mutant 522 in q.js: {
  result = descriptor[op].apply(promise, args);
} replaced with {}
Mutant 523 in q.js: {
  result = fallback.call(promise, op, args);
} replaced with {}
Mutant 524 in q.js: {
  result = reject(exception);
} replaced with {}
Mutant 525 in q.js: resolve replaced with true
Mutant 526 in q.js: resolve replaced with false
Mutant 527 in q.js: {
  resolve(result);
} replaced with {}
Mutant 528 in q.js: inspect replaced with true
Mutant 529 in q.js: inspect replaced with false
Mutant 530 in q.js: {
  var inspected = inspect();
  if (inspected.state === "rejected") {
    promise.exception = inspected.reason;
  }
  promise.valueOf = function () {
    var inspected = inspect();
    if (inspected.state === "pending" || inspected.state === "rejected") {
      return promise;
    }
    return inspected.value;
  };
} replaced with {}
Mutant 531 in q.js: inspected.state === "rejected" replaced with true
Mutant 532 in q.js: inspected.state === "rejected" replaced with false
Mutant 533 in q.js: inspected.state === "rejected" replaced with inspected.state !== "rejected"
Mutant 534 in q.js: "rejected" replaced with ""
Mutant 535 in q.js: {
  promise.exception = inspected.reason;
} replaced with {}
Mutant 536 in q.js: {
  var inspected = inspect();
  if (inspected.state === "pending" || inspected.state === "rejected") {
    return promise;
  }
  return inspected.value;
} replaced with {}
Mutant 537 in q.js: inspected.state === "pending" || inspected.state === "rejected" replaced with true
Mutant 538 in q.js: inspected.state === "pending" || inspected.state === "rejected" replaced with false
Mutant 539 in q.js: inspected.state === "pending" || inspected.state === "rejected" replaced with inspected.state === "pending" && inspected.state === "rejected"
Mutant 540 in q.js: inspected.state === "pending" replaced with false
Mutant 541 in q.js: inspected.state === "pending" replaced with inspected.state !== "pending"
Mutant 542 in q.js: "pending" replaced with ""
Mutant 543 in q.js: inspected.state === "rejected" replaced with false
Mutant 544 in q.js: inspected.state === "rejected" replaced with inspected.state !== "rejected"
Mutant 545 in q.js: "rejected" replaced with ""
Mutant 546 in q.js: {
  return promise;
} replaced with {}
Mutant 547 in q.js: {
  return "[object Promise]";
} replaced with {}
Mutant 548 in q.js: "[object Promise]" replaced with ""
Mutant 549 in q.js: {
  var self = this;
  var deferred = defer();
  var done = false; // ensure the untrusted promise makes at most a
  // single call to one of the callbacks

  function _fulfilled(value) {
    try {
      return typeof fulfilled === "function" ? fulfilled(value) : value;
    } catch (exception) {
      return reject(exception);
    }
  }
  function _rejected(exception) {
    if (typeof rejected === "function") {
      makeStackTraceLong(exception, self);
      try {
        return rejected(exception);
      } catch (newException) {
        return reject(newException);
      }
    }
    return reject(exception);
  }
  function _progressed(value) {
    return typeof progressed === "function" ? progressed(value) : value;
  }
  Q.nextTick(function () {
    self.promiseDispatch(function (value) {
      if (done) {
        return;
      }
      done = true;
      deferred.resolve(_fulfilled(value));
    }, "when", [function (exception) {
      if (done) {
        return;
      }
      done = true;
      deferred.resolve(_rejected(exception));
    }]);
  });

  // Progress propagator need to be attached in the current tick.
  self.promiseDispatch(void 0, "when", [void 0, function (value) {
    var newValue;
    var threw = false;
    try {
      newValue = _progressed(value);
    } catch (e) {
      threw = true;
      if (Q.onerror) {
        Q.onerror(e);
      } else {
        throw e;
      }
    }
    if (!threw) {
      deferred.notify(newValue);
    }
  }]);
  return deferred.promise;
} replaced with {}
Mutant 550 in q.js: false replaced with true
Mutant 551 in q.js: {
  try {
    return typeof fulfilled === "function" ? fulfilled(value) : value;
  } catch (exception) {
    return reject(exception);
  }
} replaced with {}
Mutant 552 in q.js: {
  return typeof fulfilled === "function" ? fulfilled(value) : value;
} replaced with {}
Mutant 553 in q.js: typeof fulfilled === "function" replaced with true
Mutant 554 in q.js: typeof fulfilled === "function" replaced with false
Mutant 555 in q.js: typeof fulfilled === "function" replaced with typeof fulfilled !== "function"
Mutant 556 in q.js: "function" replaced with ""
Mutant 557 in q.js: {
  return reject(exception);
} replaced with {}
Mutant 558 in q.js: {
  if (typeof rejected === "function") {
    makeStackTraceLong(exception, self);
    try {
      return rejected(exception);
    } catch (newException) {
      return reject(newException);
    }
  }
  return reject(exception);
} replaced with {}
Mutant 559 in q.js: typeof rejected === "function" replaced with true
Mutant 560 in q.js: typeof rejected === "function" replaced with false
Mutant 561 in q.js: typeof rejected === "function" replaced with typeof rejected !== "function"
Mutant 562 in q.js: "function" replaced with ""
Mutant 563 in q.js: {
  makeStackTraceLong(exception, self);
  try {
    return rejected(exception);
  } catch (newException) {
    return reject(newException);
  }
} replaced with {}
Mutant 564 in q.js: {
  return rejected(exception);
} replaced with {}
Mutant 565 in q.js: {
  return reject(newException);
} replaced with {}
Mutant 566 in q.js: {
  return typeof progressed === "function" ? progressed(value) : value;
} replaced with {}
Mutant 567 in q.js: typeof progressed === "function" replaced with true
Mutant 568 in q.js: typeof progressed === "function" replaced with false
Mutant 569 in q.js: typeof progressed === "function" replaced with typeof progressed !== "function"
Mutant 570 in q.js: "function" replaced with ""
Mutant 571 in q.js: {
  self.promiseDispatch(function (value) {
    if (done) {
      return;
    }
    done = true;
    deferred.resolve(_fulfilled(value));
  }, "when", [function (exception) {
    if (done) {
      return;
    }
    done = true;
    deferred.resolve(_rejected(exception));
  }]);
} replaced with {}
Mutant 572 in q.js: {
  if (done) {
    return;
  }
  done = true;
  deferred.resolve(_fulfilled(value));
} replaced with {}
Mutant 573 in q.js: done replaced with true
Mutant 574 in q.js: done replaced with false
Mutant 575 in q.js: {
  return;
} replaced with {}
Mutant 576 in q.js: true replaced with false
Mutant 577 in q.js: "when" replaced with ""
Mutant 578 in q.js: [function (exception) {
  if (done) {
    return;
  }
  done = true;
  deferred.resolve(_rejected(exception));
}] replaced with []
Mutant 579 in q.js: {
  if (done) {
    return;
  }
  done = true;
  deferred.resolve(_rejected(exception));
} replaced with {}
Mutant 580 in q.js: done replaced with true
Mutant 581 in q.js: done replaced with false
Mutant 582 in q.js: {
  return;
} replaced with {}
Mutant 583 in q.js: true replaced with false
Mutant 584 in q.js: "when" replaced with ""
Mutant 585 in q.js: [void 0, function (value) {
  var newValue;
  var threw = false;
  try {
    newValue = _progressed(value);
  } catch (e) {
    threw = true;
    if (Q.onerror) {
      Q.onerror(e);
    } else {
      throw e;
    }
  }
  if (!threw) {
    deferred.notify(newValue);
  }
}] replaced with []
Mutant 586 in q.js: {
  var newValue;
  var threw = false;
  try {
    newValue = _progressed(value);
  } catch (e) {
    threw = true;
    if (Q.onerror) {
      Q.onerror(e);
    } else {
      throw e;
    }
  }
  if (!threw) {
    deferred.notify(newValue);
  }
} replaced with {}
Mutant 587 in q.js: false replaced with true
Mutant 588 in q.js: {
  newValue = _progressed(value);
} replaced with {}
Mutant 589 in q.js: {
  threw = true;
  if (Q.onerror) {
    Q.onerror(e);
  } else {
    throw e;
  }
} replaced with {}
Mutant 590 in q.js: true replaced with false
Mutant 591 in q.js: Q.onerror replaced with true
Mutant 592 in q.js: Q.onerror replaced with false
Mutant 593 in q.js: {
  Q.onerror(e);
} replaced with {}
Mutant 594 in q.js: {
  throw e;
} replaced with {}
Mutant 595 in q.js: !threw replaced with threw
Mutant 596 in q.js: !threw replaced with true
Mutant 597 in q.js: !threw replaced with false
Mutant 598 in q.js: {
  deferred.notify(newValue);
} replaced with {}
Mutant 599 in q.js: {
  return Q(promise).tap(callback);
} replaced with {}
Mutant 600 in q.js: {
  callback = Q(callback);
  return this.then(function (value) {
    return callback.fcall(value).thenResolve(value);
  });
} replaced with {}
Mutant 601 in q.js: {
  return callback.fcall(value).thenResolve(value);
} replaced with {}
Mutant 602 in q.js: {
  return Q(value).then(fulfilled, rejected, progressed);
} replaced with {}
Mutant 603 in q.js: {
  return this.then(function () {
    return value;
  });
} replaced with {}
Mutant 604 in q.js: {
  return value;
} replaced with {}
Mutant 605 in q.js: {
  return Q(promise).thenResolve(value);
} replaced with {}
Mutant 606 in q.js: {
  return this.then(function () {
    throw reason;
  });
} replaced with {}
Mutant 607 in q.js: {
  throw reason;
} replaced with {}
Mutant 608 in q.js: {
  return Q(promise).thenReject(reason);
} replaced with {}
Mutant 609 in q.js: {
  if (isPromise(value)) {
    var inspected = value.inspect();
    if (inspected.state === "fulfilled") {
      return inspected.value;
    }
  }
  return value;
} replaced with {}
Mutant 610 in q.js: isPromise(value) replaced with true
Mutant 611 in q.js: isPromise(value) replaced with false
Mutant 612 in q.js: {
  var inspected = value.inspect();
  if (inspected.state === "fulfilled") {
    return inspected.value;
  }
} replaced with {}
Mutant 613 in q.js: inspected.state === "fulfilled" replaced with true
Mutant 614 in q.js: inspected.state === "fulfilled" replaced with false
Mutant 615 in q.js: inspected.state === "fulfilled" replaced with inspected.state !== "fulfilled"
Mutant 616 in q.js: "fulfilled" replaced with ""
Mutant 617 in q.js: {
  return inspected.value;
} replaced with {}
Mutant 618 in q.js: {
  return object instanceof Promise;
} replaced with {}
Mutant 619 in q.js: {
  return isObject(object) && typeof object.then === "function";
} replaced with {}
Mutant 620 in q.js: isObject(object) && typeof object.then === "function" replaced with true
Mutant 621 in q.js: isObject(object) && typeof object.then === "function" replaced with false
Mutant 622 in q.js: isObject(object) && typeof object.then === "function" replaced with isObject(object) || typeof object.then === "function"
Mutant 623 in q.js: typeof object.then === "function" replaced with true
Mutant 624 in q.js: typeof object.then === "function" replaced with typeof object.then !== "function"
Mutant 625 in q.js: "function" replaced with ""
Mutant 626 in q.js: {
  return isPromise(object) && object.inspect().state === "pending";
} replaced with {}
Mutant 627 in q.js: isPromise(object) && object.inspect().state === "pending" replaced with true
Mutant 628 in q.js: isPromise(object) && object.inspect().state === "pending" replaced with false
Mutant 629 in q.js: isPromise(object) && object.inspect().state === "pending" replaced with isPromise(object) || object.inspect().state === "pending"
Mutant 630 in q.js: object.inspect().state === "pending" replaced with true
Mutant 631 in q.js: object.inspect().state === "pending" replaced with object.inspect().state !== "pending"
Mutant 632 in q.js: "pending" replaced with ""
Mutant 633 in q.js: {
  return this.inspect().state === "pending";
} replaced with {}
Mutant 634 in q.js: this.inspect().state === "pending" replaced with true
Mutant 635 in q.js: this.inspect().state === "pending" replaced with false
Mutant 636 in q.js: this.inspect().state === "pending" replaced with this.inspect().state !== "pending"
Mutant 637 in q.js: "pending" replaced with ""
Mutant 638 in q.js: {
  return !isPromise(object) || object.inspect().state === "fulfilled";
} replaced with {}
Mutant 639 in q.js: !isPromise(object) || object.inspect().state === "fulfilled" replaced with true
Mutant 640 in q.js: !isPromise(object) || object.inspect().state === "fulfilled" replaced with false
Mutant 641 in q.js: !isPromise(object) || object.inspect().state === "fulfilled" replaced with !isPromise(object) && object.inspect().state === "fulfilled"
Mutant 642 in q.js: !isPromise(object) replaced with isPromise(object)
Mutant 643 in q.js: object.inspect().state === "fulfilled" replaced with false
Mutant 644 in q.js: object.inspect().state === "fulfilled" replaced with object.inspect().state !== "fulfilled"
Mutant 645 in q.js: "fulfilled" replaced with ""
Mutant 646 in q.js: {
  return this.inspect().state === "fulfilled";
} replaced with {}
Mutant 647 in q.js: this.inspect().state === "fulfilled" replaced with true
Mutant 648 in q.js: this.inspect().state === "fulfilled" replaced with false
Mutant 649 in q.js: this.inspect().state === "fulfilled" replaced with this.inspect().state !== "fulfilled"
Mutant 650 in q.js: "fulfilled" replaced with ""
Mutant 651 in q.js: {
  return isPromise(object) && object.inspect().state === "rejected";
} replaced with {}
Mutant 652 in q.js: isPromise(object) && object.inspect().state === "rejected" replaced with true
Mutant 653 in q.js: isPromise(object) && object.inspect().state === "rejected" replaced with false
Mutant 654 in q.js: isPromise(object) && object.inspect().state === "rejected" replaced with isPromise(object) || object.inspect().state === "rejected"
Mutant 655 in q.js: object.inspect().state === "rejected" replaced with true
Mutant 656 in q.js: object.inspect().state === "rejected" replaced with object.inspect().state !== "rejected"
Mutant 657 in q.js: "rejected" replaced with ""
Mutant 658 in q.js: {
  return this.inspect().state === "rejected";
} replaced with {}
Mutant 659 in q.js: this.inspect().state === "rejected" replaced with true
Mutant 660 in q.js: this.inspect().state === "rejected" replaced with false
Mutant 661 in q.js: this.inspect().state === "rejected" replaced with this.inspect().state !== "rejected"
Mutant 662 in q.js: "rejected" replaced with ""
Mutant 663 in q.js: [] replaced with ["Stryker was here"]
Mutant 664 in q.js: [] replaced with ["Stryker was here"]
Mutant 665 in q.js: [] replaced with ["Stryker was here"]
Mutant 666 in q.js: true replaced with false
Mutant 667 in q.js: {
  unhandledReasons.length = 0;
  unhandledRejections.length = 0;
  if (!trackUnhandledRejections) {
    trackUnhandledRejections = true;
  }
} replaced with {}
Mutant 668 in q.js: !trackUnhandledRejections replaced with trackUnhandledRejections
Mutant 669 in q.js: !trackUnhandledRejections replaced with true
Mutant 670 in q.js: !trackUnhandledRejections replaced with false
Mutant 671 in q.js: {
  trackUnhandledRejections = true;
} replaced with {}
Mutant 672 in q.js: true replaced with false
Mutant 673 in q.js: {
  if (!trackUnhandledRejections) {
    return;
  }
  if (typeof process === "object" && typeof process.emit === "function") {
    Q.nextTick.runAfter(function () {
      if (array_indexOf(unhandledRejections, promise) !== -1) {
        process.emit("unhandledRejection", reason, promise);
        reportedUnhandledRejections.push(promise);
      }
    });
  }
  unhandledRejections.push(promise);
  if (reason && typeof reason.stack !== "undefined") {
    unhandledReasons.push(reason.stack);
  } else {
    unhandledReasons.push("(no stack) " + reason);
  }
} replaced with {}
Mutant 674 in q.js: !trackUnhandledRejections replaced with trackUnhandledRejections
Mutant 675 in q.js: !trackUnhandledRejections replaced with true
Mutant 676 in q.js: !trackUnhandledRejections replaced with false
Mutant 677 in q.js: {
  return;
} replaced with {}
Mutant 678 in q.js: typeof process === "object" && typeof process.emit === "function" replaced with true
Mutant 679 in q.js: typeof process === "object" && typeof process.emit === "function" replaced with false
Mutant 680 in q.js: typeof process === "object" && typeof process.emit === "function" replaced with typeof process === "object" || typeof process.emit === "function"
Mutant 681 in q.js: typeof process === "object" replaced with true
Mutant 682 in q.js: typeof process === "object" replaced with typeof process !== "object"
Mutant 683 in q.js: "object" replaced with ""
Mutant 684 in q.js: typeof process.emit === "function" replaced with true
Mutant 685 in q.js: typeof process.emit === "function" replaced with typeof process.emit !== "function"
Mutant 686 in q.js: "function" replaced with ""
Mutant 687 in q.js: {
  Q.nextTick.runAfter(function () {
    if (array_indexOf(unhandledRejections, promise) !== -1) {
      process.emit("unhandledRejection", reason, promise);
      reportedUnhandledRejections.push(promise);
    }
  });
} replaced with {}
Mutant 688 in q.js: {
  if (array_indexOf(unhandledRejections, promise) !== -1) {
    process.emit("unhandledRejection", reason, promise);
    reportedUnhandledRejections.push(promise);
  }
} replaced with {}
Mutant 689 in q.js: array_indexOf(unhandledRejections, promise) !== -1 replaced with true
Mutant 690 in q.js: array_indexOf(unhandledRejections, promise) !== -1 replaced with false
Mutant 691 in q.js: array_indexOf(unhandledRejections, promise) !== -1 replaced with array_indexOf(unhandledRejections, promise) === -1
Mutant 692 in q.js: -1 replaced with +1
Mutant 693 in q.js: {
  process.emit("unhandledRejection", reason, promise);
  reportedUnhandledRejections.push(promise);
} replaced with {}
Mutant 694 in q.js: "unhandledRejection" replaced with ""
Mutant 695 in q.js: reason && typeof reason.stack !== "undefined" replaced with true
Mutant 696 in q.js: reason && typeof reason.stack !== "undefined" replaced with false
Mutant 697 in q.js: reason && typeof reason.stack !== "undefined" replaced with reason || typeof reason.stack !== "undefined"
Mutant 698 in q.js: typeof reason.stack !== "undefined" replaced with true
Mutant 699 in q.js: typeof reason.stack !== "undefined" replaced with typeof reason.stack === "undefined"
Mutant 700 in q.js: "undefined" replaced with ""
Mutant 701 in q.js: {
  unhandledReasons.push(reason.stack);
} replaced with {}
Mutant 702 in q.js: {
  unhandledReasons.push("(no stack) " + reason);
} replaced with {}
Mutant 703 in q.js: "(no stack) " replaced with ""
Mutant 704 in q.js: {
  if (!trackUnhandledRejections) {
    return;
  }
  var at = array_indexOf(unhandledRejections, promise);
  if (at !== -1) {
    if (typeof process === "object" && typeof process.emit === "function") {
      Q.nextTick.runAfter(function () {
        var atReport = array_indexOf(reportedUnhandledRejections, promise);
        if (atReport !== -1) {
          process.emit("rejectionHandled", unhandledReasons[at], promise);
          reportedUnhandledRejections.splice(atReport, 1);
        }
      });
    }
    unhandledRejections.splice(at, 1);
    unhandledReasons.splice(at, 1);
  }
} replaced with {}
Mutant 705 in q.js: !trackUnhandledRejections replaced with trackUnhandledRejections
Mutant 706 in q.js: !trackUnhandledRejections replaced with true
Mutant 707 in q.js: !trackUnhandledRejections replaced with false
Mutant 708 in q.js: {
  return;
} replaced with {}
Mutant 709 in q.js: at !== -1 replaced with true
Mutant 710 in q.js: at !== -1 replaced with false
Mutant 711 in q.js: at !== -1 replaced with at === -1
Mutant 712 in q.js: -1 replaced with +1
Mutant 713 in q.js: {
  if (typeof process === "object" && typeof process.emit === "function") {
    Q.nextTick.runAfter(function () {
      var atReport = array_indexOf(reportedUnhandledRejections, promise);
      if (atReport !== -1) {
        process.emit("rejectionHandled", unhandledReasons[at], promise);
        reportedUnhandledRejections.splice(atReport, 1);
      }
    });
  }
  unhandledRejections.splice(at, 1);
  unhandledReasons.splice(at, 1);
} replaced with {}
Mutant 714 in q.js: typeof process === "object" && typeof process.emit === "function" replaced with true
Mutant 715 in q.js: typeof process === "object" && typeof process.emit === "function" replaced with false
Mutant 716 in q.js: typeof process === "object" && typeof process.emit === "function" replaced with typeof process === "object" || typeof process.emit === "function"
Mutant 717 in q.js: typeof process === "object" replaced with true
Mutant 718 in q.js: typeof process === "object" replaced with typeof process !== "object"
Mutant 719 in q.js: "object" replaced with ""
Mutant 720 in q.js: typeof process.emit === "function" replaced with true
Mutant 721 in q.js: typeof process.emit === "function" replaced with typeof process.emit !== "function"
Mutant 722 in q.js: "function" replaced with ""
Mutant 723 in q.js: {
  Q.nextTick.runAfter(function () {
    var atReport = array_indexOf(reportedUnhandledRejections, promise);
    if (atReport !== -1) {
      process.emit("rejectionHandled", unhandledReasons[at], promise);
      reportedUnhandledRejections.splice(atReport, 1);
    }
  });
} replaced with {}
Mutant 724 in q.js: {
  var atReport = array_indexOf(reportedUnhandledRejections, promise);
  if (atReport !== -1) {
    process.emit("rejectionHandled", unhandledReasons[at], promise);
    reportedUnhandledRejections.splice(atReport, 1);
  }
} replaced with {}
Mutant 725 in q.js: atReport !== -1 replaced with true
Mutant 726 in q.js: atReport !== -1 replaced with false
Mutant 727 in q.js: atReport !== -1 replaced with atReport === -1
Mutant 728 in q.js: -1 replaced with +1
Mutant 729 in q.js: {
  process.emit("rejectionHandled", unhandledReasons[at], promise);
  reportedUnhandledRejections.splice(atReport, 1);
} replaced with {}
Mutant 730 in q.js: "rejectionHandled" replaced with ""
Mutant 731 in q.js: {
  // Make a copy so that consumers can't interfere with our internal state.
  return unhandledReasons.slice();
} replaced with {}
Mutant 732 in q.js: unhandledReasons.slice() replaced with unhandledReasons
Mutant 733 in q.js: {
  resetUnhandledRejections();
  trackUnhandledRejections = false;
} replaced with {}
Mutant 734 in q.js: false replaced with true
Mutant 735 in q.js: {
  var rejection = Promise({
    "when": function (rejected) {
      // note that the error has been handled
      if (rejected) {
        untrackRejection(this);
      }
      return rejected ? rejected(reason) : this;
    }
  }, function fallback() {
    return this;
  }, function inspect() {
    return {
      state: "rejected",
      reason: reason
    };
  });

  // Note that the reason has not been handled.
  trackRejection(rejection, reason);
  return rejection;
} replaced with {}
Mutant 736 in q.js: {
  "when": function (rejected) {
    // note that the error has been handled
    if (rejected) {
      untrackRejection(this);
    }
    return rejected ? rejected(reason) : this;
  }
} replaced with {}
Mutant 737 in q.js: {
  // note that the error has been handled
  if (rejected) {
    untrackRejection(this);
  }
  return rejected ? rejected(reason) : this;
} replaced with {}
Mutant 738 in q.js: rejected replaced with true
Mutant 739 in q.js: rejected replaced with false
Mutant 740 in q.js: {
  untrackRejection(this);
} replaced with {}
Mutant 741 in q.js: {
  return this;
} replaced with {}
Mutant 742 in q.js: {
  return {
    state: "rejected",
    reason: reason
  };
} replaced with {}
Mutant 743 in q.js: {
  state: "rejected",
  reason: reason
} replaced with {}
Mutant 744 in q.js: "rejected" replaced with ""
Mutant 745 in q.js: {
  return Promise({
    "when": function () {
      return value;
    },
    "get": function (name) {
      return value[name];
    },
    "set": function (name, rhs) {
      value[name] = rhs;
    },
    "delete": function (name) {
      delete value[name];
    },
    "post": function (name, args) {
      // Mark Miller proposes that post with no name should apply a
      // promised function.
      if (name === null || name === void 0) {
        return value.apply(void 0, args);
      } else {
        return value[name].apply(value, args);
      }
    },
    "apply": function (thisp, args) {
      return value.apply(thisp, args);
    },
    "keys": function () {
      return object_keys(value);
    }
  }, void 0, function inspect() {
    return {
      state: "fulfilled",
      value: value
    };
  });
} replaced with {}
Mutant 746 in q.js: {
  "when": function () {
    return value;
  },
  "get": function (name) {
    return value[name];
  },
  "set": function (name, rhs) {
    value[name] = rhs;
  },
  "delete": function (name) {
    delete value[name];
  },
  "post": function (name, args) {
    // Mark Miller proposes that post with no name should apply a
    // promised function.
    if (name === null || name === void 0) {
      return value.apply(void 0, args);
    } else {
      return value[name].apply(value, args);
    }
  },
  "apply": function (thisp, args) {
    return value.apply(thisp, args);
  },
  "keys": function () {
    return object_keys(value);
  }
} replaced with {}
Mutant 747 in q.js: {
  return value;
} replaced with {}
Mutant 748 in q.js: {
  return value[name];
} replaced with {}
Mutant 749 in q.js: {
  value[name] = rhs;
} replaced with {}
Mutant 750 in q.js: {
  delete value[name];
} replaced with {}
Mutant 751 in q.js: {
  // Mark Miller proposes that post with no name should apply a
  // promised function.
  if (name === null || name === void 0) {
    return value.apply(void 0, args);
  } else {
    return value[name].apply(value, args);
  }
} replaced with {}
Mutant 752 in q.js: name === null || name === void 0 replaced with true
Mutant 753 in q.js: name === null || name === void 0 replaced with false
Mutant 754 in q.js: name === null || name === void 0 replaced with name === null && name === void 0
Mutant 755 in q.js: name === null replaced with false
Mutant 756 in q.js: name === null replaced with name !== null
Mutant 757 in q.js: name === void 0 replaced with false
Mutant 758 in q.js: name === void 0 replaced with name !== void 0
Mutant 759 in q.js: {
  return value.apply(void 0, args);
} replaced with {}
Mutant 760 in q.js: {
  return value[name].apply(value, args);
} replaced with {}
Mutant 761 in q.js: {
  return value.apply(thisp, args);
} replaced with {}
Mutant 762 in q.js: {
  return object_keys(value);
} replaced with {}
Mutant 763 in q.js: {
  return {
    state: "fulfilled",
    value: value
  };
} replaced with {}
Mutant 764 in q.js: {
  state: "fulfilled",
  value: value
} replaced with {}
Mutant 765 in q.js: "fulfilled" replaced with ""
Mutant 766 in q.js: {
  var deferred = defer();
  Q.nextTick(function () {
    try {
      promise.then(deferred.resolve, deferred.reject, deferred.notify);
    } catch (exception) {
      deferred.reject(exception);
    }
  });
  return deferred.promise;
} replaced with {}
Mutant 767 in q.js: {
  try {
    promise.then(deferred.resolve, deferred.reject, deferred.notify);
  } catch (exception) {
    deferred.reject(exception);
  }
} replaced with {}
Mutant 768 in q.js: {
  promise.then(deferred.resolve, deferred.reject, deferred.notify);
} replaced with {}
Mutant 769 in q.js: {
  deferred.reject(exception);
} replaced with {}
Mutant 770 in q.js: {
  return Promise({
    "isDef": function () {}
  }, function fallback(op, args) {
    return dispatch(object, op, args);
  }, function () {
    return Q(object).inspect();
  });
} replaced with {}
Mutant 771 in q.js: {
  "isDef": function () {}
} replaced with {}
Mutant 772 in q.js: {
  return dispatch(object, op, args);
} replaced with {}
Mutant 773 in q.js: {
  return Q(object).inspect();
} replaced with {}
Mutant 774 in q.js: {
  return Q(value).spread(fulfilled, rejected);
} replaced with {}
Mutant 775 in q.js: {
  return this.all().then(function (array) {
    return fulfilled.apply(void 0, array);
  }, rejected);
} replaced with {}
Mutant 776 in q.js: {
  return fulfilled.apply(void 0, array);
} replaced with {}
Mutant 777 in q.js: {
  return function () {
    // when verb is "send", arg is a value
    // when verb is "throw", arg is an exception
    function continuer(verb, arg) {
      var result;

      // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
      // engine that has a deployed base of browsers that support generators.
      // However, SM's generators use the Python-inspired semantics of
      // outdated ES6 drafts.  We would like to support ES6, but we'd also
      // like to make it possible to use generators in deployed browsers, so
      // we also support Python-style generators.  At some point we can remove
      // this block.

      if (typeof StopIteration === "undefined") {
        // ES6 Generators
        try {
          result = generator[verb](arg);
        } catch (exception) {
          return reject(exception);
        }
        if (result.done) {
          return Q(result.value);
        } else {
          return when(result.value, callback, errback);
        }
      } else {
        // SpiderMonkey Generators
        // FIXME: Remove this case when SM does ES6 generators.
        try {
          result = generator[verb](arg);
        } catch (exception) {
          if (isStopIteration(exception)) {
            return Q(exception.value);
          } else {
            return reject(exception);
          }
        }
        return when(result, callback, errback);
      }
    }
    var generator = makeGenerator.apply(this, arguments);
    var callback = continuer.bind(continuer, "next");
    var errback = continuer.bind(continuer, "throw");
    return callback();
  };
} replaced with {}
Mutant 778 in q.js: {
  // when verb is "send", arg is a value
  // when verb is "throw", arg is an exception
  function continuer(verb, arg) {
    var result;

    // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
    // engine that has a deployed base of browsers that support generators.
    // However, SM's generators use the Python-inspired semantics of
    // outdated ES6 drafts.  We would like to support ES6, but we'd also
    // like to make it possible to use generators in deployed browsers, so
    // we also support Python-style generators.  At some point we can remove
    // this block.

    if (typeof StopIteration === "undefined") {
      // ES6 Generators
      try {
        result = generator[verb](arg);
      } catch (exception) {
        return reject(exception);
      }
      if (result.done) {
        return Q(result.value);
      } else {
        return when(result.value, callback, errback);
      }
    } else {
      // SpiderMonkey Generators
      // FIXME: Remove this case when SM does ES6 generators.
      try {
        result = generator[verb](arg);
      } catch (exception) {
        if (isStopIteration(exception)) {
          return Q(exception.value);
        } else {
          return reject(exception);
        }
      }
      return when(result, callback, errback);
    }
  }
  var generator = makeGenerator.apply(this, arguments);
  var callback = continuer.bind(continuer, "next");
  var errback = continuer.bind(continuer, "throw");
  return callback();
} replaced with {}
Mutant 779 in q.js: {
  var result;

  // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
  // engine that has a deployed base of browsers that support generators.
  // However, SM's generators use the Python-inspired semantics of
  // outdated ES6 drafts.  We would like to support ES6, but we'd also
  // like to make it possible to use generators in deployed browsers, so
  // we also support Python-style generators.  At some point we can remove
  // this block.

  if (typeof StopIteration === "undefined") {
    // ES6 Generators
    try {
      result = generator[verb](arg);
    } catch (exception) {
      return reject(exception);
    }
    if (result.done) {
      return Q(result.value);
    } else {
      return when(result.value, callback, errback);
    }
  } else {
    // SpiderMonkey Generators
    // FIXME: Remove this case when SM does ES6 generators.
    try {
      result = generator[verb](arg);
    } catch (exception) {
      if (isStopIteration(exception)) {
        return Q(exception.value);
      } else {
        return reject(exception);
      }
    }
    return when(result, callback, errback);
  }
} replaced with {}
Mutant 780 in q.js: typeof StopIteration === "undefined" replaced with true
Mutant 781 in q.js: typeof StopIteration === "undefined" replaced with false
Mutant 782 in q.js: typeof StopIteration === "undefined" replaced with typeof StopIteration !== "undefined"
Mutant 783 in q.js: "undefined" replaced with ""
Mutant 784 in q.js: {
  // ES6 Generators
  try {
    result = generator[verb](arg);
  } catch (exception) {
    return reject(exception);
  }
  if (result.done) {
    return Q(result.value);
  } else {
    return when(result.value, callback, errback);
  }
} replaced with {}
Mutant 785 in q.js: {
  result = generator[verb](arg);
} replaced with {}
Mutant 786 in q.js: {
  return reject(exception);
} replaced with {}
Mutant 787 in q.js: result.done replaced with true
Mutant 788 in q.js: result.done replaced with false
Mutant 789 in q.js: {
  return Q(result.value);
} replaced with {}
Mutant 790 in q.js: {
  return when(result.value, callback, errback);
} replaced with {}
Mutant 791 in q.js: {
  // SpiderMonkey Generators
  // FIXME: Remove this case when SM does ES6 generators.
  try {
    result = generator[verb](arg);
  } catch (exception) {
    if (isStopIteration(exception)) {
      return Q(exception.value);
    } else {
      return reject(exception);
    }
  }
  return when(result, callback, errback);
} replaced with {}
Mutant 792 in q.js: {
  result = generator[verb](arg);
} replaced with {}
Mutant 793 in q.js: {
  if (isStopIteration(exception)) {
    return Q(exception.value);
  } else {
    return reject(exception);
  }
} replaced with {}
Mutant 794 in q.js: isStopIteration(exception) replaced with true
Mutant 795 in q.js: isStopIteration(exception) replaced with false
Mutant 796 in q.js: {
  return Q(exception.value);
} replaced with {}
Mutant 797 in q.js: {
  return reject(exception);
} replaced with {}
Mutant 798 in q.js: "next" replaced with ""
Mutant 799 in q.js: "throw" replaced with ""
Mutant 800 in q.js: {
  Q.done(Q.async(makeGenerator)());
} replaced with {}
Mutant 801 in q.js: "return" replaced with ""
Mutant 802 in q.js: {
  throw new QReturnValue(value);
} replaced with {}
Mutant 803 in q.js: {
  return function () {
    return spread([this, all(arguments)], function (self, args) {
      return callback.apply(self, args);
    });
  };
} replaced with {}
Mutant 804 in q.js: {
  return spread([this, all(arguments)], function (self, args) {
    return callback.apply(self, args);
  });
} replaced with {}
Mutant 805 in q.js: [this, all(arguments)] replaced with []
Mutant 806 in q.js: {
  return callback.apply(self, args);
} replaced with {}
Mutant 807 in q.js: {
  return Q(object).dispatch(op, args);
} replaced with {}
Mutant 808 in q.js: {
  var self = this;
  var deferred = defer();
  Q.nextTick(function () {
    self.promiseDispatch(deferred.resolve, op, args);
  });
  return deferred.promise;
} replaced with {}
Mutant 809 in q.js: {
  self.promiseDispatch(deferred.resolve, op, args);
} replaced with {}
Mutant 810 in q.js: {
  return Q(object).dispatch("get", [key]);
} replaced with {}
Mutant 811 in q.js: "get" replaced with ""
Mutant 812 in q.js: [key] replaced with []
Mutant 813 in q.js: {
  return this.dispatch("get", [key]);
} replaced with {}
Mutant 814 in q.js: "get" replaced with ""
Mutant 815 in q.js: [key] replaced with []
Mutant 816 in q.js: {
  return Q(object).dispatch("set", [key, value]);
} replaced with {}
Mutant 817 in q.js: "set" replaced with ""
Mutant 818 in q.js: [key, value] replaced with []
Mutant 819 in q.js: {
  return this.dispatch("set", [key, value]);
} replaced with {}
Mutant 820 in q.js: "set" replaced with ""
Mutant 821 in q.js: [key, value] replaced with []
Mutant 822 in q.js: "delete" replaced with ""
Mutant 823 in q.js: {
  return Q(object).dispatch("delete", [key]);
} replaced with {}
Mutant 824 in q.js: "delete" replaced with ""
Mutant 825 in q.js: [key] replaced with []
Mutant 826 in q.js: "delete" replaced with ""
Mutant 827 in q.js: {
  return this.dispatch("delete", [key]);
} replaced with {}
Mutant 828 in q.js: "delete" replaced with ""
Mutant 829 in q.js: [key] replaced with []
Mutant 830 in q.js: {
  return Q(object).dispatch("post", [name, args]);
} replaced with {}
Mutant 831 in q.js: "post" replaced with ""
Mutant 832 in q.js: [name, args] replaced with []
Mutant 833 in q.js: {
  return this.dispatch("post", [name, args]);
} replaced with {}
Mutant 834 in q.js: "post" replaced with ""
Mutant 835 in q.js: [name, args] replaced with []
Mutant 836 in q.js: {
  return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
} replaced with {}
Mutant 837 in q.js: "post" replaced with ""
Mutant 838 in q.js: [name, array_slice(arguments, 2)] replaced with []
Mutant 839 in q.js: {
  return this.dispatch("post", [name, array_slice(arguments, 1)]);
} replaced with {}
Mutant 840 in q.js: "post" replaced with ""
Mutant 841 in q.js: [name, array_slice(arguments, 1)] replaced with []
Mutant 842 in q.js: {
  return Q(object).dispatch("apply", [void 0, args]);
} replaced with {}
Mutant 843 in q.js: "apply" replaced with ""
Mutant 844 in q.js: [void 0, args] replaced with []
Mutant 845 in q.js: {
  return this.dispatch("apply", [void 0, args]);
} replaced with {}
Mutant 846 in q.js: "apply" replaced with ""
Mutant 847 in q.js: [void 0, args] replaced with []
Mutant 848 in q.js: "try" replaced with ""
Mutant 849 in q.js: {
  return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
} replaced with {}
Mutant 850 in q.js: "apply" replaced with ""
Mutant 851 in q.js: [void 0, array_slice(arguments, 1)] replaced with []
Mutant 852 in q.js: {
  return this.dispatch("apply", [void 0, array_slice(arguments)]);
} replaced with {}
Mutant 853 in q.js: "apply" replaced with ""
Mutant 854 in q.js: [void 0, array_slice(arguments)] replaced with []
Mutant 855 in q.js: {
  var promise = Q(object);
  var args = array_slice(arguments, 1);
  return function fbound() {
    return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
  };
} replaced with {}
Mutant 856 in q.js: {
  return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
} replaced with {}
Mutant 857 in q.js: "apply" replaced with ""
Mutant 858 in q.js: [this, args.concat(array_slice(arguments))] replaced with []
Mutant 859 in q.js: {
  var promise = this;
  var args = array_slice(arguments);
  return function fbound() {
    return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
  };
} replaced with {}
Mutant 860 in q.js: {
  return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
} replaced with {}
Mutant 861 in q.js: "apply" replaced with ""
Mutant 862 in q.js: [this, args.concat(array_slice(arguments))] replaced with []
Mutant 863 in q.js: {
  return Q(object).dispatch("keys", []);
} replaced with {}
Mutant 864 in q.js: "keys" replaced with ""
Mutant 865 in q.js: [] replaced with ["Stryker was here"]
Mutant 866 in q.js: {
  return this.dispatch("keys", []);
} replaced with {}
Mutant 867 in q.js: "keys" replaced with ""
Mutant 868 in q.js: [] replaced with ["Stryker was here"]
Mutant 869 in q.js: {
  return when(promises, function (promises) {
    var pendingCount = 0;
    var deferred = defer();
    array_reduce(promises, function (undefined, promise, index) {
      var snapshot;
      if (isPromise(promise) && (snapshot = promise.inspect()).state === "fulfilled") {
        promises[index] = snapshot.value;
      } else {
        ++pendingCount;
        when(promise, function (value) {
          promises[index] = value;
          if (--pendingCount === 0) {
            deferred.resolve(promises);
          }
        }, deferred.reject, function (progress) {
          deferred.notify({
            index: index,
            value: progress
          });
        });
      }
    }, void 0);
    if (pendingCount === 0) {
      deferred.resolve(promises);
    }
    return deferred.promise;
  });
} replaced with {}
Mutant 870 in q.js: {
  var pendingCount = 0;
  var deferred = defer();
  array_reduce(promises, function (undefined, promise, index) {
    var snapshot;
    if (isPromise(promise) && (snapshot = promise.inspect()).state === "fulfilled") {
      promises[index] = snapshot.value;
    } else {
      ++pendingCount;
      when(promise, function (value) {
        promises[index] = value;
        if (--pendingCount === 0) {
          deferred.resolve(promises);
        }
      }, deferred.reject, function (progress) {
        deferred.notify({
          index: index,
          value: progress
        });
      });
    }
  }, void 0);
  if (pendingCount === 0) {
    deferred.resolve(promises);
  }
  return deferred.promise;
} replaced with {}
Mutant 871 in q.js: {
  var snapshot;
  if (isPromise(promise) && (snapshot = promise.inspect()).state === "fulfilled") {
    promises[index] = snapshot.value;
  } else {
    ++pendingCount;
    when(promise, function (value) {
      promises[index] = value;
      if (--pendingCount === 0) {
        deferred.resolve(promises);
      }
    }, deferred.reject, function (progress) {
      deferred.notify({
        index: index,
        value: progress
      });
    });
  }
} replaced with {}
Mutant 872 in q.js: isPromise(promise) && (snapshot = promise.inspect()).state === "fulfilled" replaced with true
Mutant 873 in q.js: isPromise(promise) && (snapshot = promise.inspect()).state === "fulfilled" replaced with false
Mutant 874 in q.js: isPromise(promise) && (snapshot = promise.inspect()).state === "fulfilled" replaced with isPromise(promise) || (snapshot = promise.inspect()).state === "fulfilled"
Mutant 875 in q.js: (snapshot = promise.inspect()).state === "fulfilled" replaced with true
Mutant 876 in q.js: (snapshot = promise.inspect()).state === "fulfilled" replaced with (snapshot = promise.inspect()).state !== "fulfilled"
Mutant 877 in q.js: "fulfilled" replaced with ""
Mutant 878 in q.js: {
  promises[index] = snapshot.value;
} replaced with {}
Mutant 879 in q.js: {
  ++pendingCount;
  when(promise, function (value) {
    promises[index] = value;
    if (--pendingCount === 0) {
      deferred.resolve(promises);
    }
  }, deferred.reject, function (progress) {
    deferred.notify({
      index: index,
      value: progress
    });
  });
} replaced with {}
Mutant 880 in q.js: ++pendingCount replaced with --pendingCount
Mutant 881 in q.js: {
  promises[index] = value;
  if (--pendingCount === 0) {
    deferred.resolve(promises);
  }
} replaced with {}
Mutant 882 in q.js: --pendingCount === 0 replaced with true
Mutant 883 in q.js: --pendingCount === 0 replaced with false
Mutant 884 in q.js: --pendingCount === 0 replaced with --pendingCount !== 0
Mutant 885 in q.js: --pendingCount replaced with ++pendingCount
Mutant 886 in q.js: {
  deferred.resolve(promises);
} replaced with {}
Mutant 887 in q.js: {
  deferred.notify({
    index: index,
    value: progress
  });
} replaced with {}
Mutant 888 in q.js: {
  index: index,
  value: progress
} replaced with {}
Mutant 889 in q.js: pendingCount === 0 replaced with true
Mutant 890 in q.js: pendingCount === 0 replaced with false
Mutant 891 in q.js: pendingCount === 0 replaced with pendingCount !== 0
Mutant 892 in q.js: {
  deferred.resolve(promises);
} replaced with {}
Mutant 893 in q.js: {
  return all(this);
} replaced with {}
Mutant 894 in q.js: {
  if (promises.length === 0) {
    return Q.resolve();
  }
  var deferred = Q.defer();
  var pendingCount = 0;
  array_reduce(promises, function (prev, current, index) {
    var promise = promises[index];
    pendingCount++;
    when(promise, onFulfilled, onRejected, onProgress);
    function onFulfilled(result) {
      deferred.resolve(result);
    }
    function onRejected(err) {
      pendingCount--;
      if (pendingCount === 0) {
        var rejection = err || new Error("" + err);
        rejection.message = "Q can't get fulfillment value from any promise, all " + "promises were rejected. Last error message: " + rejection.message;
        deferred.reject(rejection);
      }
    }
    function onProgress(progress) {
      deferred.notify({
        index: index,
        value: progress
      });
    }
  }, undefined);
  return deferred.promise;
} replaced with {}
Mutant 895 in q.js: promises.length === 0 replaced with true
Mutant 896 in q.js: promises.length === 0 replaced with false
Mutant 897 in q.js: promises.length === 0 replaced with promises.length !== 0
Mutant 898 in q.js: {
  return Q.resolve();
} replaced with {}
Mutant 899 in q.js: {
  var promise = promises[index];
  pendingCount++;
  when(promise, onFulfilled, onRejected, onProgress);
  function onFulfilled(result) {
    deferred.resolve(result);
  }
  function onRejected(err) {
    pendingCount--;
    if (pendingCount === 0) {
      var rejection = err || new Error("" + err);
      rejection.message = "Q can't get fulfillment value from any promise, all " + "promises were rejected. Last error message: " + rejection.message;
      deferred.reject(rejection);
    }
  }
  function onProgress(progress) {
    deferred.notify({
      index: index,
      value: progress
    });
  }
} replaced with {}
Mutant 900 in q.js: pendingCount++ replaced with pendingCount--
Mutant 901 in q.js: {
  deferred.resolve(result);
} replaced with {}
Mutant 902 in q.js: {
  pendingCount--;
  if (pendingCount === 0) {
    var rejection = err || new Error("" + err);
    rejection.message = "Q can't get fulfillment value from any promise, all " + "promises were rejected. Last error message: " + rejection.message;
    deferred.reject(rejection);
  }
} replaced with {}
Mutant 903 in q.js: pendingCount-- replaced with pendingCount++
Mutant 904 in q.js: pendingCount === 0 replaced with true
Mutant 905 in q.js: pendingCount === 0 replaced with false
Mutant 906 in q.js: pendingCount === 0 replaced with pendingCount !== 0
Mutant 907 in q.js: {
  var rejection = err || new Error("" + err);
  rejection.message = "Q can't get fulfillment value from any promise, all " + "promises were rejected. Last error message: " + rejection.message;
  deferred.reject(rejection);
} replaced with {}
Mutant 908 in q.js: err || new Error("" + err) replaced with true
Mutant 909 in q.js: err || new Error("" + err) replaced with false
Mutant 910 in q.js: err || new Error("" + err) replaced with err && new Error("" + err)
Mutant 911 in q.js: "" replaced with "Stryker was here!"
Mutant 912 in q.js: "Q can't get fulfillment value from any promise, all " replaced with ""
Mutant 913 in q.js: "promises were rejected. Last error message: " replaced with ""
Mutant 914 in q.js: {
  deferred.notify({
    index: index,
    value: progress
  });
} replaced with {}
Mutant 915 in q.js: {
  index: index,
  value: progress
} replaced with {}
Mutant 916 in q.js: {
  return any(this);
} replaced with {}
Mutant 917 in q.js: "allResolved" replaced with ""
Mutant 918 in q.js: "allSettled" replaced with ""
Mutant 919 in q.js: {
  return when(promises, function (promises) {
    promises = array_map(promises, Q);
    return when(all(array_map(promises, function (promise) {
      return when(promise, noop, noop);
    })), function () {
      return promises;
    });
  });
} replaced with {}
Mutant 920 in q.js: {
  promises = array_map(promises, Q);
  return when(all(array_map(promises, function (promise) {
    return when(promise, noop, noop);
  })), function () {
    return promises;
  });
} replaced with {}
Mutant 921 in q.js: {
  return when(promise, noop, noop);
} replaced with {}
Mutant 922 in q.js: {
  return promises;
} replaced with {}
Mutant 923 in q.js: {
  return allResolved(this);
} replaced with {}
Mutant 924 in q.js: {
  return Q(promises).allSettled();
} replaced with {}
Mutant 925 in q.js: {
  return this.then(function (promises) {
    return all(array_map(promises, function (promise) {
      promise = Q(promise);
      function regardless() {
        return promise.inspect();
      }
      return promise.then(regardless, regardless);
    }));
  });
} replaced with {}
Mutant 926 in q.js: {
  return all(array_map(promises, function (promise) {
    promise = Q(promise);
    function regardless() {
      return promise.inspect();
    }
    return promise.then(regardless, regardless);
  }));
} replaced with {}
Mutant 927 in q.js: {
  promise = Q(promise);
  function regardless() {
    return promise.inspect();
  }
  return promise.then(regardless, regardless);
} replaced with {}
Mutant 928 in q.js: {
  return promise.inspect();
} replaced with {}
Mutant 929 in q.js: "catch" replaced with ""
Mutant 930 in q.js: {
  return Q(object).then(void 0, rejected);
} replaced with {}
Mutant 931 in q.js: "catch" replaced with ""
Mutant 932 in q.js: {
  return this.then(void 0, rejected);
} replaced with {}
Mutant 933 in q.js: {
  return Q(object).then(void 0, void 0, progressed);
} replaced with {}
Mutant 934 in q.js: {
  return this.then(void 0, void 0, progressed);
} replaced with {}
Mutant 935 in q.js: "finally" replaced with ""
Mutant 936 in q.js: {
  return Q(object)["finally"](callback);
} replaced with {}
Mutant 937 in q.js: "finally" replaced with ""
Mutant 938 in q.js: "finally" replaced with ""
Mutant 939 in q.js: {
  if (!callback || typeof callback.apply !== "function") {
    throw new Error("Q can't apply finally callback");
  }
  callback = Q(callback);
  return this.then(function (value) {
    return callback.fcall().then(function () {
      return value;
    });
  }, function (reason) {
    // TODO attempt to recycle the rejection with "this".
    return callback.fcall().then(function () {
      throw reason;
    });
  });
} replaced with {}
Mutant 940 in q.js: !callback || typeof callback.apply !== "function" replaced with true
Mutant 941 in q.js: !callback || typeof callback.apply !== "function" replaced with false
Mutant 942 in q.js: !callback || typeof callback.apply !== "function" replaced with !callback && typeof callback.apply !== "function"
Mutant 943 in q.js: !callback replaced with callback
Mutant 944 in q.js: typeof callback.apply !== "function" replaced with false
Mutant 945 in q.js: typeof callback.apply !== "function" replaced with typeof callback.apply === "function"
Mutant 946 in q.js: "function" replaced with ""
Mutant 947 in q.js: {
  throw new Error("Q can't apply finally callback");
} replaced with {}
Mutant 948 in q.js: "Q can't apply finally callback" replaced with ""
Mutant 949 in q.js: {
  return callback.fcall().then(function () {
    return value;
  });
} replaced with {}
Mutant 950 in q.js: {
  return value;
} replaced with {}
Mutant 951 in q.js: {
  // TODO attempt to recycle the rejection with "this".
  return callback.fcall().then(function () {
    throw reason;
  });
} replaced with {}
Mutant 952 in q.js: {
  throw reason;
} replaced with {}
Mutant 953 in q.js: {
  return Q(object).done(fulfilled, rejected, progress);
} replaced with {}
Mutant 954 in q.js: {
  var onUnhandledError = function (error) {
    // forward to a future turn so that ``when``
    // does not catch it and turn it into a rejection.
    Q.nextTick(function () {
      makeStackTraceLong(error, promise);
      if (Q.onerror) {
        Q.onerror(error);
      } else {
        throw error;
      }
    });
  };

  // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
  var promise = fulfilled || rejected || progress ? this.then(fulfilled, rejected, progress) : this;
  if (typeof process === "object" && process && process.domain) {
    onUnhandledError = process.domain.bind(onUnhandledError);
  }
  promise.then(void 0, onUnhandledError);
} replaced with {}
Mutant 955 in q.js: {
  // forward to a future turn so that ``when``
  // does not catch it and turn it into a rejection.
  Q.nextTick(function () {
    makeStackTraceLong(error, promise);
    if (Q.onerror) {
      Q.onerror(error);
    } else {
      throw error;
    }
  });
} replaced with {}
Mutant 956 in q.js: {
  makeStackTraceLong(error, promise);
  if (Q.onerror) {
    Q.onerror(error);
  } else {
    throw error;
  }
} replaced with {}
Mutant 957 in q.js: Q.onerror replaced with true
Mutant 958 in q.js: Q.onerror replaced with false
Mutant 959 in q.js: {
  Q.onerror(error);
} replaced with {}
Mutant 960 in q.js: {
  throw error;
} replaced with {}
Mutant 961 in q.js: fulfilled || rejected || progress replaced with true
Mutant 962 in q.js: fulfilled || rejected || progress replaced with false
Mutant 963 in q.js: fulfilled || rejected || progress replaced with (fulfilled || rejected) && progress
Mutant 964 in q.js: fulfilled || rejected replaced with false
Mutant 965 in q.js: fulfilled || rejected replaced with fulfilled && rejected
Mutant 966 in q.js: typeof process === "object" && process && process.domain replaced with true
Mutant 967 in q.js: typeof process === "object" && process && process.domain replaced with false
Mutant 968 in q.js: typeof process === "object" && process && process.domain replaced with typeof process === "object" && process || process.domain
Mutant 969 in q.js: typeof process === "object" && process replaced with true
Mutant 970 in q.js: typeof process === "object" && process replaced with typeof process === "object" || process
Mutant 971 in q.js: typeof process === "object" replaced with true
Mutant 972 in q.js: typeof process === "object" replaced with typeof process !== "object"
Mutant 973 in q.js: "object" replaced with ""
Mutant 974 in q.js: {
  onUnhandledError = process.domain.bind(onUnhandledError);
} replaced with {}
Mutant 975 in q.js: {
  return Q(object).timeout(ms, error);
} replaced with {}
Mutant 976 in q.js: {
  var deferred = defer();
  var timeoutId = setTimeout(function () {
    if (!error || "string" === typeof error) {
      error = new Error(error || "Timed out after " + ms + " ms");
      error.code = "ETIMEDOUT";
    }
    deferred.reject(error);
  }, ms);
  this.then(function (value) {
    clearTimeout(timeoutId);
    deferred.resolve(value);
  }, function (exception) {
    clearTimeout(timeoutId);
    deferred.reject(exception);
  }, deferred.notify);
  return deferred.promise;
} replaced with {}
Mutant 977 in q.js: {
  if (!error || "string" === typeof error) {
    error = new Error(error || "Timed out after " + ms + " ms");
    error.code = "ETIMEDOUT";
  }
  deferred.reject(error);
} replaced with {}
Mutant 978 in q.js: !error || "string" === typeof error replaced with true
Mutant 979 in q.js: !error || "string" === typeof error replaced with false
Mutant 980 in q.js: !error || "string" === typeof error replaced with !error && "string" === typeof error
Mutant 981 in q.js: !error replaced with error
Mutant 982 in q.js: "string" === typeof error replaced with false
Mutant 983 in q.js: "string" === typeof error replaced with "string" !== typeof error
Mutant 984 in q.js: "string" replaced with ""
Mutant 985 in q.js: {
  error = new Error(error || "Timed out after " + ms + " ms");
  error.code = "ETIMEDOUT";
} replaced with {}
Mutant 986 in q.js: error || "Timed out after " + ms + " ms" replaced with true
Mutant 987 in q.js: error || "Timed out after " + ms + " ms" replaced with false
Mutant 988 in q.js: error || "Timed out after " + ms + " ms" replaced with error && "Timed out after " + ms + " ms"
Mutant 989 in q.js: "Timed out after " replaced with ""
Mutant 990 in q.js: " ms" replaced with ""
Mutant 991 in q.js: "ETIMEDOUT" replaced with ""
Mutant 992 in q.js: {
  clearTimeout(timeoutId);
  deferred.resolve(value);
} replaced with {}
Mutant 993 in q.js: {
  clearTimeout(timeoutId);
  deferred.reject(exception);
} replaced with {}
Mutant 994 in q.js: {
  if (timeout === void 0) {
    timeout = object;
    object = void 0;
  }
  return Q(object).delay(timeout);
} replaced with {}
Mutant 995 in q.js: timeout === void 0 replaced with true
Mutant 996 in q.js: timeout === void 0 replaced with false
Mutant 997 in q.js: timeout === void 0 replaced with timeout !== void 0
Mutant 998 in q.js: {
  timeout = object;
  object = void 0;
} replaced with {}
Mutant 999 in q.js: {
  return this.then(function (value) {
    var deferred = defer();
    setTimeout(function () {
      deferred.resolve(value);
    }, timeout);
    return deferred.promise;
  });
} replaced with {}
Mutant 1000 in q.js: {
  var deferred = defer();
  setTimeout(function () {
    deferred.resolve(value);
  }, timeout);
  return deferred.promise;
} replaced with {}
Mutant 1001 in q.js: {
  deferred.resolve(value);
} replaced with {}
Mutant 1002 in q.js: {
  return Q(callback).nfapply(args);
} replaced with {}
Mutant 1003 in q.js: {
  var deferred = defer();
  var nodeArgs = array_slice(args);
  nodeArgs.push(deferred.makeNodeResolver());
  this.fapply(nodeArgs).fail(deferred.reject);
  return deferred.promise;
} replaced with {}
Mutant 1004 in q.js: {
  var args = array_slice(arguments, 1);
  return Q(callback).nfapply(args);
} replaced with {}
Mutant 1005 in q.js: {
  var nodeArgs = array_slice(arguments);
  var deferred = defer();
  nodeArgs.push(deferred.makeNodeResolver());
  this.fapply(nodeArgs).fail(deferred.reject);
  return deferred.promise;
} replaced with {}
Mutant 1006 in q.js: {
  if (callback === undefined) {
    throw new Error("Q can't wrap an undefined function");
  }
  var baseArgs = array_slice(arguments, 1);
  return function () {
    var nodeArgs = baseArgs.concat(array_slice(arguments));
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(callback).fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
  };
} replaced with {}
Mutant 1007 in q.js: callback === undefined replaced with true
Mutant 1008 in q.js: callback === undefined replaced with false
Mutant 1009 in q.js: callback === undefined replaced with callback !== undefined
Mutant 1010 in q.js: {
  throw new Error("Q can't wrap an undefined function");
} replaced with {}
Mutant 1011 in q.js: "Q can't wrap an undefined function" replaced with ""
Mutant 1012 in q.js: {
  var nodeArgs = baseArgs.concat(array_slice(arguments));
  var deferred = defer();
  nodeArgs.push(deferred.makeNodeResolver());
  Q(callback).fapply(nodeArgs).fail(deferred.reject);
  return deferred.promise;
} replaced with {}
Mutant 1013 in q.js: {
  var args = array_slice(arguments);
  args.unshift(this);
  return Q.denodeify.apply(void 0, args);
} replaced with {}
Mutant 1014 in q.js: {
  var baseArgs = array_slice(arguments, 2);
  return function () {
    var nodeArgs = baseArgs.concat(array_slice(arguments));
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    function bound() {
      return callback.apply(thisp, arguments);
    }
    Q(bound).fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
  };
} replaced with {}
Mutant 1015 in q.js: {
  var nodeArgs = baseArgs.concat(array_slice(arguments));
  var deferred = defer();
  nodeArgs.push(deferred.makeNodeResolver());
  function bound() {
    return callback.apply(thisp, arguments);
  }
  Q(bound).fapply(nodeArgs).fail(deferred.reject);
  return deferred.promise;
} replaced with {}
Mutant 1016 in q.js: {
  return callback.apply(thisp, arguments);
} replaced with {}
Mutant 1017 in q.js: {
  var args = array_slice(arguments, 0);
  args.unshift(this);
  return Q.nbind.apply(void 0, args);
} replaced with {}
Mutant 1018 in q.js: {
  return Q(object).npost(name, args);
} replaced with {}
Mutant 1019 in q.js: {
  var nodeArgs = array_slice(args || []);
  var deferred = defer();
  nodeArgs.push(deferred.makeNodeResolver());
  this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
  return deferred.promise;
} replaced with {}
Mutant 1020 in q.js: args || [] replaced with true
Mutant 1021 in q.js: args || [] replaced with false
Mutant 1022 in q.js: args || [] replaced with args && []
Mutant 1023 in q.js: [] replaced with ["Stryker was here"]
Mutant 1024 in q.js: "post" replaced with ""
Mutant 1025 in q.js: [name, nodeArgs] replaced with []
Mutant 1026 in q.js: {
  var nodeArgs = array_slice(arguments, 2);
  var deferred = defer();
  nodeArgs.push(deferred.makeNodeResolver());
  Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
  return deferred.promise;
} replaced with {}
Mutant 1027 in q.js: "post" replaced with ""
Mutant 1028 in q.js: [name, nodeArgs] replaced with []
Mutant 1029 in q.js: {
  var nodeArgs = array_slice(arguments, 1);
  var deferred = defer();
  nodeArgs.push(deferred.makeNodeResolver());
  this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
  return deferred.promise;
} replaced with {}
Mutant 1030 in q.js: "post" replaced with ""
Mutant 1031 in q.js: [name, nodeArgs] replaced with []
Mutant 1032 in q.js: {
  return Q(object).nodeify(nodeback);
} replaced with {}
Mutant 1033 in q.js: {
  if (nodeback) {
    this.then(function (value) {
      Q.nextTick(function () {
        nodeback(null, value);
      });
    }, function (error) {
      Q.nextTick(function () {
        nodeback(error);
      });
    });
  } else {
    return this;
  }
} replaced with {}
Mutant 1034 in q.js: nodeback replaced with true
Mutant 1035 in q.js: nodeback replaced with false
Mutant 1036 in q.js: {
  this.then(function (value) {
    Q.nextTick(function () {
      nodeback(null, value);
    });
  }, function (error) {
    Q.nextTick(function () {
      nodeback(error);
    });
  });
} replaced with {}
Mutant 1037 in q.js: {
  Q.nextTick(function () {
    nodeback(null, value);
  });
} replaced with {}
Mutant 1038 in q.js: {
  nodeback(null, value);
} replaced with {}
Mutant 1039 in q.js: {
  Q.nextTick(function () {
    nodeback(error);
  });
} replaced with {}
Mutant 1040 in q.js: {
  nodeback(error);
} replaced with {}
Mutant 1041 in q.js: {
  return this;
} replaced with {}
Mutant 1042 in q.js: {
  throw new Error("Q.noConflict only works when Q is used as a global");
} replaced with {}
Mutant 1043 in q.js: "Q.noConflict only works when Q is used as a global" replaced with ""
Mutant 1044 in queue.js: {
  var ends = Q.defer();
  var closed = Q.defer();
  return {
    put: function (value) {
      var next = Q.defer();
      ends.resolve({
        head: value,
        tail: next.promise
      });
      ends.resolve = next.resolve;
    },
    get: function () {
      var result = ends.promise.get("head");
      ends.promise = ends.promise.get("tail");
      return result.fail(function (error) {
        closed.resolve(error);
        throw error;
      });
    },
    closed: closed.promise,
    close: function (error) {
      error = error || new Error("Can't get value from closed queue");
      var end = {
        head: Q.reject(error)
      };
      end.tail = end;
      ends.resolve(end);
      return closed.promise;
    }
  };
} replaced with {}
Mutant 1045 in queue.js: {
  put: function (value) {
    var next = Q.defer();
    ends.resolve({
      head: value,
      tail: next.promise
    });
    ends.resolve = next.resolve;
  },
  get: function () {
    var result = ends.promise.get("head");
    ends.promise = ends.promise.get("tail");
    return result.fail(function (error) {
      closed.resolve(error);
      throw error;
    });
  },
  closed: closed.promise,
  close: function (error) {
    error = error || new Error("Can't get value from closed queue");
    var end = {
      head: Q.reject(error)
    };
    end.tail = end;
    ends.resolve(end);
    return closed.promise;
  }
} replaced with {}
Mutant 1046 in queue.js: {
  var next = Q.defer();
  ends.resolve({
    head: value,
    tail: next.promise
  });
  ends.resolve = next.resolve;
} replaced with {}
Mutant 1047 in queue.js: {
  head: value,
  tail: next.promise
} replaced with {}
Mutant 1048 in queue.js: {
  var result = ends.promise.get("head");
  ends.promise = ends.promise.get("tail");
  return result.fail(function (error) {
    closed.resolve(error);
    throw error;
  });
} replaced with {}
Mutant 1049 in queue.js: "head" replaced with ""
Mutant 1050 in queue.js: "tail" replaced with ""
Mutant 1051 in queue.js: {
  closed.resolve(error);
  throw error;
} replaced with {}
Mutant 1052 in queue.js: {
  error = error || new Error("Can't get value from closed queue");
  var end = {
    head: Q.reject(error)
  };
  end.tail = end;
  ends.resolve(end);
  return closed.promise;
} replaced with {}
Mutant 1053 in queue.js: error || new Error("Can't get value from closed queue") replaced with true
Mutant 1054 in queue.js: error || new Error("Can't get value from closed queue") replaced with false
Mutant 1055 in queue.js: error || new Error("Can't get value from closed queue") replaced with error && new Error("Can't get value from closed queue")
Mutant 1056 in queue.js: "Can't get value from closed queue" replaced with ""
Mutant 1057 in queue.js: {
  head: Q.reject(error)
} replaced with {}
[32m13:06:00 (2224) INFO Instrumenter[39m Instrumented 2 source file(s) with 1058 mutant(s)
[32m13:06:00 (2224) INFO ConcurrencyTokenProvider[39m Creating 1 test runner process(es).
[32m13:06:01 (2224) INFO BroadcastReporter[39m Detected that current console does not support the "progress" reporter, downgrading to "progress-append-only" reporter
[32m13:06:01 (2224) INFO DryRunExecutor[39m Starting initial test run (command test runner with "perTest" coverage analysis). This may take a while.
[32m13:06:08 (2224) INFO DryRunExecutor[39m Initial test run succeeded. Ran 1 tests in 6 seconds (net 6806 ms, overhead 0 ms).
Mutation testing 0% (elapsed: <1m, remaining: ~43m) 4/1058 tested (1 survived, 0 timed out)
Mutation testing 0% (elapsed: <1m, remaining: ~1h 10m) 5/1058 tested (2 survived, 0 timed out)
Mutation testing 0% (elapsed: <1m, remaining: ~1h 27m) 6/1058 tested (3 survived, 0 timed out)
Mutation testing 0% (elapsed: <1m, remaining: ~1h 17m) 9/1058 tested (5 survived, 0 timed out)
Mutation testing 0% (elapsed: <1m, remaining: ~1h 27m) 10/1058 tested (6 survived, 0 timed out)
Mutation testing 1% (elapsed: ~1m, remaining: ~1h 20m) 13/1058 tested (7 survived, 0 timed out)
Mutation testing 1% (elapsed: ~1m, remaining: ~1h 11m) 17/1058 tested (8 survived, 0 timed out)
Mutation testing 1% (elapsed: ~1m, remaining: ~1h 12m) 19/1058 tested (10 survived, 0 timed out)
Mutation testing 1% (elapsed: ~1m, remaining: ~1h 17m) 20/1058 tested (11 survived, 0 timed out)
Mutation testing 2% (elapsed: ~1m, remaining: ~1h 18m) 22/1058 tested (13 survived, 0 timed out)
Mutation testing 2% (elapsed: ~1m, remaining: ~1h 22m) 23/1058 tested (14 survived, 0 timed out)
Mutation testing 2% (elapsed: ~2m, remaining: ~1h 22m) 25/1058 tested (16 survived, 0 timed out)
Mutation testing 2% (elapsed: ~2m, remaining: ~1h 26m) 26/1058 tested (17 survived, 0 timed out)
Mutation testing 2% (elapsed: ~2m, remaining: ~1h 25m) 28/1058 tested (19 survived, 0 timed out)
Mutation testing 2% (elapsed: ~2m, remaining: ~1h 28m) 29/1058 tested (20 survived, 0 timed out)
Mutation testing 2% (elapsed: ~2m, remaining: ~1h 28m) 31/1058 tested (22 survived, 0 timed out)
Mutation testing 3% (elapsed: ~2m, remaining: ~1h 30m) 32/1058 tested (23 survived, 0 timed out)
Mutation testing 3% (elapsed: ~3m, remaining: ~1h 30m) 34/1058 tested (25 survived, 0 timed out)
Mutation testing 3% (elapsed: ~3m, remaining: ~1h 32m) 35/1058 tested (26 survived, 0 timed out)
Mutation testing 3% (elapsed: ~3m, remaining: ~1h 31m) 37/1058 tested (28 survived, 0 timed out)
Mutation testing 3% (elapsed: ~3m, remaining: ~1h 33m) 38/1058 tested (29 survived, 0 timed out)
Mutation testing 3% (elapsed: ~3m, remaining: ~1h 33m) 40/1058 tested (31 survived, 0 timed out)
Mutation testing 3% (elapsed: ~3m, remaining: ~1h 35m) 41/1058 tested (32 survived, 0 timed out)
Mutation testing 4% (elapsed: ~4m, remaining: ~1h 34m) 43/1058 tested (34 survived, 0 timed out)
Mutation testing 4% (elapsed: ~4m, remaining: ~1h 36m) 44/1058 tested (35 survived, 0 timed out)
Mutation testing 4% (elapsed: ~4m, remaining: ~1h 35m) 46/1058 tested (37 survived, 0 timed out)
Mutation testing 4% (elapsed: ~4m, remaining: ~1h 36m) 47/1058 tested (38 survived, 0 timed out)
Mutation testing 4% (elapsed: ~4m, remaining: ~1h 36m) 49/1058 tested (40 survived, 0 timed out)
Mutation testing 4% (elapsed: ~4m, remaining: ~1h 37m) 50/1058 tested (41 survived, 0 timed out)
Mutation testing 4% (elapsed: ~5m, remaining: ~1h 36m) 52/1058 tested (42 survived, 0 timed out)
Mutation testing 5% (elapsed: ~5m, remaining: ~1h 36m) 54/1058 tested (44 survived, 0 timed out)
Mutation testing 5% (elapsed: ~5m, remaining: ~1h 37m) 55/1058 tested (45 survived, 0 timed out)
Mutation testing 5% (elapsed: ~5m, remaining: ~1h 34m) 58/1058 tested (47 survived, 0 timed out)
Mutation testing 5% (elapsed: ~5m, remaining: ~1h 35m) 59/1058 tested (48 survived, 0 timed out)
Mutation testing 5% (elapsed: ~5m, remaining: ~1h 38m) 59/1058 tested (48 survived, 0 timed out)
Mutation testing 5% (elapsed: ~6m, remaining: ~1h 38m) 61/1058 tested (49 survived, 1 timed out)
Mutation testing 5% (elapsed: ~6m, remaining: ~1h 39m) 62/1058 tested (50 survived, 1 timed out)
Mutation testing 5% (elapsed: ~6m, remaining: ~1h 40m) 63/1058 tested (50 survived, 2 timed out)
Mutation testing 5% (elapsed: ~6m, remaining: ~1h 42m) 63/1058 tested (50 survived, 2 timed out)
Mutation testing 6% (elapsed: ~6m, remaining: ~1h 43m) 64/1058 tested (50 survived, 3 timed out)
Mutation testing 6% (elapsed: ~6m, remaining: ~1h 46m) 64/1058 tested (50 survived, 3 timed out)
Mutation testing 6% (elapsed: ~7m, remaining: ~1h 46m) 65/1058 tested (50 survived, 4 timed out)
Mutation testing 6% (elapsed: ~7m, remaining: ~1h 47m) 66/1058 tested (50 survived, 5 timed out)
Mutation testing 6% (elapsed: ~7m, remaining: ~1h 46m) 68/1058 tested (52 survived, 5 timed out)
Mutation testing 6% (elapsed: ~7m, remaining: ~1h 47m) 69/1058 tested (53 survived, 5 timed out)
Mutation testing 6% (elapsed: ~7m, remaining: ~1h 49m) 69/1058 tested (53 survived, 5 timed out)
Mutation testing 6% (elapsed: ~7m, remaining: ~1h 50m) 70/1058 tested (53 survived, 6 timed out)
Mutation testing 6% (elapsed: ~8m, remaining: ~1h 51m) 71/1058 tested (53 survived, 7 timed out)
Mutation testing 6% (elapsed: ~8m, remaining: ~1h 53m) 71/1058 tested (53 survived, 7 timed out)
Mutation testing 6% (elapsed: ~8m, remaining: ~1h 54m) 72/1058 tested (53 survived, 8 timed out)
Mutation testing 6% (elapsed: ~8m, remaining: ~1h 54m) 73/1058 tested (53 survived, 9 timed out)
Mutation testing 6% (elapsed: ~8m, remaining: ~1h 55m) 74/1058 tested (54 survived, 9 timed out)
Mutation testing 7% (elapsed: ~8m, remaining: ~1h 54m) 76/1058 tested (56 survived, 9 timed out)
Mutation testing 7% (elapsed: ~9m, remaining: ~1h 54m) 77/1058 tested (57 survived, 9 timed out)
Mutation testing 7% (elapsed: ~9m, remaining: ~1h 53m) 79/1058 tested (59 survived, 9 timed out)
Mutation testing 7% (elapsed: ~9m, remaining: ~1h 54m) 80/1058 tested (60 survived, 9 timed out)
Mutation testing 7% (elapsed: ~9m, remaining: ~1h 53m) 82/1058 tested (62 survived, 9 timed out)
Mutation testing 7% (elapsed: ~9m, remaining: ~1h 53m) 83/1058 tested (63 survived, 9 timed out)
Mutation testing 8% (elapsed: ~9m, remaining: ~1h 52m) 85/1058 tested (65 survived, 9 timed out)
Mutation testing 8% (elapsed: ~10m, remaining: ~1h 54m) 85/1058 tested (65 survived, 9 timed out)
Mutation testing 8% (elapsed: ~10m, remaining: ~1h 53m) 87/1058 tested (66 survived, 10 timed out)
Mutation testing 8% (elapsed: ~10m, remaining: ~1h 53m) 88/1058 tested (67 survived, 10 timed out)
Mutation testing 8% (elapsed: ~10m, remaining: ~1h 55m) 88/1058 tested (67 survived, 10 timed out)
Mutation testing 8% (elapsed: ~10m, remaining: ~1h 54m) 90/1058 tested (67 survived, 11 timed out)
Mutation testing 8% (elapsed: ~10m, remaining: ~1h 55m) 91/1058 tested (67 survived, 12 timed out)
Mutation testing 8% (elapsed: ~11m, remaining: ~1h 55m) 92/1058 tested (68 survived, 12 timed out)
Mutation testing 8% (elapsed: ~11m, remaining: ~1h 57m) 92/1058 tested (68 survived, 12 timed out)
Mutation testing 8% (elapsed: ~11m, remaining: ~1h 57m) 93/1058 tested (68 survived, 13 timed out)
Mutation testing 8% (elapsed: ~11m, remaining: ~1h 57m) 94/1058 tested (68 survived, 14 timed out)
Mutation testing 8% (elapsed: ~11m, remaining: ~1h 58m) 95/1058 tested (69 survived, 14 timed out)
Mutation testing 9% (elapsed: ~11m, remaining: ~1h 58m) 96/1058 tested (69 survived, 15 timed out)
Mutation testing 9% (elapsed: ~12m, remaining: ~2h 0m) 96/1058 tested (69 survived, 15 timed out)
Mutation testing 9% (elapsed: ~12m, remaining: ~1h 59m) 98/1058 tested (70 survived, 16 timed out)
Mutation testing 9% (elapsed: ~12m, remaining: ~1h 59m) 99/1058 tested (71 survived, 16 timed out)
Mutation testing 9% (elapsed: ~12m, remaining: ~1h 59m) 100/1058 tested (72 survived, 16 timed out)
Mutation testing 9% (elapsed: ~12m, remaining: ~1h 58m) 102/1058 tested (74 survived, 16 timed out)
Mutation testing 9% (elapsed: ~12m, remaining: ~1h 58m) 103/1058 tested (75 survived, 16 timed out)
Mutation testing 9% (elapsed: ~13m, remaining: ~1h 57m) 105/1058 tested (77 survived, 16 timed out)
Mutation testing 10% (elapsed: ~13m, remaining: ~1h 58m) 106/1058 tested (78 survived, 16 timed out)
Mutation testing 10% (elapsed: ~13m, remaining: ~1h 57m) 108/1058 tested (80 survived, 16 timed out)
Mutation testing 10% (elapsed: ~13m, remaining: ~1h 56m) 110/1058 tested (81 survived, 16 timed out)
Mutation testing 10% (elapsed: ~13m, remaining: ~1h 56m) 111/1058 tested (82 survived, 16 timed out)
Mutation testing 10% (elapsed: ~13m, remaining: ~1h 56m) 112/1058 tested (82 survived, 17 timed out)
Mutation testing 10% (elapsed: ~14m, remaining: ~1h 57m) 113/1058 tested (83 survived, 17 timed out)
Mutation testing 10% (elapsed: ~14m, remaining: ~1h 56m) 115/1058 tested (85 survived, 17 timed out)
Mutation testing 10% (elapsed: ~14m, remaining: ~1h 56m) 116/1058 tested (86 survived, 17 timed out)
Mutation testing 11% (elapsed: ~14m, remaining: ~1h 55m) 118/1058 tested (88 survived, 17 timed out)
Mutation testing 11% (elapsed: ~14m, remaining: ~1h 55m) 119/1058 tested (89 survived, 17 timed out)
Mutation testing 11% (elapsed: ~14m, remaining: ~1h 54m) 121/1058 tested (91 survived, 17 timed out)
Mutation testing 11% (elapsed: ~15m, remaining: ~1h 55m) 122/1058 tested (92 survived, 17 timed out)
Mutation testing 11% (elapsed: ~15m, remaining: ~1h 54m) 124/1058 tested (94 survived, 17 timed out)
Mutation testing 11% (elapsed: ~15m, remaining: ~1h 54m) 125/1058 tested (95 survived, 17 timed out)
Mutation testing 12% (elapsed: ~15m, remaining: ~1h 53m) 127/1058 tested (97 survived, 17 timed out)
Mutation testing 12% (elapsed: ~15m, remaining: ~1h 53m) 128/1058 tested (98 survived, 17 timed out)
Mutation testing 12% (elapsed: ~15m, remaining: ~1h 53m) 130/1058 tested (100 survived, 17 timed out)
Mutation testing 12% (elapsed: ~16m, remaining: ~1h 53m) 131/1058 tested (101 survived, 17 timed out)
Mutation testing 12% (elapsed: ~16m, remaining: ~1h 52m) 133/1058 tested (103 survived, 17 timed out)
Mutation testing 12% (elapsed: ~16m, remaining: ~1h 52m) 134/1058 tested (104 survived, 17 timed out)
Mutation testing 12% (elapsed: ~16m, remaining: ~1h 52m) 135/1058 tested (105 survived, 17 timed out)
Mutation testing 12% (elapsed: ~16m, remaining: ~1h 52m) 137/1058 tested (107 survived, 17 timed out)
Mutation testing 13% (elapsed: ~16m, remaining: ~1h 52m) 138/1058 tested (108 survived, 17 timed out)
Mutation testing 13% (elapsed: ~17m, remaining: ~1h 50m) 141/1058 tested (110 survived, 17 timed out)
Mutation testing 13% (elapsed: ~17m, remaining: ~1h 51m) 141/1058 tested (110 survived, 17 timed out)
Mutation testing 13% (elapsed: ~17m, remaining: ~1h 50m) 144/1058 tested (110 survived, 18 timed out)
Mutation testing 13% (elapsed: ~17m, remaining: ~1h 49m) 146/1058 tested (112 survived, 18 timed out)
Mutation testing 13% (elapsed: ~17m, remaining: ~1h 49m) 147/1058 tested (113 survived, 18 timed out)
Mutation testing 14% (elapsed: ~17m, remaining: ~1h 48m) 149/1058 tested (115 survived, 18 timed out)
Mutation testing 14% (elapsed: ~18m, remaining: ~1h 48m) 150/1058 tested (116 survived, 18 timed out)
Mutation testing 14% (elapsed: ~18m, remaining: ~1h 49m) 151/1058 tested (117 survived, 18 timed out)
Mutation testing 14% (elapsed: ~18m, remaining: ~1h 48m) 153/1058 tested (119 survived, 18 timed out)
Mutation testing 14% (elapsed: ~18m, remaining: ~1h 48m) 154/1058 tested (120 survived, 18 timed out)
Mutation testing 14% (elapsed: ~18m, remaining: ~1h 47m) 156/1058 tested (122 survived, 18 timed out)
Mutation testing 14% (elapsed: ~18m, remaining: ~1h 48m) 157/1058 tested (123 survived, 18 timed out)
Mutation testing 15% (elapsed: ~19m, remaining: ~1h 47m) 159/1058 tested (125 survived, 18 timed out)
Mutation testing 15% (elapsed: ~19m, remaining: ~1h 47m) 160/1058 tested (126 survived, 18 timed out)
Mutation testing 15% (elapsed: ~19m, remaining: ~1h 46m) 162/1058 tested (128 survived, 18 timed out)
Mutation testing 15% (elapsed: ~19m, remaining: ~1h 47m) 163/1058 tested (129 survived, 18 timed out)
Mutation testing 15% (elapsed: ~19m, remaining: ~1h 46m) 165/1058 tested (131 survived, 18 timed out)
Mutation testing 15% (elapsed: ~19m, remaining: ~1h 46m) 166/1058 tested (132 survived, 18 timed out)
Mutation testing 15% (elapsed: ~20m, remaining: ~1h 45m) 168/1058 tested (134 survived, 18 timed out)
Mutation testing 15% (elapsed: ~20m, remaining: ~1h 46m) 169/1058 tested (135 survived, 18 timed out)
Mutation testing 16% (elapsed: ~20m, remaining: ~1h 44m) 172/1058 tested (136 survived, 18 timed out)
Mutation testing 16% (elapsed: ~20m, remaining: ~1h 44m) 174/1058 tested (138 survived, 18 timed out)
Mutation testing 16% (elapsed: ~20m, remaining: ~1h 44m) 175/1058 tested (139 survived, 18 timed out)
Mutation testing 16% (elapsed: ~20m, remaining: ~1h 43m) 177/1058 tested (141 survived, 18 timed out)
Mutation testing 16% (elapsed: ~21m, remaining: ~1h 43m) 178/1058 tested (142 survived, 18 timed out)
Mutation testing 17% (elapsed: ~21m, remaining: ~1h 43m) 180/1058 tested (144 survived, 18 timed out)
Mutation testing 17% (elapsed: ~21m, remaining: ~1h 43m) 181/1058 tested (145 survived, 18 timed out)
Mutation testing 17% (elapsed: ~21m, remaining: ~1h 42m) 183/1058 tested (147 survived, 18 timed out)
Mutation testing 17% (elapsed: ~21m, remaining: ~1h 42m) 184/1058 tested (148 survived, 18 timed out)
Mutation testing 17% (elapsed: ~21m, remaining: ~1h 42m) 186/1058 tested (150 survived, 18 timed out)
Mutation testing 17% (elapsed: ~22m, remaining: ~1h 42m) 187/1058 tested (151 survived, 18 timed out)
Mutation testing 17% (elapsed: ~22m, remaining: ~1h 41m) 189/1058 tested (153 survived, 18 timed out)
Mutation testing 18% (elapsed: ~22m, remaining: ~1h 40m) 192/1058 tested (154 survived, 18 timed out)
Mutation testing 18% (elapsed: ~22m, remaining: ~1h 40m) 193/1058 tested (155 survived, 18 timed out)
Mutation testing 18% (elapsed: ~22m, remaining: ~1h 40m) 195/1058 tested (157 survived, 18 timed out)
Mutation testing 18% (elapsed: ~22m, remaining: ~1h 40m) 196/1058 tested (158 survived, 18 timed out)
Mutation testing 18% (elapsed: ~23m, remaining: ~1h 39m) 198/1058 tested (160 survived, 18 timed out)
Mutation testing 18% (elapsed: ~23m, remaining: ~1h 40m) 199/1058 tested (161 survived, 18 timed out)
Mutation testing 18% (elapsed: ~23m, remaining: ~1h 39m) 201/1058 tested (163 survived, 18 timed out)
Mutation testing 19% (elapsed: ~23m, remaining: ~1h 39m) 202/1058 tested (164 survived, 18 timed out)
Mutation testing 19% (elapsed: ~23m, remaining: ~1h 39m) 204/1058 tested (166 survived, 18 timed out)
Mutation testing 19% (elapsed: ~23m, remaining: ~1h 39m) 205/1058 tested (167 survived, 18 timed out)
Mutation testing 19% (elapsed: ~24m, remaining: ~1h 39m) 206/1058 tested (168 survived, 18 timed out)
Mutation testing 19% (elapsed: ~24m, remaining: ~1h 38m) 209/1058 tested (169 survived, 18 timed out)
Mutation testing 19% (elapsed: ~24m, remaining: ~1h 37m) 211/1058 tested (169 survived, 18 timed out)
Mutation testing 20% (elapsed: ~24m, remaining: ~1h 37m) 212/1058 tested (170 survived, 18 timed out)
Mutation testing 20% (elapsed: ~24m, remaining: ~1h 37m) 214/1058 tested (172 survived, 18 timed out)
Mutation testing 20% (elapsed: ~24m, remaining: ~1h 37m) 215/1058 tested (173 survived, 18 timed out)
Mutation testing 20% (elapsed: ~25m, remaining: ~1h 36m) 217/1058 tested (175 survived, 18 timed out)
Mutation testing 20% (elapsed: ~25m, remaining: ~1h 36m) 219/1058 tested (176 survived, 18 timed out)
Mutation testing 20% (elapsed: ~25m, remaining: ~1h 35m) 222/1058 tested (177 survived, 18 timed out)
Mutation testing 21% (elapsed: ~25m, remaining: ~1h 34m) 224/1058 tested (179 survived, 18 timed out)
Mutation testing 21% (elapsed: ~25m, remaining: ~1h 35m) 225/1058 tested (180 survived, 18 timed out)
Mutation testing 21% (elapsed: ~25m, remaining: ~1h 34m) 227/1058 tested (182 survived, 18 timed out)
Mutation testing 21% (elapsed: ~26m, remaining: ~1h 34m) 228/1058 tested (182 survived, 18 timed out)
Mutation testing 21% (elapsed: ~26m, remaining: ~1h 34m) 229/1058 tested (183 survived, 18 timed out)
Mutation testing 21% (elapsed: ~26m, remaining: ~1h 34m) 230/1058 tested (183 survived, 18 timed out)
Mutation testing 21% (elapsed: ~26m, remaining: ~1h 34m) 231/1058 tested (183 survived, 18 timed out)
Mutation testing 21% (elapsed: ~26m, remaining: ~1h 34m) 232/1058 tested (183 survived, 18 timed out)
Mutation testing 22% (elapsed: ~26m, remaining: ~1h 34m) 234/1058 tested (184 survived, 18 timed out)
Mutation testing 22% (elapsed: ~27m, remaining: ~1h 34m) 235/1058 tested (185 survived, 18 timed out)
Mutation testing 22% (elapsed: ~27m, remaining: ~1h 34m) 237/1058 tested (187 survived, 18 timed out)
Mutation testing 22% (elapsed: ~27m, remaining: ~1h 34m) 238/1058 tested (188 survived, 18 timed out)
Mutation testing 22% (elapsed: ~27m, remaining: ~1h 33m) 240/1058 tested (190 survived, 18 timed out)
Mutation testing 22% (elapsed: ~27m, remaining: ~1h 33m) 241/1058 tested (191 survived, 18 timed out)
Mutation testing 22% (elapsed: ~27m, remaining: ~1h 33m) 243/1058 tested (193 survived, 18 timed out)
Mutation testing 23% (elapsed: ~28m, remaining: ~1h 33m) 244/1058 tested (194 survived, 18 timed out)
Mutation testing 23% (elapsed: ~28m, remaining: ~1h 32m) 246/1058 tested (196 survived, 18 timed out)
Mutation testing 23% (elapsed: ~28m, remaining: ~1h 33m) 247/1058 tested (197 survived, 18 timed out)
Mutation testing 23% (elapsed: ~28m, remaining: ~1h 32m) 249/1058 tested (199 survived, 18 timed out)
Mutation testing 23% (elapsed: ~28m, remaining: ~1h 32m) 250/1058 tested (200 survived, 18 timed out)
Mutation testing 23% (elapsed: ~28m, remaining: ~1h 32m) 252/1058 tested (202 survived, 18 timed out)
Mutation testing 23% (elapsed: ~29m, remaining: ~1h 32m) 253/1058 tested (203 survived, 18 timed out)
Mutation testing 24% (elapsed: ~29m, remaining: ~1h 31m) 255/1058 tested (205 survived, 18 timed out)
Mutation testing 24% (elapsed: ~29m, remaining: ~1h 31m) 256/1058 tested (206 survived, 18 timed out)
Mutation testing 24% (elapsed: ~29m, remaining: ~1h 31m) 258/1058 tested (208 survived, 18 timed out)
Mutation testing 24% (elapsed: ~29m, remaining: ~1h 31m) 259/1058 tested (209 survived, 18 timed out)
Mutation testing 24% (elapsed: ~29m, remaining: ~1h 31m) 261/1058 tested (211 survived, 18 timed out)
Mutation testing 24% (elapsed: ~30m, remaining: ~1h 31m) 262/1058 tested (212 survived, 18 timed out)
Mutation testing 24% (elapsed: ~30m, remaining: ~1h 31m) 263/1058 tested (213 survived, 18 timed out)
Mutation testing 25% (elapsed: ~30m, remaining: ~1h 30m) 265/1058 tested (215 survived, 18 timed out)
Mutation testing 25% (elapsed: ~30m, remaining: ~1h 30m) 266/1058 tested (216 survived, 18 timed out)
Mutation testing 25% (elapsed: ~30m, remaining: ~1h 30m) 268/1058 tested (218 survived, 18 timed out)
Mutation testing 25% (elapsed: ~30m, remaining: ~1h 30m) 269/1058 tested (219 survived, 18 timed out)
Mutation testing 25% (elapsed: ~31m, remaining: ~1h 30m) 271/1058 tested (221 survived, 18 timed out)
Mutation testing 25% (elapsed: ~31m, remaining: ~1h 30m) 272/1058 tested (222 survived, 18 timed out)
Mutation testing 25% (elapsed: ~31m, remaining: ~1h 29m) 274/1058 tested (224 survived, 18 timed out)
Mutation testing 25% (elapsed: ~31m, remaining: ~1h 29m) 275/1058 tested (225 survived, 18 timed out)
Mutation testing 26% (elapsed: ~31m, remaining: ~1h 29m) 277/1058 tested (227 survived, 18 timed out)
Mutation testing 26% (elapsed: ~31m, remaining: ~1h 29m) 278/1058 tested (228 survived, 18 timed out)
Mutation testing 26% (elapsed: ~32m, remaining: ~1h 28m) 280/1058 tested (230 survived, 18 timed out)
Mutation testing 26% (elapsed: ~32m, remaining: ~1h 28m) 281/1058 tested (231 survived, 18 timed out)
Mutation testing 26% (elapsed: ~32m, remaining: ~1h 28m) 283/1058 tested (233 survived, 18 timed out)
Mutation testing 26% (elapsed: ~32m, remaining: ~1h 28m) 284/1058 tested (234 survived, 18 timed out)
Mutation testing 27% (elapsed: ~32m, remaining: ~1h 28m) 286/1058 tested (236 survived, 18 timed out)
Mutation testing 27% (elapsed: ~32m, remaining: ~1h 28m) 287/1058 tested (237 survived, 18 timed out)
Mutation testing 27% (elapsed: ~33m, remaining: ~1h 27m) 289/1058 tested (239 survived, 18 timed out)
Mutation testing 27% (elapsed: ~33m, remaining: ~1h 27m) 290/1058 tested (240 survived, 18 timed out)
Mutation testing 27% (elapsed: ~33m, remaining: ~1h 27m) 292/1058 tested (242 survived, 18 timed out)
Mutation testing 27% (elapsed: ~33m, remaining: ~1h 27m) 293/1058 tested (243 survived, 18 timed out)
Mutation testing 27% (elapsed: ~33m, remaining: ~1h 27m) 295/1058 tested (245 survived, 18 timed out)
Mutation testing 27% (elapsed: ~33m, remaining: ~1h 27m) 296/1058 tested (246 survived, 18 timed out)
Mutation testing 28% (elapsed: ~34m, remaining: ~1h 27m) 297/1058 tested (247 survived, 18 timed out)
Mutation testing 28% (elapsed: ~34m, remaining: ~1h 26m) 299/1058 tested (249 survived, 18 timed out)
Mutation testing 28% (elapsed: ~34m, remaining: ~1h 26m) 300/1058 tested (250 survived, 18 timed out)
Mutation testing 28% (elapsed: ~34m, remaining: ~1h 25m) 303/1058 tested (252 survived, 18 timed out)
Mutation testing 28% (elapsed: ~34m, remaining: ~1h 25m) 304/1058 tested (253 survived, 18 timed out)
Mutation testing 28% (elapsed: ~34m, remaining: ~1h 25m) 306/1058 tested (255 survived, 18 timed out)
Mutation testing 29% (elapsed: ~35m, remaining: ~1h 25m) 307/1058 tested (256 survived, 18 timed out)
Mutation testing 29% (elapsed: ~35m, remaining: ~1h 25m) 309/1058 tested (258 survived, 18 timed out)
Mutation testing 29% (elapsed: ~35m, remaining: ~1h 25m) 310/1058 tested (259 survived, 18 timed out)
Mutation testing 29% (elapsed: ~35m, remaining: ~1h 24m) 312/1058 tested (261 survived, 18 timed out)
Mutation testing 29% (elapsed: ~35m, remaining: ~1h 24m) 313/1058 tested (262 survived, 18 timed out)
Mutation testing 29% (elapsed: ~35m, remaining: ~1h 24m) 315/1058 tested (264 survived, 18 timed out)
Mutation testing 29% (elapsed: ~36m, remaining: ~1h 24m) 316/1058 tested (265 survived, 18 timed out)
Mutation testing 30% (elapsed: ~36m, remaining: ~1h 24m) 318/1058 tested (267 survived, 18 timed out)
Mutation testing 30% (elapsed: ~36m, remaining: ~1h 24m) 319/1058 tested (268 survived, 18 timed out)
Mutation testing 30% (elapsed: ~36m, remaining: ~1h 24m) 320/1058 tested (269 survived, 18 timed out)
Mutation testing 30% (elapsed: ~36m, remaining: ~1h 23m) 322/1058 tested (271 survived, 18 timed out)
Mutation testing 30% (elapsed: ~36m, remaining: ~1h 23m) 323/1058 tested (272 survived, 18 timed out)
Mutation testing 30% (elapsed: ~37m, remaining: ~1h 23m) 325/1058 tested (274 survived, 18 timed out)
Mutation testing 30% (elapsed: ~37m, remaining: ~1h 23m) 326/1058 tested (275 survived, 18 timed out)
Mutation testing 31% (elapsed: ~37m, remaining: ~1h 23m) 328/1058 tested (277 survived, 18 timed out)
Mutation testing 31% (elapsed: ~37m, remaining: ~1h 23m) 329/1058 tested (278 survived, 18 timed out)
Mutation testing 31% (elapsed: ~37m, remaining: ~1h 22m) 331/1058 tested (280 survived, 18 timed out)
Mutation testing 31% (elapsed: ~37m, remaining: ~1h 22m) 332/1058 tested (281 survived, 18 timed out)
Mutation testing 31% (elapsed: ~38m, remaining: ~1h 22m) 334/1058 tested (283 survived, 18 timed out)
Mutation testing 31% (elapsed: ~38m, remaining: ~1h 22m) 335/1058 tested (284 survived, 18 timed out)
Mutation testing 31% (elapsed: ~38m, remaining: ~1h 22m) 337/1058 tested (286 survived, 18 timed out)
Mutation testing 31% (elapsed: ~38m, remaining: ~1h 22m) 338/1058 tested (287 survived, 18 timed out)
Mutation testing 32% (elapsed: ~38m, remaining: ~1h 21m) 340/1058 tested (289 survived, 18 timed out)
Mutation testing 32% (elapsed: ~38m, remaining: ~1h 21m) 341/1058 tested (290 survived, 18 timed out)
Mutation testing 32% (elapsed: ~39m, remaining: ~1h 21m) 343/1058 tested (292 survived, 18 timed out)
Mutation testing 32% (elapsed: ~39m, remaining: ~1h 21m) 344/1058 tested (293 survived, 18 timed out)
Mutation testing 32% (elapsed: ~39m, remaining: ~1h 20m) 346/1058 tested (295 survived, 18 timed out)
Mutation testing 32% (elapsed: ~39m, remaining: ~1h 20m) 347/1058 tested (296 survived, 18 timed out)
Mutation testing 32% (elapsed: ~39m, remaining: ~1h 20m) 348/1058 tested (297 survived, 18 timed out)
Mutation testing 33% (elapsed: ~39m, remaining: ~1h 20m) 350/1058 tested (299 survived, 18 timed out)
Mutation testing 33% (elapsed: ~40m, remaining: ~1h 20m) 351/1058 tested (300 survived, 18 timed out)
Mutation testing 33% (elapsed: ~40m, remaining: ~1h 20m) 353/1058 tested (302 survived, 18 timed out)
Mutation testing 33% (elapsed: ~40m, remaining: ~1h 20m) 354/1058 tested (303 survived, 18 timed out)
Mutation testing 33% (elapsed: ~40m, remaining: ~1h 19m) 356/1058 tested (305 survived, 18 timed out)
Mutation testing 33% (elapsed: ~40m, remaining: ~1h 19m) 357/1058 tested (306 survived, 18 timed out)
Mutation testing 33% (elapsed: ~40m, remaining: ~1h 19m) 359/1058 tested (308 survived, 18 timed out)
Mutation testing 34% (elapsed: ~41m, remaining: ~1h 19m) 360/1058 tested (309 survived, 18 timed out)
Mutation testing 34% (elapsed: ~41m, remaining: ~1h 19m) 362/1058 tested (311 survived, 18 timed out)
Mutation testing 34% (elapsed: ~41m, remaining: ~1h 19m) 363/1058 tested (312 survived, 18 timed out)
Mutation testing 34% (elapsed: ~41m, remaining: ~1h 18m) 365/1058 tested (314 survived, 18 timed out)
Mutation testing 34% (elapsed: ~41m, remaining: ~1h 18m) 366/1058 tested (315 survived, 18 timed out)
Mutation testing 34% (elapsed: ~41m, remaining: ~1h 18m) 368/1058 tested (317 survived, 18 timed out)
Mutation testing 34% (elapsed: ~42m, remaining: ~1h 18m) 369/1058 tested (318 survived, 18 timed out)
Mutation testing 35% (elapsed: ~42m, remaining: ~1h 18m) 371/1058 tested (320 survived, 18 timed out)
Mutation testing 35% (elapsed: ~42m, remaining: ~1h 18m) 372/1058 tested (321 survived, 18 timed out)
Mutation testing 35% (elapsed: ~42m, remaining: ~1h 17m) 374/1058 tested (323 survived, 18 timed out)
Mutation testing 35% (elapsed: ~42m, remaining: ~1h 17m) 375/1058 tested (324 survived, 18 timed out)
Mutation testing 35% (elapsed: ~42m, remaining: ~1h 17m) 377/1058 tested (326 survived, 18 timed out)
Mutation testing 35% (elapsed: ~43m, remaining: ~1h 16m) 380/1058 tested (327 survived, 18 timed out)
Mutation testing 36% (elapsed: ~43m, remaining: ~1h 16m) 381/1058 tested (328 survived, 18 timed out)
Mutation testing 36% (elapsed: ~43m, remaining: ~1h 16m) 381/1058 tested (328 survived, 18 timed out)
Mutation testing 36% (elapsed: ~43m, remaining: ~1h 16m) 383/1058 tested (328 survived, 19 timed out)
Mutation testing 36% (elapsed: ~43m, remaining: ~1h 16m) 385/1058 tested (328 survived, 19 timed out)
Mutation testing 36% (elapsed: ~43m, remaining: ~1h 16m) 386/1058 tested (329 survived, 19 timed out)
Mutation testing 36% (elapsed: ~44m, remaining: ~1h 15m) 388/1058 tested (331 survived, 19 timed out)
Mutation testing 36% (elapsed: ~44m, remaining: ~1h 15m) 389/1058 tested (332 survived, 19 timed out)
Mutation testing 36% (elapsed: ~44m, remaining: ~1h 15m) 391/1058 tested (334 survived, 19 timed out)
Mutation testing 37% (elapsed: ~44m, remaining: ~1h 15m) 392/1058 tested (335 survived, 19 timed out)
Mutation testing 37% (elapsed: ~44m, remaining: ~1h 15m) 394/1058 tested (337 survived, 19 timed out)
Mutation testing 37% (elapsed: ~44m, remaining: ~1h 15m) 395/1058 tested (338 survived, 19 timed out)
Mutation testing 37% (elapsed: ~45m, remaining: ~1h 14m) 397/1058 tested (340 survived, 19 timed out)
Mutation testing 37% (elapsed: ~45m, remaining: ~1h 14m) 400/1058 tested (341 survived, 19 timed out)
Mutation testing 37% (elapsed: ~45m, remaining: ~1h 14m) 401/1058 tested (342 survived, 19 timed out)
Mutation testing 37% (elapsed: ~45m, remaining: ~1h 14m) 402/1058 tested (342 survived, 20 timed out)
Mutation testing 38% (elapsed: ~45m, remaining: ~1h 13m) 404/1058 tested (342 survived, 20 timed out)
Mutation testing 38% (elapsed: ~45m, remaining: ~1h 13m) 405/1058 tested (342 survived, 21 timed out)
Mutation testing 38% (elapsed: ~46m, remaining: ~1h 13m) 406/1058 tested (343 survived, 21 timed out)
Mutation testing 38% (elapsed: ~46m, remaining: ~1h 13m) 408/1058 tested (345 survived, 21 timed out)
Mutation testing 38% (elapsed: ~46m, remaining: ~1h 13m) 409/1058 tested (346 survived, 21 timed out)
Mutation testing 38% (elapsed: ~46m, remaining: ~1h 13m) 411/1058 tested (348 survived, 21 timed out)
Mutation testing 38% (elapsed: ~46m, remaining: ~1h 13m) 412/1058 tested (349 survived, 21 timed out)
Mutation testing 39% (elapsed: ~46m, remaining: ~1h 13m) 413/1058 tested (349 survived, 22 timed out)
Mutation testing 39% (elapsed: ~47m, remaining: ~1h 13m) 413/1058 tested (349 survived, 22 timed out)
Mutation testing 39% (elapsed: ~47m, remaining: ~1h 13m) 414/1058 tested (349 survived, 23 timed out)
Mutation testing 39% (elapsed: ~47m, remaining: ~1h 13m) 416/1058 tested (351 survived, 23 timed out)
Mutation testing 39% (elapsed: ~47m, remaining: ~1h 13m) 417/1058 tested (352 survived, 23 timed out)
Mutation testing 39% (elapsed: ~47m, remaining: ~1h 12m) 419/1058 tested (354 survived, 23 timed out)
Mutation testing 39% (elapsed: ~47m, remaining: ~1h 12m) 420/1058 tested (355 survived, 23 timed out)
Mutation testing 39% (elapsed: ~48m, remaining: ~1h 12m) 422/1058 tested (357 survived, 23 timed out)
Mutation testing 39% (elapsed: ~48m, remaining: ~1h 12m) 423/1058 tested (358 survived, 23 timed out)
Mutation testing 40% (elapsed: ~48m, remaining: ~1h 11m) 425/1058 tested (360 survived, 23 timed out)
Mutation testing 40% (elapsed: ~48m, remaining: ~1h 11m) 426/1058 tested (361 survived, 23 timed out)
Mutation testing 40% (elapsed: ~48m, remaining: ~1h 11m) 428/1058 tested (363 survived, 23 timed out)
Mutation testing 40% (elapsed: ~48m, remaining: ~1h 11m) 429/1058 tested (364 survived, 23 timed out)
Mutation testing 40% (elapsed: ~49m, remaining: ~1h 11m) 430/1058 tested (365 survived, 23 timed out)
Mutation testing 40% (elapsed: ~49m, remaining: ~1h 11m) 432/1058 tested (367 survived, 23 timed out)
Mutation testing 40% (elapsed: ~49m, remaining: ~1h 11m) 433/1058 tested (368 survived, 23 timed out)
Mutation testing 41% (elapsed: ~49m, remaining: ~1h 10m) 435/1058 tested (370 survived, 23 timed out)
Mutation testing 41% (elapsed: ~49m, remaining: ~1h 10m) 436/1058 tested (371 survived, 23 timed out)
Mutation testing 41% (elapsed: ~49m, remaining: ~1h 10m) 438/1058 tested (373 survived, 23 timed out)
Mutation testing 41% (elapsed: ~50m, remaining: ~1h 10m) 438/1058 tested (373 survived, 23 timed out)
Mutation testing 41% (elapsed: ~50m, remaining: ~1h 10m) 440/1058 tested (374 survived, 24 timed out)
Mutation testing 41% (elapsed: ~50m, remaining: ~1h 10m) 441/1058 tested (375 survived, 24 timed out)
Mutation testing 41% (elapsed: ~50m, remaining: ~1h 10m) 443/1058 tested (377 survived, 24 timed out)
Mutation testing 41% (elapsed: ~50m, remaining: ~1h 10m) 443/1058 tested (377 survived, 24 timed out)
Mutation testing 41% (elapsed: ~50m, remaining: ~1h 10m) 444/1058 tested (377 survived, 25 timed out)
Mutation testing 41% (elapsed: ~51m, remaining: ~1h 10m) 444/1058 tested (377 survived, 25 timed out)
Mutation testing 42% (elapsed: ~51m, remaining: ~1h 10m) 445/1058 tested (377 survived, 26 timed out)
Mutation testing 42% (elapsed: ~51m, remaining: ~1h 10m) 446/1058 tested (377 survived, 27 timed out)
Mutation testing 42% (elapsed: ~51m, remaining: ~1h 10m) 446/1058 tested (377 survived, 27 timed out)
Mutation testing 42% (elapsed: ~51m, remaining: ~1h 10m) 449/1058 tested (377 survived, 28 timed out)
Mutation testing 42% (elapsed: ~51m, remaining: ~1h 9m) 451/1058 tested (379 survived, 28 timed out)
Mutation testing 42% (elapsed: ~52m, remaining: ~1h 9m) 452/1058 tested (380 survived, 28 timed out)
Mutation testing 42% (elapsed: ~52m, remaining: ~1h 9m) 453/1058 tested (381 survived, 28 timed out)
Mutation testing 42% (elapsed: ~52m, remaining: ~1h 9m) 454/1058 tested (381 survived, 29 timed out)
Mutation testing 42% (elapsed: ~52m, remaining: ~1h 9m) 454/1058 tested (381 survived, 29 timed out)
Mutation testing 43% (elapsed: ~52m, remaining: ~1h 9m) 457/1058 tested (381 survived, 30 timed out)
Mutation testing 43% (elapsed: ~52m, remaining: ~1h 9m) 458/1058 tested (382 survived, 30 timed out)
Mutation testing 43% (elapsed: ~53m, remaining: ~1h 8m) 460/1058 tested (384 survived, 30 timed out)
Mutation testing 43% (elapsed: ~53m, remaining: ~1h 8m) 461/1058 tested (385 survived, 30 timed out)
Mutation testing 43% (elapsed: ~53m, remaining: ~1h 8m) 463/1058 tested (387 survived, 30 timed out)
Mutation testing 43% (elapsed: ~53m, remaining: ~1h 8m) 464/1058 tested (388 survived, 30 timed out)
Mutation testing 44% (elapsed: ~53m, remaining: ~1h 8m) 466/1058 tested (390 survived, 30 timed out)
Mutation testing 44% (elapsed: ~53m, remaining: ~1h 8m) 467/1058 tested (391 survived, 30 timed out)
Mutation testing 44% (elapsed: ~54m, remaining: ~1h 7m) 469/1058 tested (393 survived, 30 timed out)
Mutation testing 44% (elapsed: ~54m, remaining: ~1h 7m) 470/1058 tested (394 survived, 30 timed out)
Mutation testing 44% (elapsed: ~54m, remaining: ~1h 7m) 472/1058 tested (396 survived, 30 timed out)
Mutation testing 44% (elapsed: ~54m, remaining: ~1h 7m) 473/1058 tested (397 survived, 30 timed out)
Mutation testing 44% (elapsed: ~54m, remaining: ~1h 7m) 475/1058 tested (399 survived, 30 timed out)
Mutation testing 44% (elapsed: ~54m, remaining: ~1h 7m) 476/1058 tested (400 survived, 30 timed out)
Mutation testing 45% (elapsed: ~55m, remaining: ~1h 6m) 478/1058 tested (402 survived, 30 timed out)
Mutation testing 45% (elapsed: ~55m, remaining: ~1h 6m) 479/1058 tested (403 survived, 30 timed out)
Mutation testing 45% (elapsed: ~55m, remaining: ~1h 6m) 481/1058 tested (405 survived, 30 timed out)
Mutation testing 45% (elapsed: ~55m, remaining: ~1h 6m) 482/1058 tested (406 survived, 30 timed out)
Mutation testing 45% (elapsed: ~55m, remaining: ~1h 6m) 484/1058 tested (408 survived, 30 timed out)
Mutation testing 45% (elapsed: ~55m, remaining: ~1h 5m) 485/1058 tested (409 survived, 30 timed out)
Mutation testing 45% (elapsed: ~56m, remaining: ~1h 5m) 486/1058 tested (410 survived, 30 timed out)
Mutation testing 46% (elapsed: ~56m, remaining: ~1h 5m) 488/1058 tested (412 survived, 30 timed out)
Mutation testing 46% (elapsed: ~56m, remaining: ~1h 5m) 489/1058 tested (413 survived, 30 timed out)
Mutation testing 46% (elapsed: ~56m, remaining: ~1h 5m) 491/1058 tested (415 survived, 30 timed out)
Mutation testing 46% (elapsed: ~56m, remaining: ~1h 5m) 492/1058 tested (416 survived, 30 timed out)
Mutation testing 46% (elapsed: ~56m, remaining: ~1h 4m) 494/1058 tested (418 survived, 30 timed out)
Mutation testing 46% (elapsed: ~57m, remaining: ~1h 4m) 495/1058 tested (419 survived, 30 timed out)
Mutation testing 46% (elapsed: ~57m, remaining: ~1h 4m) 497/1058 tested (421 survived, 30 timed out)
Mutation testing 47% (elapsed: ~57m, remaining: ~1h 4m) 498/1058 tested (422 survived, 30 timed out)
Mutation testing 47% (elapsed: ~57m, remaining: ~1h 4m) 500/1058 tested (424 survived, 30 timed out)
Mutation testing 47% (elapsed: ~57m, remaining: ~1h 4m) 501/1058 tested (425 survived, 30 timed out)
Mutation testing 47% (elapsed: ~57m, remaining: ~1h 3m) 503/1058 tested (427 survived, 30 timed out)
Mutation testing 47% (elapsed: ~58m, remaining: ~1h 3m) 505/1058 tested (428 survived, 30 timed out)
Mutation testing 47% (elapsed: ~58m, remaining: ~1h 3m) 507/1058 tested (430 survived, 30 timed out)
Mutation testing 48% (elapsed: ~58m, remaining: ~1h 3m) 508/1058 tested (431 survived, 30 timed out)
Mutation testing 48% (elapsed: ~58m, remaining: ~1h 2m) 510/1058 tested (433 survived, 30 timed out)
Mutation testing 48% (elapsed: ~58m, remaining: ~1h 2m) 511/1058 tested (434 survived, 30 timed out)
Mutation testing 48% (elapsed: ~58m, remaining: ~1h 2m) 512/1058 tested (435 survived, 30 timed out)
Mutation testing 48% (elapsed: ~59m, remaining: ~1h 2m) 514/1058 tested (437 survived, 30 timed out)
Mutation testing 48% (elapsed: ~59m, remaining: ~1h 2m) 515/1058 tested (438 survived, 30 timed out)
Mutation testing 48% (elapsed: ~59m, remaining: ~1h 2m) 517/1058 tested (440 survived, 30 timed out)
Mutation testing 48% (elapsed: ~59m, remaining: ~1h 2m) 518/1058 tested (441 survived, 30 timed out)
Mutation testing 49% (elapsed: ~59m, remaining: ~1h 1m) 519/1058 tested (441 survived, 31 timed out)
Mutation testing 49% (elapsed: ~59m, remaining: ~1h 2m) 519/1058 tested (441 survived, 31 timed out)
Mutation testing 49% (elapsed: ~1h 0m, remaining: ~1h 2m) 520/1058 tested (441 survived, 32 timed out)
Mutation testing 49% (elapsed: ~1h 0m, remaining: ~1h 2m) 521/1058 tested (442 survived, 32 timed out)
Mutation testing 49% (elapsed: ~1h 0m, remaining: ~1h 1m) 522/1058 tested (442 survived, 33 timed out)
Mutation testing 49% (elapsed: ~1h 0m, remaining: ~1h 2m) 522/1058 tested (442 survived, 33 timed out)
Mutation testing 49% (elapsed: ~1h 0m, remaining: ~1h 1m) 524/1058 tested (443 survived, 34 timed out)
Mutation testing 49% (elapsed: ~1h 0m, remaining: ~1h 1m) 526/1058 tested (444 survived, 34 timed out)
Mutation testing 49% (elapsed: ~1h 1m, remaining: ~1h 1m) 526/1058 tested (444 survived, 34 timed out)
Mutation testing 49% (elapsed: ~1h 1m, remaining: ~1h 1m) 527/1058 tested (444 survived, 35 timed out)
Mutation testing 49% (elapsed: ~1h 1m, remaining: ~1h 1m) 528/1058 tested (444 survived, 36 timed out)
Mutation testing 50% (elapsed: ~1h 1m, remaining: ~1h 1m) 529/1058 tested (445 survived, 36 timed out)
Mutation testing 50% (elapsed: ~1h 1m, remaining: ~1h 1m) 531/1058 tested (447 survived, 36 timed out)
Mutation testing 50% (elapsed: ~1h 1m, remaining: ~1h 1m) 532/1058 tested (448 survived, 36 timed out)
Mutation testing 50% (elapsed: ~1h 2m, remaining: ~1h 0m) 534/1058 tested (450 survived, 36 timed out)
Mutation testing 50% (elapsed: ~1h 2m, remaining: ~1h 0m) 535/1058 tested (451 survived, 36 timed out)
Mutation testing 50% (elapsed: ~1h 2m, remaining: ~1h 0m) 537/1058 tested (453 survived, 36 timed out)
Mutation testing 50% (elapsed: ~1h 2m, remaining: ~1h 0m) 538/1058 tested (454 survived, 36 timed out)
Mutation testing 51% (elapsed: ~1h 2m, remaining: ~1h 0m) 540/1058 tested (456 survived, 36 timed out)
Mutation testing 51% (elapsed: ~1h 2m, remaining: ~1h 0m) 541/1058 tested (457 survived, 36 timed out)
Mutation testing 51% (elapsed: ~1h 3m, remaining: ~59m) 543/1058 tested (459 survived, 36 timed out)
Mutation testing 51% (elapsed: ~1h 3m, remaining: ~59m) 544/1058 tested (460 survived, 36 timed out)
Mutation testing 51% (elapsed: ~1h 3m, remaining: ~59m) 546/1058 tested (462 survived, 36 timed out)
Mutation testing 51% (elapsed: ~1h 3m, remaining: ~59m) 547/1058 tested (463 survived, 36 timed out)
Mutation testing 51% (elapsed: ~1h 3m, remaining: ~59m) 549/1058 tested (465 survived, 36 timed out)
Mutation testing 51% (elapsed: ~1h 3m, remaining: ~59m) 549/1058 tested (465 survived, 36 timed out)
Mutation testing 51% (elapsed: ~1h 4m, remaining: ~59m) 550/1058 tested (465 survived, 36 timed out)
Mutation testing 52% (elapsed: ~1h 4m, remaining: ~59m) 551/1058 tested (465 survived, 37 timed out)
Mutation testing 52% (elapsed: ~1h 4m, remaining: ~59m) 551/1058 tested (465 survived, 37 timed out)
Mutation testing 52% (elapsed: ~1h 4m, remaining: ~59m) 552/1058 tested (465 survived, 38 timed out)
Mutation testing 52% (elapsed: ~1h 4m, remaining: ~59m) 553/1058 tested (465 survived, 39 timed out)
Mutation testing 52% (elapsed: ~1h 4m, remaining: ~58m) 554/1058 tested (465 survived, 39 timed out)
Mutation testing 52% (elapsed: ~1h 5m, remaining: ~59m) 554/1058 tested (465 survived, 39 timed out)
Mutation testing 52% (elapsed: ~1h 5m, remaining: ~59m) 555/1058 tested (465 survived, 40 timed out)
Mutation testing 52% (elapsed: ~1h 5m, remaining: ~58m) 556/1058 tested (465 survived, 41 timed out)
Mutation testing 52% (elapsed: ~1h 5m, remaining: ~59m) 556/1058 tested (465 survived, 41 timed out)
Mutation testing 52% (elapsed: ~1h 5m, remaining: ~59m) 557/1058 tested (465 survived, 42 timed out)
Mutation testing 52% (elapsed: ~1h 5m, remaining: ~58m) 558/1058 tested (465 survived, 42 timed out)
Mutation testing 52% (elapsed: ~1h 6m, remaining: ~59m) 558/1058 tested (465 survived, 42 timed out)
Mutation testing 52% (elapsed: ~1h 6m, remaining: ~59m) 559/1058 tested (465 survived, 43 timed out)
Mutation testing 52% (elapsed: ~1h 6m, remaining: ~58m) 560/1058 tested (465 survived, 43 timed out)
Mutation testing 53% (elapsed: ~1h 6m, remaining: ~58m) 561/1058 tested (465 survived, 44 timed out)
Mutation testing 53% (elapsed: ~1h 6m, remaining: ~59m) 561/1058 tested (465 survived, 44 timed out)
Mutation testing 53% (elapsed: ~1h 6m, remaining: ~58m) 562/1058 tested (465 survived, 45 timed out)
Mutation testing 53% (elapsed: ~1h 7m, remaining: ~58m) 563/1058 tested (465 survived, 46 timed out)
Mutation testing 53% (elapsed: ~1h 7m, remaining: ~59m) 563/1058 tested (465 survived, 46 timed out)
Mutation testing 53% (elapsed: ~1h 7m, remaining: ~58m) 564/1058 tested (465 survived, 47 timed out)
Mutation testing 53% (elapsed: ~1h 7m, remaining: ~58m) 565/1058 tested (465 survived, 48 timed out)
Mutation testing 53% (elapsed: ~1h 7m, remaining: ~59m) 565/1058 tested (465 survived, 48 timed out)
Mutation testing 53% (elapsed: ~1h 7m, remaining: ~58m) 567/1058 tested (466 survived, 48 timed out)
Mutation testing 53% (elapsed: ~1h 8m, remaining: ~58m) 568/1058 tested (467 survived, 48 timed out)
Mutation testing 53% (elapsed: ~1h 8m, remaining: ~58m) 570/1058 tested (469 survived, 48 timed out)
Mutation testing 53% (elapsed: ~1h 8m, remaining: ~58m) 571/1058 tested (470 survived, 48 timed out)
Mutation testing 53% (elapsed: ~1h 8m, remaining: ~58m) 571/1058 tested (470 survived, 48 timed out)
Mutation testing 54% (elapsed: ~1h 8m, remaining: ~58m) 572/1058 tested (470 survived, 49 timed out)
Mutation testing 54% (elapsed: ~1h 8m, remaining: ~58m) 573/1058 tested (470 survived, 50 timed out)
Mutation testing 54% (elapsed: ~1h 9m, remaining: ~58m) 573/1058 tested (470 survived, 50 timed out)
Mutation testing 54% (elapsed: ~1h 9m, remaining: ~58m) 575/1058 tested (470 survived, 51 timed out)
Mutation testing 54% (elapsed: ~1h 9m, remaining: ~58m) 576/1058 tested (470 survived, 51 timed out)
Mutation testing 54% (elapsed: ~1h 9m, remaining: ~57m) 577/1058 tested (471 survived, 51 timed out)
Mutation testing 54% (elapsed: ~1h 9m, remaining: ~57m) 578/1058 tested (471 survived, 52 timed out)
Mutation testing 54% (elapsed: ~1h 9m, remaining: ~57m) 578/1058 tested (471 survived, 52 timed out)
Mutation testing 54% (elapsed: ~1h 10m, remaining: ~57m) 579/1058 tested (471 survived, 53 timed out)
Mutation testing 54% (elapsed: ~1h 10m, remaining: ~57m) 580/1058 tested (471 survived, 54 timed out)
Mutation testing 54% (elapsed: ~1h 10m, remaining: ~57m) 580/1058 tested (471 survived, 54 timed out)
Mutation testing 54% (elapsed: ~1h 10m, remaining: ~57m) 581/1058 tested (471 survived, 55 timed out)
Mutation testing 55% (elapsed: ~1h 10m, remaining: ~57m) 583/1058 tested (473 survived, 55 timed out)
Mutation testing 55% (elapsed: ~1h 10m, remaining: ~57m) 584/1058 tested (473 survived, 55 timed out)
Mutation testing 55% (elapsed: ~1h 11m, remaining: ~57m) 585/1058 tested (474 survived, 55 timed out)
Mutation testing 55% (elapsed: ~1h 11m, remaining: ~57m) 587/1058 tested (476 survived, 55 timed out)
Mutation testing 55% (elapsed: ~1h 11m, remaining: ~57m) 588/1058 tested (477 survived, 55 timed out)
Mutation testing 55% (elapsed: ~1h 11m, remaining: ~56m) 590/1058 tested (479 survived, 55 timed out)
Mutation testing 55% (elapsed: ~1h 11m, remaining: ~56m) 591/1058 tested (480 survived, 55 timed out)
Mutation testing 56% (elapsed: ~1h 11m, remaining: ~56m) 593/1058 tested (482 survived, 55 timed out)
Mutation testing 56% (elapsed: ~1h 12m, remaining: ~56m) 594/1058 tested (483 survived, 55 timed out)
Mutation testing 56% (elapsed: ~1h 12m, remaining: ~55m) 596/1058 tested (485 survived, 55 timed out)
Mutation testing 56% (elapsed: ~1h 12m, remaining: ~55m) 597/1058 tested (486 survived, 55 timed out)
Mutation testing 56% (elapsed: ~1h 12m, remaining: ~55m) 599/1058 tested (488 survived, 55 timed out)
Mutation testing 56% (elapsed: ~1h 12m, remaining: ~55m) 600/1058 tested (489 survived, 55 timed out)
Mutation testing 56% (elapsed: ~1h 12m, remaining: ~55m) 602/1058 tested (491 survived, 55 timed out)
Mutation testing 56% (elapsed: ~1h 13m, remaining: ~55m) 603/1058 tested (492 survived, 55 timed out)
Mutation testing 57% (elapsed: ~1h 13m, remaining: ~54m) 605/1058 tested (494 survived, 55 timed out)
Mutation testing 57% (elapsed: ~1h 13m, remaining: ~54m) 606/1058 tested (495 survived, 55 timed out)
Mutation testing 57% (elapsed: ~1h 13m, remaining: ~54m) 608/1058 tested (497 survived, 55 timed out)
Mutation testing 57% (elapsed: ~1h 13m, remaining: ~54m) 609/1058 tested (498 survived, 55 timed out)
Mutation testing 57% (elapsed: ~1h 13m, remaining: ~54m) 611/1058 tested (500 survived, 55 timed out)
Mutation testing 57% (elapsed: ~1h 14m, remaining: ~53m) 612/1058 tested (501 survived, 55 timed out)
Mutation testing 58% (elapsed: ~1h 14m, remaining: ~53m) 614/1058 tested (503 survived, 55 timed out)
Mutation testing 58% (elapsed: ~1h 14m, remaining: ~53m) 615/1058 tested (504 survived, 55 timed out)
Mutation testing 58% (elapsed: ~1h 14m, remaining: ~53m) 617/1058 tested (506 survived, 55 timed out)
Mutation testing 58% (elapsed: ~1h 14m, remaining: ~53m) 618/1058 tested (507 survived, 55 timed out)
Mutation testing 58% (elapsed: ~1h 14m, remaining: ~53m) 619/1058 tested (508 survived, 55 timed out)
Mutation testing 58% (elapsed: ~1h 15m, remaining: ~52m) 620/1058 tested (508 survived, 55 timed out)
Mutation testing 58% (elapsed: ~1h 15m, remaining: ~52m) 621/1058 tested (508 survived, 56 timed out)
Mutation testing 58% (elapsed: ~1h 15m, remaining: ~52m) 622/1058 tested (508 survived, 56 timed out)
Mutation testing 58% (elapsed: ~1h 15m, remaining: ~52m) 623/1058 tested (508 survived, 57 timed out)
Mutation testing 58% (elapsed: ~1h 15m, remaining: ~52m) 623/1058 tested (508 survived, 57 timed out)
Mutation testing 58% (elapsed: ~1h 15m, remaining: ~52m) 624/1058 tested (508 survived, 58 timed out)
Mutation testing 59% (elapsed: ~1h 16m, remaining: ~52m) 625/1058 tested (508 survived, 59 timed out)
Mutation testing 59% (elapsed: ~1h 16m, remaining: ~52m) 626/1058 tested (508 survived, 59 timed out)
Mutation testing 59% (elapsed: ~1h 16m, remaining: ~52m) 627/1058 tested (509 survived, 59 timed out)
Mutation testing 59% (elapsed: ~1h 16m, remaining: ~52m) 629/1058 tested (511 survived, 59 timed out)
Mutation testing 59% (elapsed: ~1h 16m, remaining: ~52m) 630/1058 tested (512 survived, 59 timed out)
Mutation testing 59% (elapsed: ~1h 16m, remaining: ~51m) 632/1058 tested (514 survived, 59 timed out)
Mutation testing 59% (elapsed: ~1h 17m, remaining: ~51m) 633/1058 tested (515 survived, 59 timed out)
Mutation testing 60% (elapsed: ~1h 17m, remaining: ~51m) 635/1058 tested (517 survived, 59 timed out)
Mutation testing 60% (elapsed: ~1h 17m, remaining: ~51m) 636/1058 tested (518 survived, 59 timed out)
Mutation testing 60% (elapsed: ~1h 17m, remaining: ~51m) 638/1058 tested (520 survived, 59 timed out)
Mutation testing 60% (elapsed: ~1h 17m, remaining: ~50m) 639/1058 tested (521 survived, 59 timed out)
Mutation testing 60% (elapsed: ~1h 17m, remaining: ~50m) 641/1058 tested (523 survived, 59 timed out)
Mutation testing 60% (elapsed: ~1h 18m, remaining: ~50m) 642/1058 tested (524 survived, 59 timed out)
Mutation testing 60% (elapsed: ~1h 18m, remaining: ~50m) 644/1058 tested (526 survived, 59 timed out)
Mutation testing 60% (elapsed: ~1h 18m, remaining: ~50m) 645/1058 tested (527 survived, 59 timed out)
Mutation testing 61% (elapsed: ~1h 18m, remaining: ~49m) 647/1058 tested (529 survived, 59 timed out)
Mutation testing 61% (elapsed: ~1h 18m, remaining: ~49m) 648/1058 tested (530 survived, 59 timed out)
Mutation testing 61% (elapsed: ~1h 18m, remaining: ~49m) 650/1058 tested (532 survived, 59 timed out)
Mutation testing 61% (elapsed: ~1h 19m, remaining: ~49m) 651/1058 tested (533 survived, 59 timed out)
Mutation testing 61% (elapsed: ~1h 19m, remaining: ~49m) 653/1058 tested (535 survived, 59 timed out)
Mutation testing 61% (elapsed: ~1h 19m, remaining: ~49m) 654/1058 tested (536 survived, 59 timed out)
Mutation testing 62% (elapsed: ~1h 19m, remaining: ~48m) 656/1058 tested (538 survived, 59 timed out)
Mutation testing 62% (elapsed: ~1h 19m, remaining: ~48m) 657/1058 tested (539 survived, 59 timed out)
Mutation testing 62% (elapsed: ~1h 19m, remaining: ~48m) 659/1058 tested (541 survived, 59 timed out)
Mutation testing 62% (elapsed: ~1h 20m, remaining: ~48m) 660/1058 tested (542 survived, 59 timed out)
Mutation testing 62% (elapsed: ~1h 20m, remaining: ~48m) 661/1058 tested (543 survived, 59 timed out)
Mutation testing 62% (elapsed: ~1h 20m, remaining: ~47m) 663/1058 tested (545 survived, 59 timed out)
Mutation testing 62% (elapsed: ~1h 20m, remaining: ~47m) 664/1058 tested (546 survived, 59 timed out)
Mutation testing 62% (elapsed: ~1h 20m, remaining: ~47m) 666/1058 tested (548 survived, 59 timed out)
Mutation testing 63% (elapsed: ~1h 20m, remaining: ~47m) 667/1058 tested (549 survived, 59 timed out)
Mutation testing 63% (elapsed: ~1h 21m, remaining: ~47m) 669/1058 tested (551 survived, 59 timed out)
Mutation testing 63% (elapsed: ~1h 21m, remaining: ~47m) 670/1058 tested (552 survived, 59 timed out)
Mutation testing 63% (elapsed: ~1h 21m, remaining: ~46m) 672/1058 tested (554 survived, 59 timed out)
Mutation testing 63% (elapsed: ~1h 21m, remaining: ~46m) 673/1058 tested (555 survived, 59 timed out)
Mutation testing 63% (elapsed: ~1h 21m, remaining: ~46m) 675/1058 tested (557 survived, 59 timed out)
Mutation testing 63% (elapsed: ~1h 21m, remaining: ~46m) 676/1058 tested (558 survived, 59 timed out)
Mutation testing 64% (elapsed: ~1h 22m, remaining: ~45m) 678/1058 tested (560 survived, 59 timed out)
Mutation testing 64% (elapsed: ~1h 22m, remaining: ~45m) 679/1058 tested (561 survived, 59 timed out)
Mutation testing 64% (elapsed: ~1h 22m, remaining: ~45m) 681/1058 tested (563 survived, 59 timed out)
Mutation testing 64% (elapsed: ~1h 22m, remaining: ~45m) 682/1058 tested (564 survived, 59 timed out)
Mutation testing 64% (elapsed: ~1h 22m, remaining: ~45m) 684/1058 tested (566 survived, 59 timed out)
Mutation testing 64% (elapsed: ~1h 22m, remaining: ~45m) 685/1058 tested (567 survived, 59 timed out)
Mutation testing 64% (elapsed: ~1h 23m, remaining: ~44m) 687/1058 tested (569 survived, 59 timed out)
Mutation testing 65% (elapsed: ~1h 23m, remaining: ~44m) 688/1058 tested (570 survived, 59 timed out)
Mutation testing 65% (elapsed: ~1h 23m, remaining: ~44m) 690/1058 tested (572 survived, 59 timed out)
Mutation testing 65% (elapsed: ~1h 23m, remaining: ~44m) 691/1058 tested (573 survived, 59 timed out)
Mutation testing 65% (elapsed: ~1h 23m, remaining: ~44m) 693/1058 tested (575 survived, 59 timed out)
Mutation testing 65% (elapsed: ~1h 23m, remaining: ~43m) 694/1058 tested (576 survived, 59 timed out)
Mutation testing 65% (elapsed: ~1h 24m, remaining: ~43m) 695/1058 tested (577 survived, 59 timed out)
Mutation testing 65% (elapsed: ~1h 24m, remaining: ~43m) 697/1058 tested (578 survived, 59 timed out)
Mutation testing 65% (elapsed: ~1h 24m, remaining: ~43m) 698/1058 tested (578 survived, 59 timed out)
Mutation testing 66% (elapsed: ~1h 24m, remaining: ~43m) 700/1058 tested (580 survived, 59 timed out)
Mutation testing 66% (elapsed: ~1h 24m, remaining: ~43m) 701/1058 tested (581 survived, 59 timed out)
Mutation testing 66% (elapsed: ~1h 24m, remaining: ~42m) 703/1058 tested (583 survived, 59 timed out)
Mutation testing 66% (elapsed: ~1h 25m, remaining: ~42m) 704/1058 tested (584 survived, 59 timed out)
Mutation testing 66% (elapsed: ~1h 25m, remaining: ~42m) 706/1058 tested (586 survived, 59 timed out)
Mutation testing 66% (elapsed: ~1h 25m, remaining: ~42m) 707/1058 tested (587 survived, 59 timed out)
Mutation testing 66% (elapsed: ~1h 25m, remaining: ~42m) 708/1058 tested (588 survived, 59 timed out)
Mutation testing 67% (elapsed: ~1h 25m, remaining: ~41m) 710/1058 tested (590 survived, 59 timed out)
Mutation testing 67% (elapsed: ~1h 25m, remaining: ~41m) 711/1058 tested (591 survived, 59 timed out)
Mutation testing 67% (elapsed: ~1h 26m, remaining: ~41m) 713/1058 tested (593 survived, 59 timed out)
Mutation testing 67% (elapsed: ~1h 26m, remaining: ~41m) 714/1058 tested (594 survived, 59 timed out)
Mutation testing 67% (elapsed: ~1h 26m, remaining: ~41m) 716/1058 tested (596 survived, 59 timed out)
Mutation testing 67% (elapsed: ~1h 26m, remaining: ~41m) 717/1058 tested (597 survived, 59 timed out)
Mutation testing 67% (elapsed: ~1h 26m, remaining: ~40m) 719/1058 tested (599 survived, 59 timed out)
Mutation testing 68% (elapsed: ~1h 26m, remaining: ~40m) 720/1058 tested (600 survived, 59 timed out)
Mutation testing 68% (elapsed: ~1h 27m, remaining: ~40m) 722/1058 tested (602 survived, 59 timed out)
Mutation testing 68% (elapsed: ~1h 27m, remaining: ~40m) 723/1058 tested (603 survived, 59 timed out)
Mutation testing 68% (elapsed: ~1h 27m, remaining: ~40m) 725/1058 tested (605 survived, 59 timed out)
Mutation testing 68% (elapsed: ~1h 27m, remaining: ~40m) 726/1058 tested (606 survived, 59 timed out)
Mutation testing 68% (elapsed: ~1h 27m, remaining: ~39m) 728/1058 tested (608 survived, 59 timed out)
Mutation testing 68% (elapsed: ~1h 27m, remaining: ~39m) 729/1058 tested (609 survived, 59 timed out)
Mutation testing 69% (elapsed: ~1h 28m, remaining: ~39m) 731/1058 tested (611 survived, 59 timed out)
Mutation testing 69% (elapsed: ~1h 28m, remaining: ~39m) 732/1058 tested (612 survived, 59 timed out)
Mutation testing 69% (elapsed: ~1h 28m, remaining: ~38m) 734/1058 tested (614 survived, 59 timed out)
Mutation testing 69% (elapsed: ~1h 28m, remaining: ~38m) 736/1058 tested (615 survived, 59 timed out)
Mutation testing 69% (elapsed: ~1h 28m, remaining: ~38m) 736/1058 tested (615 survived, 59 timed out)
Mutation testing 69% (elapsed: ~1h 28m, remaining: ~38m) 737/1058 tested (615 survived, 60 timed out)
Mutation testing 69% (elapsed: ~1h 29m, remaining: ~38m) 738/1058 tested (615 survived, 61 timed out)
Mutation testing 69% (elapsed: ~1h 29m, remaining: ~38m) 739/1058 tested (616 survived, 61 timed out)
Mutation testing 70% (elapsed: ~1h 29m, remaining: ~38m) 741/1058 tested (618 survived, 61 timed out)
Mutation testing 70% (elapsed: ~1h 29m, remaining: ~37m) 743/1058 tested (619 survived, 61 timed out)
Mutation testing 70% (elapsed: ~1h 29m, remaining: ~37m) 745/1058 tested (621 survived, 61 timed out)
Mutation testing 70% (elapsed: ~1h 29m, remaining: ~37m) 746/1058 tested (621 survived, 61 timed out)
Mutation testing 70% (elapsed: ~1h 30m, remaining: ~37m) 747/1058 tested (621 survived, 62 timed out)
Mutation testing 70% (elapsed: ~1h 30m, remaining: ~37m) 747/1058 tested (621 survived, 62 timed out)
Mutation testing 70% (elapsed: ~1h 30m, remaining: ~37m) 749/1058 tested (622 survived, 63 timed out)
Mutation testing 70% (elapsed: ~1h 30m, remaining: ~37m) 750/1058 tested (623 survived, 63 timed out)
Mutation testing 71% (elapsed: ~1h 30m, remaining: ~36m) 752/1058 tested (625 survived, 63 timed out)
Mutation testing 71% (elapsed: ~1h 30m, remaining: ~36m) 753/1058 tested (626 survived, 63 timed out)
Mutation testing 71% (elapsed: ~1h 31m, remaining: ~36m) 755/1058 tested (628 survived, 63 timed out)
Mutation testing 71% (elapsed: ~1h 31m, remaining: ~36m) 756/1058 tested (629 survived, 63 timed out)
Mutation testing 71% (elapsed: ~1h 31m, remaining: ~36m) 758/1058 tested (631 survived, 63 timed out)
Mutation testing 71% (elapsed: ~1h 31m, remaining: ~36m) 759/1058 tested (632 survived, 63 timed out)
Mutation testing 71% (elapsed: ~1h 31m, remaining: ~35m) 761/1058 tested (634 survived, 63 timed out)
Mutation testing 72% (elapsed: ~1h 31m, remaining: ~35m) 762/1058 tested (635 survived, 63 timed out)
Mutation testing 72% (elapsed: ~1h 32m, remaining: ~35m) 764/1058 tested (636 survived, 63 timed out)
Mutation testing 72% (elapsed: ~1h 32m, remaining: ~35m) 766/1058 tested (638 survived, 63 timed out)
Mutation testing 72% (elapsed: ~1h 32m, remaining: ~35m) 767/1058 tested (638 survived, 63 timed out)
Mutation testing 72% (elapsed: ~1h 32m, remaining: ~34m) 769/1058 tested (638 survived, 63 timed out)
Mutation testing 72% (elapsed: ~1h 32m, remaining: ~34m) 770/1058 tested (639 survived, 63 timed out)
Mutation testing 72% (elapsed: ~1h 32m, remaining: ~34m) 772/1058 tested (641 survived, 63 timed out)
Mutation testing 73% (elapsed: ~1h 33m, remaining: ~34m) 773/1058 tested (642 survived, 63 timed out)
Mutation testing 73% (elapsed: ~1h 33m, remaining: ~34m) 775/1058 tested (644 survived, 63 timed out)
Mutation testing 73% (elapsed: ~1h 33m, remaining: ~33m) 776/1058 tested (645 survived, 63 timed out)
Mutation testing 73% (elapsed: ~1h 33m, remaining: ~33m) 778/1058 tested (647 survived, 63 timed out)
Mutation testing 73% (elapsed: ~1h 33m, remaining: ~33m) 779/1058 tested (648 survived, 63 timed out)
Mutation testing 73% (elapsed: ~1h 33m, remaining: ~33m) 781/1058 tested (650 survived, 63 timed out)
Mutation testing 73% (elapsed: ~1h 34m, remaining: ~33m) 782/1058 tested (651 survived, 63 timed out)
Mutation testing 74% (elapsed: ~1h 34m, remaining: ~32m) 784/1058 tested (653 survived, 63 timed out)
Mutation testing 74% (elapsed: ~1h 34m, remaining: ~32m) 785/1058 tested (654 survived, 63 timed out)
Mutation testing 74% (elapsed: ~1h 34m, remaining: ~32m) 786/1058 tested (655 survived, 63 timed out)
Mutation testing 74% (elapsed: ~1h 34m, remaining: ~32m) 788/1058 tested (657 survived, 63 timed out)
Mutation testing 74% (elapsed: ~1h 34m, remaining: ~32m) 789/1058 tested (658 survived, 63 timed out)
Mutation testing 74% (elapsed: ~1h 35m, remaining: ~32m) 791/1058 tested (660 survived, 63 timed out)
Mutation testing 74% (elapsed: ~1h 35m, remaining: ~31m) 792/1058 tested (661 survived, 63 timed out)
Mutation testing 75% (elapsed: ~1h 35m, remaining: ~31m) 794/1058 tested (663 survived, 63 timed out)
Mutation testing 75% (elapsed: ~1h 35m, remaining: ~31m) 795/1058 tested (664 survived, 63 timed out)
Mutation testing 75% (elapsed: ~1h 35m, remaining: ~31m) 797/1058 tested (666 survived, 63 timed out)
Mutation testing 75% (elapsed: ~1h 35m, remaining: ~31m) 798/1058 tested (667 survived, 63 timed out)
Mutation testing 75% (elapsed: ~1h 36m, remaining: ~30m) 800/1058 tested (669 survived, 63 timed out)
Mutation testing 75% (elapsed: ~1h 36m, remaining: ~30m) 801/1058 tested (670 survived, 63 timed out)
Mutation testing 75% (elapsed: ~1h 36m, remaining: ~30m) 803/1058 tested (672 survived, 63 timed out)
Mutation testing 75% (elapsed: ~1h 36m, remaining: ~30m) 804/1058 tested (673 survived, 63 timed out)
Mutation testing 76% (elapsed: ~1h 36m, remaining: ~30m) 806/1058 tested (675 survived, 63 timed out)
Mutation testing 76% (elapsed: ~1h 36m, remaining: ~30m) 807/1058 tested (676 survived, 63 timed out)
Mutation testing 76% (elapsed: ~1h 37m, remaining: ~29m) 809/1058 tested (678 survived, 63 timed out)
Mutation testing 76% (elapsed: ~1h 37m, remaining: ~29m) 810/1058 tested (679 survived, 63 timed out)
Mutation testing 76% (elapsed: ~1h 37m, remaining: ~29m) 812/1058 tested (681 survived, 63 timed out)
Mutation testing 76% (elapsed: ~1h 37m, remaining: ~29m) 813/1058 tested (682 survived, 63 timed out)
Mutation testing 77% (elapsed: ~1h 37m, remaining: ~29m) 815/1058 tested (684 survived, 63 timed out)
Mutation testing 77% (elapsed: ~1h 37m, remaining: ~29m) 816/1058 tested (685 survived, 63 timed out)
Mutation testing 77% (elapsed: ~1h 38m, remaining: ~28m) 818/1058 tested (687 survived, 63 timed out)
Mutation testing 77% (elapsed: ~1h 38m, remaining: ~28m) 819/1058 tested (688 survived, 63 timed out)
Mutation testing 77% (elapsed: ~1h 38m, remaining: ~28m) 820/1058 tested (689 survived, 63 timed out)
Mutation testing 77% (elapsed: ~1h 38m, remaining: ~28m) 822/1058 tested (691 survived, 63 timed out)
Mutation testing 77% (elapsed: ~1h 38m, remaining: ~28m) 823/1058 tested (692 survived, 63 timed out)
Mutation testing 77% (elapsed: ~1h 38m, remaining: ~27m) 825/1058 tested (694 survived, 63 timed out)
Mutation testing 78% (elapsed: ~1h 39m, remaining: ~27m) 826/1058 tested (695 survived, 63 timed out)
Mutation testing 78% (elapsed: ~1h 39m, remaining: ~27m) 828/1058 tested (697 survived, 63 timed out)
Mutation testing 78% (elapsed: ~1h 39m, remaining: ~27m) 829/1058 tested (698 survived, 63 timed out)
Mutation testing 78% (elapsed: ~1h 39m, remaining: ~27m) 831/1058 tested (700 survived, 63 timed out)
Mutation testing 78% (elapsed: ~1h 39m, remaining: ~27m) 832/1058 tested (701 survived, 63 timed out)
Mutation testing 78% (elapsed: ~1h 39m, remaining: ~26m) 834/1058 tested (703 survived, 63 timed out)
Mutation testing 78% (elapsed: ~1h 40m, remaining: ~26m) 835/1058 tested (704 survived, 63 timed out)
Mutation testing 79% (elapsed: ~1h 40m, remaining: ~26m) 837/1058 tested (706 survived, 63 timed out)
Mutation testing 79% (elapsed: ~1h 40m, remaining: ~26m) 838/1058 tested (707 survived, 63 timed out)
Mutation testing 79% (elapsed: ~1h 40m, remaining: ~26m) 840/1058 tested (709 survived, 63 timed out)
Mutation testing 79% (elapsed: ~1h 40m, remaining: ~25m) 841/1058 tested (710 survived, 63 timed out)
Mutation testing 79% (elapsed: ~1h 40m, remaining: ~25m) 843/1058 tested (712 survived, 63 timed out)
Mutation testing 79% (elapsed: ~1h 41m, remaining: ~25m) 844/1058 tested (713 survived, 63 timed out)
Mutation testing 79% (elapsed: ~1h 41m, remaining: ~25m) 846/1058 tested (715 survived, 63 timed out)
Mutation testing 80% (elapsed: ~1h 41m, remaining: ~25m) 847/1058 tested (716 survived, 63 timed out)
Mutation testing 80% (elapsed: ~1h 41m, remaining: ~24m) 849/1058 tested (718 survived, 63 timed out)
Mutation testing 80% (elapsed: ~1h 41m, remaining: ~24m) 850/1058 tested (719 survived, 63 timed out)
Mutation testing 80% (elapsed: ~1h 41m, remaining: ~24m) 851/1058 tested (720 survived, 63 timed out)
Mutation testing 80% (elapsed: ~1h 42m, remaining: ~24m) 853/1058 tested (722 survived, 63 timed out)
Mutation testing 80% (elapsed: ~1h 42m, remaining: ~24m) 854/1058 tested (723 survived, 63 timed out)
Mutation testing 80% (elapsed: ~1h 42m, remaining: ~24m) 856/1058 tested (725 survived, 63 timed out)
Mutation testing 81% (elapsed: ~1h 42m, remaining: ~24m) 857/1058 tested (726 survived, 63 timed out)
Mutation testing 81% (elapsed: ~1h 42m, remaining: ~23m) 859/1058 tested (728 survived, 63 timed out)
Mutation testing 81% (elapsed: ~1h 42m, remaining: ~23m) 860/1058 tested (729 survived, 63 timed out)
Mutation testing 81% (elapsed: ~1h 43m, remaining: ~23m) 862/1058 tested (731 survived, 63 timed out)
Mutation testing 81% (elapsed: ~1h 43m, remaining: ~23m) 863/1058 tested (732 survived, 63 timed out)
Mutation testing 81% (elapsed: ~1h 43m, remaining: ~23m) 865/1058 tested (734 survived, 63 timed out)
Mutation testing 81% (elapsed: ~1h 43m, remaining: ~22m) 866/1058 tested (735 survived, 63 timed out)
Mutation testing 82% (elapsed: ~1h 43m, remaining: ~22m) 868/1058 tested (737 survived, 63 timed out)
Mutation testing 82% (elapsed: ~1h 43m, remaining: ~22m) 869/1058 tested (738 survived, 63 timed out)
Mutation testing 82% (elapsed: ~1h 44m, remaining: ~22m) 871/1058 tested (740 survived, 63 timed out)
Mutation testing 82% (elapsed: ~1h 44m, remaining: ~22m) 872/1058 tested (741 survived, 63 timed out)
Mutation testing 82% (elapsed: ~1h 44m, remaining: ~21m) 874/1058 tested (743 survived, 63 timed out)
Mutation testing 82% (elapsed: ~1h 44m, remaining: ~21m) 875/1058 tested (744 survived, 63 timed out)
Mutation testing 82% (elapsed: ~1h 44m, remaining: ~21m) 877/1058 tested (746 survived, 63 timed out)
Mutation testing 82% (elapsed: ~1h 44m, remaining: ~21m) 878/1058 tested (747 survived, 63 timed out)
Mutation testing 83% (elapsed: ~1h 45m, remaining: ~21m) 880/1058 tested (749 survived, 63 timed out)
Mutation testing 83% (elapsed: ~1h 45m, remaining: ~21m) 881/1058 tested (750 survived, 63 timed out)
Mutation testing 83% (elapsed: ~1h 45m, remaining: ~21m) 882/1058 tested (751 survived, 63 timed out)
Mutation testing 83% (elapsed: ~1h 45m, remaining: ~20m) 884/1058 tested (753 survived, 63 timed out)
Mutation testing 83% (elapsed: ~1h 45m, remaining: ~20m) 885/1058 tested (754 survived, 63 timed out)
Mutation testing 83% (elapsed: ~1h 45m, remaining: ~20m) 887/1058 tested (756 survived, 63 timed out)
Mutation testing 83% (elapsed: ~1h 46m, remaining: ~20m) 888/1058 tested (757 survived, 63 timed out)
Mutation testing 84% (elapsed: ~1h 46m, remaining: ~20m) 890/1058 tested (759 survived, 63 timed out)
Mutation testing 84% (elapsed: ~1h 46m, remaining: ~19m) 891/1058 tested (760 survived, 63 timed out)
Mutation testing 84% (elapsed: ~1h 46m, remaining: ~19m) 893/1058 tested (762 survived, 63 timed out)
Mutation testing 84% (elapsed: ~1h 46m, remaining: ~19m) 894/1058 tested (763 survived, 63 timed out)
Mutation testing 84% (elapsed: ~1h 46m, remaining: ~19m) 896/1058 tested (765 survived, 63 timed out)
Mutation testing 84% (elapsed: ~1h 47m, remaining: ~19m) 897/1058 tested (766 survived, 63 timed out)
Mutation testing 84% (elapsed: ~1h 47m, remaining: ~18m) 899/1058 tested (768 survived, 63 timed out)
Mutation testing 85% (elapsed: ~1h 47m, remaining: ~18m) 900/1058 tested (769 survived, 63 timed out)
Mutation testing 85% (elapsed: ~1h 47m, remaining: ~18m) 902/1058 tested (771 survived, 63 timed out)
Mutation testing 85% (elapsed: ~1h 47m, remaining: ~18m) 903/1058 tested (772 survived, 63 timed out)
Mutation testing 85% (elapsed: ~1h 47m, remaining: ~18m) 905/1058 tested (774 survived, 63 timed out)
Mutation testing 85% (elapsed: ~1h 48m, remaining: ~18m) 906/1058 tested (775 survived, 63 timed out)
Mutation testing 85% (elapsed: ~1h 48m, remaining: ~17m) 908/1058 tested (777 survived, 63 timed out)
Mutation testing 85% (elapsed: ~1h 48m, remaining: ~17m) 909/1058 tested (778 survived, 63 timed out)
Mutation testing 86% (elapsed: ~1h 48m, remaining: ~17m) 911/1058 tested (780 survived, 63 timed out)
Mutation testing 86% (elapsed: ~1h 48m, remaining: ~17m) 912/1058 tested (781 survived, 63 timed out)
Mutation testing 86% (elapsed: ~1h 48m, remaining: ~17m) 914/1058 tested (783 survived, 63 timed out)
Mutation testing 86% (elapsed: ~1h 49m, remaining: ~17m) 915/1058 tested (784 survived, 63 timed out)
Mutation testing 86% (elapsed: ~1h 49m, remaining: ~16m) 916/1058 tested (785 survived, 63 timed out)
Mutation testing 86% (elapsed: ~1h 49m, remaining: ~16m) 918/1058 tested (787 survived, 63 timed out)
Mutation testing 86% (elapsed: ~1h 49m, remaining: ~16m) 919/1058 tested (788 survived, 63 timed out)
Mutation testing 87% (elapsed: ~1h 49m, remaining: ~16m) 921/1058 tested (790 survived, 63 timed out)
Mutation testing 87% (elapsed: ~1h 49m, remaining: ~16m) 922/1058 tested (791 survived, 63 timed out)
Mutation testing 87% (elapsed: ~1h 50m, remaining: ~15m) 924/1058 tested (793 survived, 63 timed out)
Mutation testing 87% (elapsed: ~1h 50m, remaining: ~15m) 925/1058 tested (794 survived, 63 timed out)
Mutation testing 87% (elapsed: ~1h 50m, remaining: ~15m) 927/1058 tested (796 survived, 63 timed out)
Mutation testing 87% (elapsed: ~1h 50m, remaining: ~15m) 928/1058 tested (797 survived, 63 timed out)
Mutation testing 87% (elapsed: ~1h 50m, remaining: ~15m) 930/1058 tested (799 survived, 63 timed out)
Mutation testing 87% (elapsed: ~1h 50m, remaining: ~15m) 931/1058 tested (800 survived, 63 timed out)
Mutation testing 88% (elapsed: ~1h 51m, remaining: ~14m) 933/1058 tested (802 survived, 63 timed out)
Mutation testing 88% (elapsed: ~1h 51m, remaining: ~14m) 934/1058 tested (803 survived, 63 timed out)
Mutation testing 88% (elapsed: ~1h 51m, remaining: ~14m) 936/1058 tested (805 survived, 63 timed out)
Mutation testing 88% (elapsed: ~1h 51m, remaining: ~14m) 937/1058 tested (806 survived, 63 timed out)
Mutation testing 88% (elapsed: ~1h 51m, remaining: ~14m) 939/1058 tested (808 survived, 63 timed out)
Mutation testing 88% (elapsed: ~1h 51m, remaining: ~14m) 940/1058 tested (809 survived, 63 timed out)
Mutation testing 89% (elapsed: ~1h 52m, remaining: ~13m) 942/1058 tested (811 survived, 63 timed out)
Mutation testing 89% (elapsed: ~1h 52m, remaining: ~13m) 943/1058 tested (812 survived, 63 timed out)
Mutation testing 89% (elapsed: ~1h 52m, remaining: ~13m) 945/1058 tested (814 survived, 63 timed out)
Mutation testing 89% (elapsed: ~1h 52m, remaining: ~13m) 946/1058 tested (815 survived, 63 timed out)
Mutation testing 89% (elapsed: ~1h 52m, remaining: ~13m) 947/1058 tested (816 survived, 63 timed out)
Mutation testing 89% (elapsed: ~1h 52m, remaining: ~12m) 949/1058 tested (818 survived, 63 timed out)
Mutation testing 89% (elapsed: ~1h 53m, remaining: ~12m) 950/1058 tested (819 survived, 63 timed out)
Mutation testing 89% (elapsed: ~1h 53m, remaining: ~12m) 952/1058 tested (821 survived, 63 timed out)
Mutation testing 90% (elapsed: ~1h 53m, remaining: ~12m) 953/1058 tested (822 survived, 63 timed out)
Mutation testing 90% (elapsed: ~1h 53m, remaining: ~12m) 955/1058 tested (824 survived, 63 timed out)
Mutation testing 90% (elapsed: ~1h 53m, remaining: ~12m) 956/1058 tested (825 survived, 63 timed out)
Mutation testing 90% (elapsed: ~1h 53m, remaining: ~11m) 958/1058 tested (827 survived, 63 timed out)
Mutation testing 90% (elapsed: ~1h 54m, remaining: ~11m) 959/1058 tested (828 survived, 63 timed out)
Mutation testing 90% (elapsed: ~1h 54m, remaining: ~11m) 961/1058 tested (830 survived, 63 timed out)
Mutation testing 90% (elapsed: ~1h 54m, remaining: ~11m) 962/1058 tested (831 survived, 63 timed out)
Mutation testing 91% (elapsed: ~1h 54m, remaining: ~11m) 964/1058 tested (833 survived, 63 timed out)
Mutation testing 91% (elapsed: ~1h 54m, remaining: ~11m) 965/1058 tested (834 survived, 63 timed out)
Mutation testing 91% (elapsed: ~1h 54m, remaining: ~10m) 967/1058 tested (836 survived, 63 timed out)
Mutation testing 91% (elapsed: ~1h 55m, remaining: ~10m) 968/1058 tested (837 survived, 63 timed out)
Mutation testing 91% (elapsed: ~1h 55m, remaining: ~10m) 970/1058 tested (839 survived, 63 timed out)
Mutation testing 91% (elapsed: ~1h 55m, remaining: ~10m) 971/1058 tested (840 survived, 63 timed out)
Mutation testing 91% (elapsed: ~1h 55m, remaining: ~10m) 973/1058 tested (842 survived, 63 timed out)
Mutation testing 92% (elapsed: ~1h 55m, remaining: ~9m) 974/1058 tested (843 survived, 63 timed out)
Mutation testing 92% (elapsed: ~1h 55m, remaining: ~9m) 976/1058 tested (845 survived, 63 timed out)
Mutation testing 92% (elapsed: ~1h 56m, remaining: ~9m) 977/1058 tested (846 survived, 63 timed out)
Mutation testing 92% (elapsed: ~1h 56m, remaining: ~9m) 978/1058 tested (847 survived, 63 timed out)
Mutation testing 92% (elapsed: ~1h 56m, remaining: ~9m) 980/1058 tested (849 survived, 63 timed out)
Mutation testing 92% (elapsed: ~1h 56m, remaining: ~9m) 981/1058 tested (850 survived, 63 timed out)
Mutation testing 92% (elapsed: ~1h 56m, remaining: ~8m) 983/1058 tested (852 survived, 63 timed out)
Mutation testing 93% (elapsed: ~1h 56m, remaining: ~8m) 984/1058 tested (853 survived, 63 timed out)
Mutation testing 93% (elapsed: ~1h 57m, remaining: ~8m) 986/1058 tested (855 survived, 63 timed out)
Mutation testing 93% (elapsed: ~1h 57m, remaining: ~8m) 987/1058 tested (856 survived, 63 timed out)
Mutation testing 93% (elapsed: ~1h 57m, remaining: ~8m) 989/1058 tested (858 survived, 63 timed out)
Mutation testing 93% (elapsed: ~1h 57m, remaining: ~8m) 990/1058 tested (859 survived, 63 timed out)
Mutation testing 93% (elapsed: ~1h 57m, remaining: ~7m) 992/1058 tested (861 survived, 63 timed out)
Mutation testing 93% (elapsed: ~1h 57m, remaining: ~7m) 993/1058 tested (862 survived, 63 timed out)
Mutation testing 94% (elapsed: ~1h 58m, remaining: ~7m) 995/1058 tested (864 survived, 63 timed out)
Mutation testing 94% (elapsed: ~1h 58m, remaining: ~7m) 996/1058 tested (865 survived, 63 timed out)
Mutation testing 94% (elapsed: ~1h 58m, remaining: ~7m) 998/1058 tested (867 survived, 63 timed out)
Mutation testing 94% (elapsed: ~1h 58m, remaining: ~6m) 999/1058 tested (868 survived, 63 timed out)
Mutation testing 94% (elapsed: ~1h 58m, remaining: ~6m) 1001/1058 tested (870 survived, 63 timed out)
Mutation testing 94% (elapsed: ~1h 58m, remaining: ~6m) 1002/1058 tested (871 survived, 63 timed out)
Mutation testing 94% (elapsed: ~1h 59m, remaining: ~6m) 1004/1058 tested (873 survived, 63 timed out)
Mutation testing 94% (elapsed: ~1h 59m, remaining: ~6m) 1005/1058 tested (874 survived, 63 timed out)
Mutation testing 95% (elapsed: ~1h 59m, remaining: ~6m) 1006/1058 tested (875 survived, 63 timed out)
Mutation testing 95% (elapsed: ~1h 59m, remaining: ~5m) 1008/1058 tested (877 survived, 63 timed out)
Mutation testing 95% (elapsed: ~1h 59m, remaining: ~5m) 1009/1058 tested (878 survived, 63 timed out)
Mutation testing 95% (elapsed: ~1h 59m, remaining: ~5m) 1011/1058 tested (880 survived, 63 timed out)
Mutation testing 95% (elapsed: ~2h 0m, remaining: ~5m) 1012/1058 tested (881 survived, 63 timed out)
Mutation testing 95% (elapsed: ~2h 0m, remaining: ~5m) 1014/1058 tested (883 survived, 63 timed out)
Mutation testing 95% (elapsed: ~2h 0m, remaining: ~5m) 1015/1058 tested (884 survived, 63 timed out)
Mutation testing 96% (elapsed: ~2h 0m, remaining: ~4m) 1017/1058 tested (886 survived, 63 timed out)
Mutation testing 96% (elapsed: ~2h 0m, remaining: ~4m) 1018/1058 tested (887 survived, 63 timed out)
Mutation testing 96% (elapsed: ~2h 0m, remaining: ~4m) 1020/1058 tested (889 survived, 63 timed out)
Mutation testing 96% (elapsed: ~2h 1m, remaining: ~4m) 1021/1058 tested (890 survived, 63 timed out)
Mutation testing 96% (elapsed: ~2h 1m, remaining: ~4m) 1023/1058 tested (892 survived, 63 timed out)
Mutation testing 96% (elapsed: ~2h 1m, remaining: ~4m) 1024/1058 tested (893 survived, 63 timed out)
Mutation testing 96% (elapsed: ~2h 1m, remaining: ~3m) 1026/1058 tested (895 survived, 63 timed out)
Mutation testing 97% (elapsed: ~2h 1m, remaining: ~3m) 1027/1058 tested (896 survived, 63 timed out)
Mutation testing 97% (elapsed: ~2h 1m, remaining: ~3m) 1029/1058 tested (898 survived, 63 timed out)
Mutation testing 97% (elapsed: ~2h 2m, remaining: ~3m) 1030/1058 tested (899 survived, 63 timed out)
Mutation testing 97% (elapsed: ~2h 2m, remaining: ~3m) 1032/1058 tested (901 survived, 63 timed out)
Mutation testing 97% (elapsed: ~2h 2m, remaining: ~2m) 1033/1058 tested (902 survived, 63 timed out)
Mutation testing 97% (elapsed: ~2h 2m, remaining: ~2m) 1035/1058 tested (904 survived, 63 timed out)
Mutation testing 97% (elapsed: ~2h 2m, remaining: ~2m) 1036/1058 tested (905 survived, 63 timed out)
Mutation testing 98% (elapsed: ~2h 2m, remaining: ~2m) 1038/1058 tested (907 survived, 63 timed out)
Mutation testing 98% (elapsed: ~2h 3m, remaining: ~2m) 1039/1058 tested (908 survived, 63 timed out)
Mutation testing 98% (elapsed: ~2h 3m, remaining: ~2m) 1040/1058 tested (909 survived, 63 timed out)
Mutation testing 98% (elapsed: ~2h 3m, remaining: ~1m) 1042/1058 tested (911 survived, 63 timed out)
Mutation testing 98% (elapsed: ~2h 3m, remaining: ~1m) 1043/1058 tested (912 survived, 63 timed out)
Mutation testing 98% (elapsed: ~2h 3m, remaining: ~1m) 1045/1058 tested (914 survived, 63 timed out)
Mutation testing 98% (elapsed: ~2h 3m, remaining: ~1m) 1046/1058 tested (915 survived, 63 timed out)
Mutation testing 99% (elapsed: ~2h 4m, remaining: ~1m) 1048/1058 tested (917 survived, 63 timed out)
Mutation testing 99% (elapsed: ~2h 4m, remaining: ~1m) 1049/1058 tested (918 survived, 63 timed out)
Mutation testing 99% (elapsed: ~2h 4m, remaining: <1m) 1051/1058 tested (920 survived, 63 timed out)
Mutation testing 99% (elapsed: ~2h 4m, remaining: <1m) 1052/1058 tested (921 survived, 63 timed out)
Mutation testing 99% (elapsed: ~2h 4m, remaining: <1m) 1054/1058 tested (923 survived, 63 timed out)
Mutation testing 99% (elapsed: ~2h 4m, remaining: <1m) 1055/1058 tested (924 survived, 63 timed out)
Mutation testing 99% (elapsed: ~2h 5m, remaining: <1m) 1057/1058 tested (926 survived, 63 timed out)

All tests
  ✓ All tests (killed 68)

[Survived] ConditionalExpression
q.js:38:9
-       if (typeof bootstrap === "function") {
+       if (false) {

[Survived] StringLiteral
q.js:38:30
-       if (typeof bootstrap === "function") {
+       if (typeof bootstrap === "") {

[Survived] BlockStatement
q.js:38:42
-       if (typeof bootstrap === "function") {
-           bootstrap("promise", definition);
-       // CommonJS
-       } else if (typeof exports === "object" && typeof module === "object") {
+       if (typeof bootstrap === "function") {} else if (typeof exports === "object" && typeof module === "object") {

[Survived] StringLiteral
q.js:39:19
-           bootstrap("promise", definition);
+           bootstrap("", definition);

[Survived] ConditionalExpression
q.js:42:16
-       } else if (typeof exports === "object" && typeof module === "object") {
+       } else if (true) {

[Survived] LogicalOperator
q.js:42:16
-       } else if (typeof exports === "object" && typeof module === "object") {
+       } else if (typeof exports === "object" || typeof module === "object") {

[Survived] ConditionalExpression
q.js:42:16
-       } else if (typeof exports === "object" && typeof module === "object") {
+       } else if (true && typeof module === "object") {

[Survived] ConditionalExpression
q.js:42:47
-       } else if (typeof exports === "object" && typeof module === "object") {
+       } else if (typeof exports === "object" && true) {

[Survived] ConditionalExpression
q.js:46:16
-       } else if (typeof define === "function" && define.amd) {
+       } else if (true) {

[Survived] ConditionalExpression
q.js:46:16
-       } else if (typeof define === "function" && define.amd) {
+       } else if (false) {

[Survived] LogicalOperator
q.js:46:16
-       } else if (typeof define === "function" && define.amd) {
+       } else if (typeof define === "function" || define.amd) {

[Survived] ConditionalExpression
q.js:46:16
-       } else if (typeof define === "function" && define.amd) {
+       } else if (true && define.amd) {

[Survived] EqualityOperator
q.js:46:16
-       } else if (typeof define === "function" && define.amd) {
+       } else if (typeof define !== "function" && define.amd) {

[Survived] StringLiteral
q.js:46:34
-       } else if (typeof define === "function" && define.amd) {
+       } else if (typeof define === "" && define.amd) {

[Survived] BlockStatement
q.js:46:60
-       } else if (typeof define === "function" && define.amd) {
-           define(definition);
-       // SES (Secure EcmaScript)
-       } else if (typeof ses !== "undefined") {
+       } else if (typeof define === "function" && define.amd) {} else if (typeof ses !== "undefined") {

[Survived] ConditionalExpression
q.js:50:16
-       } else if (typeof ses !== "undefined") {
+       } else if (true) {

[Survived] ConditionalExpression
q.js:50:16
-       } else if (typeof ses !== "undefined") {
+       } else if (false) {

[Survived] EqualityOperator
q.js:50:16
-       } else if (typeof ses !== "undefined") {
+       } else if (typeof ses === "undefined") {

[Survived] StringLiteral
q.js:50:31
-       } else if (typeof ses !== "undefined") {
+       } else if (typeof ses !== "") {

[Survived] BlockStatement
q.js:50:44
-       } else if (typeof ses !== "undefined") {
-           if (!ses.ok()) {
-               return;
-           } else {
-               ses.makeQ = definition;
-           }
-       // <script>
-       } else if (typeof window !== "undefined" || typeof self !== "undefined") {
+       } else if (typeof ses !== "undefined") {} else if (typeof window !== "undefined" || typeof self !== "undefined") {

[Survived] BooleanLiteral
q.js:51:13
-           if (!ses.ok()) {
+           if (ses.ok()) {

[Survived] ConditionalExpression
q.js:51:13
-           if (!ses.ok()) {
+           if (true) {

[Survived] ConditionalExpression
q.js:51:13
-           if (!ses.ok()) {
+           if (false) {

[Survived] BlockStatement
q.js:51:24
-           if (!ses.ok()) {
-               return;
-           } else {
+           if (!ses.ok()) {} else {

[Survived] BlockStatement
q.js:53:16
-           } else {
-               ses.makeQ = definition;
-           }
+           } else {}

[Survived] ConditionalExpression
q.js:58:16
-       } else if (typeof window !== "undefined" || typeof self !== "undefined") {
+       } else if (true) {

[Survived] ConditionalExpression
q.js:58:16
-       } else if (typeof window !== "undefined" || typeof self !== "undefined") {
+       } else if (false) {

[Survived] LogicalOperator
q.js:58:16
-       } else if (typeof window !== "undefined" || typeof self !== "undefined") {
+       } else if (typeof window !== "undefined" && typeof self !== "undefined") {

[Survived] ConditionalExpression
q.js:58:16
-       } else if (typeof window !== "undefined" || typeof self !== "undefined") {
+       } else if (false || typeof self !== "undefined") {

[Survived] EqualityOperator
q.js:58:16
-       } else if (typeof window !== "undefined" || typeof self !== "undefined") {
+       } else if (typeof window === "undefined" || typeof self !== "undefined") {

[Survived] StringLiteral
q.js:58:34
-       } else if (typeof window !== "undefined" || typeof self !== "undefined") {
+       } else if (typeof window !== "" || typeof self !== "undefined") {

[Survived] ConditionalExpression
q.js:58:49
-       } else if (typeof window !== "undefined" || typeof self !== "undefined") {
+       } else if (typeof window !== "undefined" || false) {

[Survived] EqualityOperator
q.js:58:49
-       } else if (typeof window !== "undefined" || typeof self !== "undefined") {
+       } else if (typeof window !== "undefined" || typeof self === "undefined") {

[Survived] StringLiteral
q.js:58:65
-       } else if (typeof window !== "undefined" || typeof self !== "undefined") {
+       } else if (typeof window !== "undefined" || typeof self !== "") {

[Survived] BlockStatement
q.js:58:78
-       } else if (typeof window !== "undefined" || typeof self !== "undefined") {
-           // Prefer window over self for add-on scripts. Use self for
-           // non-windowed contexts.
-           var global = typeof window !== "undefined" ? window : self;
-           // Get the `window` object, save the previous Q global
-           // and initialize Q as a global.
-           var previousQ = global.Q;
-           global.Q = definition();
-           // Add a noConflict function so Q can be removed from the
-           // global namespace.
-           global.Q.noConflict = function () {
-               global.Q = previousQ;
-               return this;
-           };
-       } else {
+       } else if (typeof window !== "undefined" || typeof self !== "undefined") {} else {

[Survived] ConditionalExpression
q.js:61:22
-           var global = typeof window !== "undefined" ? window : self;
+           var global = true ? window : self;

[Survived] ConditionalExpression
q.js:61:22
-           var global = typeof window !== "undefined" ? window : self;
+           var global = false ? window : self;

[Survived] EqualityOperator
q.js:61:22
-           var global = typeof window !== "undefined" ? window : self;
+           var global = typeof window === "undefined" ? window : self;

[Survived] StringLiteral
q.js:61:40
-           var global = typeof window !== "undefined" ? window : self;
+           var global = typeof window !== "" ? window : self;

[Survived] BlockStatement
q.js:70:43
-           global.Q.noConflict = function () {
-               global.Q = previousQ;
-               return this;
-           };
+           global.Q.noConflict = function () {};

[Survived] BlockStatement
q.js:75:12
-       } else {
-           throw new Error("This environment was not anticipated by Q. Please file a bug.");
-       }
+       } else {}

[Survived] StringLiteral
q.js:76:25
-           throw new Error("This environment was not anticipated by Q. Please file a bug.");
+           throw new Error("");

[Survived] BooleanLiteral
q.js:82:17
-   var hasStacks = false;
+   var hasStacks = true;

[Survived] BlockStatement
q.js:83:5
-   try {
-       throw new Error();
-   } catch (e) {
+   try {} catch (e) {

[Survived] BlockStatement
q.js:85:13
-   } catch (e) {
-       hasStacks = !!e.stack;
-   }
+   } catch (e) {}

[Survived] BooleanLiteral
q.js:86:17
-       hasStacks = !!e.stack;
+       hasStacks = !e.stack;

[Survived] BooleanLiteral
q.js:86:18
-       hasStacks = !!e.stack;
+       hasStacks = !e.stack;

[Survived] ObjectLiteral
q.js:103:16
-       var head = {task: void 0, next: null};
+       var head = {};

[Survived] BooleanLiteral
q.js:107:20
-       var isNodeJS = false;
+       var isNodeJS = true;

[Survived] ArrayDeclaration
q.js:109:22
-       var laterQueue = [];
+       var laterQueue = ["Stryker was here"];

[Survived] ConditionalExpression
q.js:121:17
-               if (domain) {
+               if (false) {

[Survived] BlockStatement
q.js:121:25
-               if (domain) {
-                   head.domain = void 0;
-                   domain.enter();
-               }
+               if (domain) {}

[Survived] ConditionalExpression
q.js:128:16
-           while (laterQueue.length) {
+           while (false) {

[Survived] BlockStatement
q.js:139:21
-           } catch (e) {
-               if (isNodeJS) {
-                   // In node, uncaught exceptions are considered fatal errors.
-                   // Re-throw them synchronously to interrupt flushing!
-                   // Ensure continuation if the uncaught exception is suppressed
-                   // listening "uncaughtException" events (as domains does).
-                   // Continue in next event to avoid tick recursion.
-                   if (domain) {
-                       domain.exit();
-                   }
-                   setTimeout(flush, 0);
-                   if (domain) {
-                       domain.enter();
-                   }
-                   throw e;
-               } else {
-                   // In browsers, uncaught exceptions are not fatal.
-                   // Re-throw them asynchronously to avoid slow-downs.
-                   setTimeout(function () {
-                       throw e;
-                   }, 0);
-               }
-           }
+           } catch (e) {}

[Survived] ConditionalExpression
q.js:140:17
-               if (isNodeJS) {
+               if (true) {

[Survived] ConditionalExpression
q.js:140:17
-               if (isNodeJS) {
+               if (false) {

[Survived] BlockStatement
q.js:140:27
-               if (isNodeJS) {
-                   // In node, uncaught exceptions are considered fatal errors.
-                   // Re-throw them synchronously to interrupt flushing!
-                   // Ensure continuation if the uncaught exception is suppressed
-                   // listening "uncaughtException" events (as domains does).
-                   // Continue in next event to avoid tick recursion.
-                   if (domain) {
-                       domain.exit();
-                   }
-                   setTimeout(flush, 0);
-                   if (domain) {
-                       domain.enter();
-                   }
-                   throw e;
-               } else {
+               if (isNodeJS) {} else {

[Survived] ConditionalExpression
q.js:147:21
-                   if (domain) {
+                   if (true) {

[Survived] ConditionalExpression
q.js:147:21
-                   if (domain) {
+                   if (false) {

[Survived] BlockStatement
q.js:147:29
-                   if (domain) {
-                       domain.exit();
-                   }
+                   if (domain) {}

[Survived] ConditionalExpression
q.js:151:21
-                   if (domain) {
+                   if (true) {

[Survived] ConditionalExpression
q.js:151:21
-                   if (domain) {
+                   if (false) {

[Survived] BlockStatement
q.js:151:29
-                   if (domain) {
-                       domain.enter();
-                   }
+                   if (domain) {}

[Survived] BlockStatement
q.js:157:20
-               } else {
-                   // In browsers, uncaught exceptions are not fatal.
-                   // Re-throw them asynchronously to avoid slow-downs.
-                   setTimeout(function () {
-                       throw e;
-                   }, 0);
-               }
+               } else {}

[Survived] BlockStatement
q.js:160:40
-                   setTimeout(function () {
-                       throw e;
-                   }, 0);
+                   setTimeout(function () {}, 0);

[Survived] ConditionalExpression
q.js:166:13
-           if (domain) {
+           if (false) {

[Survived] BlockStatement
q.js:166:21
-           if (domain) {
-               domain.exit();
-           }
+           if (domain) {}

[Survived] ConditionalExpression
q.js:174:21
-               domain: isNodeJS && process.domain,
+               domain: false,

[Survived] ConditionalExpression
q.js:178:13
-           if (!flushing) {
+           if (true) {

[Survived] BooleanLiteral
q.js:179:24
-               flushing = true;
+               flushing = false;

[Survived] ConditionalExpression
q.js:184:9
-       if (typeof process === "object" &&
-           process.toString() === "[object process]" && process.nextTick) {
+       if (true) {

[Survived] ConditionalExpression
q.js:184:9
-       if (typeof process === "object" &&
-           process.toString() === "[object process]" && process.nextTick) {
+       if (false) {

[Survived] LogicalOperator
q.js:184:9
-       if (typeof process === "object" &&
-           process.toString() === "[object process]" && process.nextTick) {
+       if (typeof process === "object" && process.toString() === "[object process]" || process.nextTick) {

[Survived] ConditionalExpression
q.js:184:9
-       if (typeof process === "object" &&
-           process.toString() === "[object process]" && process.nextTick) {
+       if (true && process.nextTick) {

[Survived] LogicalOperator
q.js:184:9
-       if (typeof process === "object" &&
-           process.toString() === "[object process]" && process.nextTick) {
+       if (typeof process === "object" || process.toString() === "[object process]" && process.nextTick) {

[Survived] ConditionalExpression
q.js:184:9
-       if (typeof process === "object" &&
+       if (true &&

[Survived] EqualityOperator
q.js:184:9
-       if (typeof process === "object" &&
+       if (typeof process !== "object" &&

[Survived] StringLiteral
q.js:184:28
-       if (typeof process === "object" &&
+       if (typeof process === "" &&

[Survived] ConditionalExpression
q.js:185:9
-           process.toString() === "[object process]" && process.nextTick) {
+           true && process.nextTick) {

[Survived] EqualityOperator
q.js:185:9
-           process.toString() === "[object process]" && process.nextTick) {
+           process.toString() !== "[object process]" && process.nextTick) {

[Survived] StringLiteral
q.js:185:32
-           process.toString() === "[object process]" && process.nextTick) {
+           process.toString() === "" && process.nextTick) {

[Survived] BooleanLiteral
q.js:194:20
-           isNodeJS = true;
+           isNodeJS = false;

[Survived] ConditionalExpression
q.js:200:16
-       } else if (typeof setImmediate === "function") {
+       } else if (true) {

[Survived] ConditionalExpression
q.js:200:16
-       } else if (typeof setImmediate === "function") {
+       } else if (false) {

[Survived] EqualityOperator
q.js:200:16
-       } else if (typeof setImmediate === "function") {
+       } else if (typeof setImmediate !== "function") {

[Survived] StringLiteral
q.js:200:40
-       } else if (typeof setImmediate === "function") {
+       } else if (typeof setImmediate === "") {

[Survived] BlockStatement
q.js:200:52
-       } else if (typeof setImmediate === "function") {
-           // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
-           if (typeof window !== "undefined") {
-               requestTick = setImmediate.bind(window, flush);
-           } else {
-               requestTick = function () {
-                   setImmediate(flush);
-               };
-           }
-       } else if (typeof MessageChannel !== "undefined") {
+       } else if (typeof setImmediate === "function") {} else if (typeof MessageChannel !== "undefined") {

[Survived] ConditionalExpression
q.js:202:13
-           if (typeof window !== "undefined") {
+           if (true) {

[Survived] ConditionalExpression
q.js:202:13
-           if (typeof window !== "undefined") {
+           if (false) {

[Survived] EqualityOperator
q.js:202:13
-           if (typeof window !== "undefined") {
+           if (typeof window === "undefined") {

[Survived] StringLiteral
q.js:202:31
-           if (typeof window !== "undefined") {
+           if (typeof window !== "") {

[Survived] BlockStatement
q.js:202:44
-           if (typeof window !== "undefined") {
-               requestTick = setImmediate.bind(window, flush);
-           } else {
+           if (typeof window !== "undefined") {} else {

[Survived] BlockStatement
q.js:204:16
-           } else {
-               requestTick = function () {
-                   setImmediate(flush);
-               };
-           }
+           } else {}

[Survived] BlockStatement
q.js:205:39
-               requestTick = function () {
-                   setImmediate(flush);
-               };
+               requestTick = function () {};

[Survived] ConditionalExpression
q.js:210:16
-       } else if (typeof MessageChannel !== "undefined") {
+       } else if (true) {

[Survived] ConditionalExpression
q.js:210:16
-       } else if (typeof MessageChannel !== "undefined") {
+       } else if (false) {

[Survived] EqualityOperator
q.js:210:16
-       } else if (typeof MessageChannel !== "undefined") {
+       } else if (typeof MessageChannel === "undefined") {

[Survived] StringLiteral
q.js:210:42
-       } else if (typeof MessageChannel !== "undefined") {
+       } else if (typeof MessageChannel !== "") {

[Survived] BlockStatement
q.js:210:55
-       } else if (typeof MessageChannel !== "undefined") {
-           // modern browsers
-           // http://www.nonblocking.io/2011/06/windownexttick.html
-           var channel = new MessageChannel();
-           // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
-           // working message ports the first time a page loads.
-           channel.port1.onmessage = function () {
-               requestTick = requestPortTick;
-               channel.port1.onmessage = flush;
-               flush();
-           };
-           var requestPortTick = function () {
-               // Opera requires us to provide a message payload, regardless of
-               // whether we use it.
-               channel.port2.postMessage(0);
-           };
-           requestTick = function () {
-               setTimeout(flush, 0);
-               requestPortTick();
-           };
-       } else {
+       } else if (typeof MessageChannel !== "undefined") {} else {

[Survived] BlockStatement
q.js:216:47
-           channel.port1.onmessage = function () {
-               requestTick = requestPortTick;
-               channel.port1.onmessage = flush;
-               flush();
-           };
+           channel.port1.onmessage = function () {};

[Survived] BlockStatement
q.js:221:43
-           var requestPortTick = function () {
-               // Opera requires us to provide a message payload, regardless of
-               // whether we use it.
-               channel.port2.postMessage(0);
-           };
+           var requestPortTick = function () {};

[Survived] BlockStatement
q.js:226:35
-           requestTick = function () {
-               setTimeout(flush, 0);
-               requestPortTick();
-           };
+           requestTick = function () {};

[Survived] BlockStatement
q.js:231:12
-       } else {
-           // old browsers
-           requestTick = function () {
-               setTimeout(flush, 0);
-           };
-       }
+       } else {}

[Survived] BlockStatement
q.js:233:35
-           requestTick = function () {
-               setTimeout(flush, 0);
-           };
+           requestTick = function () {};

[Survived] BlockStatement
q.js:240:41
-       nextTick.runAfter = function (task) {
-           laterQueue.push(task);
-           if (!flushing) {
-               flushing = true;
-               requestTick();
-           }
-       };
+       nextTick.runAfter = function (task) {};

[Survived] BooleanLiteral
q.js:242:13
-           if (!flushing) {
+           if (flushing) {

[Survived] ConditionalExpression
q.js:242:13
-           if (!flushing) {
+           if (true) {

[Survived] ConditionalExpression
q.js:242:13
-           if (!flushing) {
+           if (false) {

[Survived] BlockStatement
q.js:242:24
-           if (!flushing) {
-               flushing = true;
-               requestTick();
-           }
+           if (!flushing) {}

[Survived] BooleanLiteral
q.js:243:24
-               flushing = true;
+               flushing = false;

[Survived] LogicalOperator
q.js:273:5
-       Array.prototype.reduce || function (callback, basis) {
-           var index = 0,
-               length = this.length;
-           // concerning the initial value, if one is not provided
-           if (arguments.length === 1) {
-               // seek to the first value in the array, accounting
-               // for the possibility that is is a sparse array
-               do {
-                   if (index in this) {
-                       basis = this[index++];
-                       break;
-                   }
-                   if (++index >= length) {
-                       throw new TypeError();
-                   }
-               } while (1);
-           }
-           // reduce
-           for (; index < length; index++) {
-               // account for the possibility that the array is sparse
-               if (index in this) {
-                   basis = callback(basis, this[index], index);
-               }
-           }
-           return basis;
-       }
+       Array.prototype.reduce && function (callback, basis) {
+     var index = 0,
+       length = this.length;
+     // concerning the initial value, if one is not provided
+     if (arguments.length === 1) {
+       // seek to the first value in the array, accounting
+       // for the possibility that is is a sparse array
+       do {
+         if (index in this) {
+           basis = this[index++];
+           break;
+         }
+         if (++index >= length) {
+           throw new TypeError();
+         }
+       } while (1);
+     }
+     // reduce
+     for (; index < length; index++) {
+       // account for the possibility that the array is sparse
+       if (index in this) {
+         basis = callback(basis, this[index], index);
+       }
+     }
+     return basis;
+   }

[Survived] BlockStatement
q.js:273:58
-       Array.prototype.reduce || function (callback, basis) {
-           var index = 0,
-               length = this.length;
-           // concerning the initial value, if one is not provided
-           if (arguments.length === 1) {
-               // seek to the first value in the array, accounting
-               // for the possibility that is is a sparse array
-               do {
-                   if (index in this) {
-                       basis = this[index++];
-                       break;
-                   }
-                   if (++index >= length) {
-                       throw new TypeError();
-                   }
-               } while (1);
-           }
-           // reduce
-           for (; index < length; index++) {
-               // account for the possibility that the array is sparse
-               if (index in this) {
-                   basis = callback(basis, this[index], index);
-               }
-           }
-           return basis;
-       }
+       Array.prototype.reduce || function (callback, basis) {}

[Survived] ConditionalExpression
q.js:277:13
-           if (arguments.length === 1) {
+           if (true) {

[Survived] ConditionalExpression
q.js:277:13
-           if (arguments.length === 1) {
+           if (false) {

[Survived] EqualityOperator
q.js:277:13
-           if (arguments.length === 1) {
+           if (arguments.length !== 1) {

[Survived] BlockStatement
q.js:277:37
-           if (arguments.length === 1) {
-               // seek to the first value in the array, accounting
-               // for the possibility that is is a sparse array
-               do {
-                   if (index in this) {
-                       basis = this[index++];
-                       break;
-                   }
-                   if (++index >= length) {
-                       throw new TypeError();
-                   }
-               } while (1);
-           }
+           if (arguments.length === 1) {}

[Survived] ConditionalExpression
q.js:288:22
-               } while (1);
+               } while (false);

[Survived] BlockStatement
q.js:280:16
-               do {
-                   if (index in this) {
-                       basis = this[index++];
-                       break;
-                   }
-                   if (++index >= length) {
-                       throw new TypeError();
-                   }
-               } while (1);
+               do {} while (1);

[Survived] ConditionalExpression
q.js:281:21
-                   if (index in this) {
+                   if (true) {

[Survived] ConditionalExpression
q.js:281:21
-                   if (index in this) {
+                   if (false) {

[Survived] BlockStatement
q.js:281:36
-                   if (index in this) {
-                       basis = this[index++];
-                       break;
-                   }
+                   if (index in this) {}

[Survived] UpdateOperator
q.js:282:34
-                       basis = this[index++];
+                       basis = this[index--];

[Survived] ConditionalExpression
q.js:285:21
-                   if (++index >= length) {
+                   if (true) {

[Survived] ConditionalExpression
q.js:285:21
-                   if (++index >= length) {
+                   if (false) {

[Survived] EqualityOperator
q.js:285:21
-                   if (++index >= length) {
+                   if (++index > length) {

[Survived] EqualityOperator
q.js:285:21
-                   if (++index >= length) {
+                   if (++index < length) {

[Survived] UpdateOperator
q.js:285:21
-                   if (++index >= length) {
+                   if (--index >= length) {

[Survived] BlockStatement
q.js:285:40
-                   if (++index >= length) {
-                       throw new TypeError();
-                   }
+                   if (++index >= length) {}

[Survived] ConditionalExpression
q.js:291:16
-           for (; index < length; index++) {
+           for (; false; index++) {

[Survived] EqualityOperator
q.js:291:16
-           for (; index < length; index++) {
+           for (; index <= length; index++) {

[Survived] EqualityOperator
q.js:291:16
-           for (; index < length; index++) {
+           for (; index >= length; index++) {

[Survived] UpdateOperator
q.js:291:32
-           for (; index < length; index++) {
+           for (; index < length; index--) {

[Survived] BlockStatement
q.js:291:41
-           for (; index < length; index++) {
-               // account for the possibility that the array is sparse
-               if (index in this) {
-                   basis = callback(basis, this[index], index);
-               }
-           }
+           for (; index < length; index++) {}

[Survived] ConditionalExpression
q.js:293:17
-               if (index in this) {
+               if (true) {

[Survived] ConditionalExpression
q.js:293:17
-               if (index in this) {
+               if (false) {

[Survived] BlockStatement
q.js:293:32
-               if (index in this) {
-                   basis = callback(basis, this[index], index);
-               }
+               if (index in this) {}

[Survived] LogicalOperator
q.js:302:5
-       Array.prototype.indexOf || function (value) {
-           // not a very good shim, but good enough for our one use of it
-           for (var i = 0; i < this.length; i++) {
-               if (this[i] === value) {
-                   return i;
-               }
-           }
-           return -1;
-       }
+       Array.prototype.indexOf && function (value) {
+     // not a very good shim, but good enough for our one use of it
+     for (var i = 0; i < this.length; i++) {
+       if (this[i] === value) {
+         return i;
+       }
+     }
+     return -1;
+   }

[Survived] BlockStatement
q.js:302:49
-       Array.prototype.indexOf || function (value) {
-           // not a very good shim, but good enough for our one use of it
-           for (var i = 0; i < this.length; i++) {
-               if (this[i] === value) {
-                   return i;
-               }
-           }
-           return -1;
-       }
+       Array.prototype.indexOf || function (value) {}

[Survived] ConditionalExpression
q.js:304:25
-           for (var i = 0; i < this.length; i++) {
+           for (var i = 0; false; i++) {

[Survived] EqualityOperator
q.js:304:25
-           for (var i = 0; i < this.length; i++) {
+           for (var i = 0; i <= this.length; i++) {

[Survived] EqualityOperator
q.js:304:25
-           for (var i = 0; i < this.length; i++) {
+           for (var i = 0; i >= this.length; i++) {

[Survived] UpdateOperator
q.js:304:42
-           for (var i = 0; i < this.length; i++) {
+           for (var i = 0; i < this.length; i--) {

[Survived] BlockStatement
q.js:304:47
-           for (var i = 0; i < this.length; i++) {
-               if (this[i] === value) {
-                   return i;
-               }
-           }
+           for (var i = 0; i < this.length; i++) {}

[Survived] ConditionalExpression
q.js:305:17
-               if (this[i] === value) {
+               if (true) {

[Survived] ConditionalExpression
q.js:305:17
-               if (this[i] === value) {
+               if (false) {

[Survived] EqualityOperator
q.js:305:17
-               if (this[i] === value) {
+               if (this[i] !== value) {

[Survived] BlockStatement
q.js:305:36
-               if (this[i] === value) {
-                   return i;
-               }
+               if (this[i] === value) {}

[Survived] UnaryOperator
q.js:309:16
-           return -1;
+           return +1;

[Survived] ConditionalExpression
q.js:314:5
-       Array.prototype.map || function (callback, thisp) {
-           var self = this;
-           var collect = [];
-           array_reduce(self, function (undefined, value, index) {
-               collect.push(callback.call(thisp, value, index, self));
-           }, void 0);
-           return collect;
-       }
+       true

[Survived] ConditionalExpression
q.js:314:5
-       Array.prototype.map || function (callback, thisp) {
-           var self = this;
-           var collect = [];
-           array_reduce(self, function (undefined, value, index) {
-               collect.push(callback.call(thisp, value, index, self));
-           }, void 0);
-           return collect;
-       }
+       false

[Survived] LogicalOperator
q.js:314:5
-       Array.prototype.map || function (callback, thisp) {
-           var self = this;
-           var collect = [];
-           array_reduce(self, function (undefined, value, index) {
-               collect.push(callback.call(thisp, value, index, self));
-           }, void 0);
-           return collect;
-       }
+       Array.prototype.map && function (callback, thisp) {
+     var self = this;
+     var collect = [];
+     array_reduce(self, function (undefined, value, index) {
+       collect.push(callback.call(thisp, value, index, self));
+     }, void 0);
+     return collect;
+   }

[Survived] BlockStatement
q.js:314:55
-       Array.prototype.map || function (callback, thisp) {
-           var self = this;
-           var collect = [];
-           array_reduce(self, function (undefined, value, index) {
-               collect.push(callback.call(thisp, value, index, self));
-           }, void 0);
-           return collect;
-       }
+       Array.prototype.map || function (callback, thisp) {}

[Survived] ArrayDeclaration
q.js:316:23
-           var collect = [];
+           var collect = ["Stryker was here"];

[Survived] BlockStatement
q.js:317:63
-           array_reduce(self, function (undefined, value, index) {
-               collect.push(callback.call(thisp, value, index, self));
-           }, void 0);
+           array_reduce(self, function (undefined, value, index) {}, void 0);

[Survived] LogicalOperator
q.js:324:21
-   var object_create = Object.create || function (prototype) {
-       function Type() { }
-       Type.prototype = prototype;
-       return new Type();
-   };
+   var object_create = Object.create && function (prototype) {
+     function Type() {}
+     Type.prototype = prototype;
+     return new Type();
+   };

[Survived] BlockStatement
q.js:324:59
-   var object_create = Object.create || function (prototype) {
-       function Type() { }
-       Type.prototype = prototype;
-       return new Type();
-   };
+   var object_create = Object.create || function (prototype) {};

[Survived] ConditionalExpression
q.js:330:29
-   var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
-       obj[prop] = descriptor.value;
-       return obj;
-   };
+   var object_defineProperty = true;

[Survived] ConditionalExpression
q.js:330:29
-   var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
-       obj[prop] = descriptor.value;
-       return obj;
-   };
+   var object_defineProperty = false;

[Survived] LogicalOperator
q.js:330:29
-   var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
-       obj[prop] = descriptor.value;
-       return obj;
-   };
+   var object_defineProperty = Object.defineProperty && function (obj, prop, descriptor) {
+     obj[prop] = descriptor.value;
+     return obj;
+   };

[Survived] BlockStatement
q.js:330:87
-   var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
-       obj[prop] = descriptor.value;
-       return obj;
-   };
+   var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {};

[Survived] ConditionalExpression
q.js:337:19
-   var object_keys = Object.keys || function (object) {
-       var keys = [];
-       for (var key in object) {
-           if (object_hasOwnProperty(object, key)) {
-               keys.push(key);
-           }
-       }
-       return keys;
-   };
+   var object_keys = true;

[Survived] ConditionalExpression
q.js:337:19
-   var object_keys = Object.keys || function (object) {
-       var keys = [];
-       for (var key in object) {
-           if (object_hasOwnProperty(object, key)) {
-               keys.push(key);
-           }
-       }
-       return keys;
-   };
+   var object_keys = false;

[Survived] LogicalOperator
q.js:337:19
-   var object_keys = Object.keys || function (object) {
-       var keys = [];
-       for (var key in object) {
-           if (object_hasOwnProperty(object, key)) {
-               keys.push(key);
-           }
-       }
-       return keys;
-   };
+   var object_keys = Object.keys && function (object) {
+     var keys = [];
+     for (var key in object) {
+       if (object_hasOwnProperty(object, key)) {
+         keys.push(key);
+       }
+     }
+     return keys;
+   };

[Survived] BlockStatement
q.js:337:52
-   var object_keys = Object.keys || function (object) {
-       var keys = [];
-       for (var key in object) {
-           if (object_hasOwnProperty(object, key)) {
-               keys.push(key);
-           }
-       }
-       return keys;
-   };
+   var object_keys = Object.keys || function (object) {};

[Survived] ArrayDeclaration
q.js:338:16
-       var keys = [];
+       var keys = ["Stryker was here"];

[Survived] BlockStatement
q.js:339:29
-       for (var key in object) {
-           if (object_hasOwnProperty(object, key)) {
-               keys.push(key);
-           }
-       }
+       for (var key in object) {}

[Survived] ConditionalExpression
q.js:340:13
-           if (object_hasOwnProperty(object, key)) {
+           if (true) {

[Survived] ConditionalExpression
q.js:340:13
-           if (object_hasOwnProperty(object, key)) {
+           if (false) {

[Survived] BlockStatement
q.js:340:49
-           if (object_hasOwnProperty(object, key)) {
-               keys.push(key);
-           }
+           if (object_hasOwnProperty(object, key)) {}

[Survived] BlockStatement
q.js:356:37
-   function isStopIteration(exception) {
-       return (
-           object_toString(exception) === "[object StopIteration]" ||
-           exception instanceof QReturnValue
-       );
-   }
+   function isStopIteration(exception) {}

[Survived] ConditionalExpression
q.js:358:9
-           object_toString(exception) === "[object StopIteration]" ||
-           exception instanceof QReturnValue
+           true

[Survived] ConditionalExpression
q.js:358:9
-           object_toString(exception) === "[object StopIteration]" ||
-           exception instanceof QReturnValue
+           false

[Survived] LogicalOperator
q.js:358:9
-           object_toString(exception) === "[object StopIteration]" ||
-           exception instanceof QReturnValue
+           object_toString(exception) === "[object StopIteration]" && exception instanceof QReturnValue

[Survived] ConditionalExpression
q.js:358:9
-           object_toString(exception) === "[object StopIteration]" ||
+           false ||

[Survived] EqualityOperator
q.js:358:9
-           object_toString(exception) === "[object StopIteration]" ||
+           object_toString(exception) !== "[object StopIteration]" ||

[Survived] StringLiteral
q.js:358:40
-           object_toString(exception) === "[object StopIteration]" ||
+           object_toString(exception) === "" ||

[Survived] ConditionalExpression
q.js:366:5
-   if (typeof ReturnValue !== "undefined") {
+   if (false) {

[Survived] BlockStatement
q.js:366:41
-   if (typeof ReturnValue !== "undefined") {
-       QReturnValue = ReturnValue;
-   } else {
+   if (typeof ReturnValue !== "undefined") {} else {

[Survived] BlockStatement
q.js:368:8
-   } else {
-       QReturnValue = function (value) {
-           this.value = value;
-       };
-   }
+   } else {}

[Survived] BlockStatement
q.js:369:37
-       QReturnValue = function (value) {
-           this.value = value;
-       };
+       QReturnValue = function (value) {};

[Survived] StringLiteral
q.js:376:28
-   var STACK_JUMP_SEPARATOR = "From previous event:";
+   var STACK_JUMP_SEPARATOR = "";

[Survived] BlockStatement
q.js:378:45
-   function makeStackTraceLong(error, promise) {
-       // If possible, transform the error stack trace by removing Node and Q
-       // cruft, then concatenating with the stack trace of `promise`. See #57.
-       if (hasStacks &&
-           promise.stack &&
-           typeof error === "object" &&
-           error !== null &&
-           error.stack
-       ) {
-           var stacks = [];
-           for (var p = promise; !!p; p = p.source) {
-               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
-                   object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: true});
-                   stacks.unshift(p.stack);
-               }
-           }
-           stacks.unshift(error.stack);
-           var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
-           var stack = filterStackString(concatedStacks);
-           object_defineProperty(error, "stack", {value: stack, configurable: true});
-       }
-   }
+   function makeStackTraceLong(error, promise) {}

[Survived] ConditionalExpression
q.js:381:9
-       if (hasStacks &&
-           promise.stack &&
-           typeof error === "object" &&
-           error !== null &&
-           error.stack
+       if (false

[Survived] LogicalOperator
q.js:381:9
-       if (hasStacks &&
-           promise.stack &&
-           typeof error === "object" &&
+       if (hasStacks && promise.stack || typeof error === "object" &&

[Survived] ConditionalExpression
q.js:381:9
-       if (hasStacks &&
-           promise.stack &&
+       if (true &&

[Survived] LogicalOperator
q.js:381:9
-       if (hasStacks &&
-           promise.stack &&
+       if (hasStacks || promise.stack &&

[Survived] ConditionalExpression
q.js:383:9
-           typeof error === "object" &&
+           true &&

[Survived] EqualityOperator
q.js:383:9
-           typeof error === "object" &&
+           typeof error !== "object" &&

[Survived] StringLiteral
q.js:383:26
-           typeof error === "object" &&
+           typeof error === "" &&

[Survived] ConditionalExpression
q.js:384:9
-           error !== null &&
+           true &&

[Survived] EqualityOperator
q.js:384:9
-           error !== null &&
+           error === null &&

[Survived] BlockStatement
q.js:386:7
-       ) {
-           var stacks = [];
-           for (var p = promise; !!p; p = p.source) {
-               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
-                   object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: true});
-                   stacks.unshift(p.stack);
-               }
-           }
-           stacks.unshift(error.stack);
-           var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
-           var stack = filterStackString(concatedStacks);
-           object_defineProperty(error, "stack", {value: stack, configurable: true});
-       }
+       ) {}

[Survived] ArrayDeclaration
q.js:387:22
-           var stacks = [];
+           var stacks = ["Stryker was here"];

[Survived] BooleanLiteral
q.js:388:31
-           for (var p = promise; !!p; p = p.source) {
+           for (var p = promise; !p; p = p.source) {

[Survived] ConditionalExpression
q.js:388:31
-           for (var p = promise; !!p; p = p.source) {
+           for (var p = promise; false; p = p.source) {

[Survived] BooleanLiteral
q.js:388:32
-           for (var p = promise; !!p; p = p.source) {
+           for (var p = promise; !p; p = p.source) {

[Survived] BlockStatement
q.js:388:50
-           for (var p = promise; !!p; p = p.source) {
-               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
-                   object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: true});
-                   stacks.unshift(p.stack);
-               }
-           }
+           for (var p = promise; !!p; p = p.source) {}

[Survived] ConditionalExpression
q.js:389:17
-               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
+               if (true) {

[Survived] ConditionalExpression
q.js:389:17
-               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
+               if (false) {

[Survived] LogicalOperator
q.js:389:17
-               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
+               if (p.stack || !error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter) {

[Survived] ConditionalExpression
q.js:389:29
-               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
+               if (p.stack && (true)) {

[Survived] LogicalOperator
q.js:389:29
-               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
+               if (p.stack && (!error.__minimumStackCounter__ && error.__minimumStackCounter__ > p.stackCounter)) {

[Survived] BooleanLiteral
q.js:389:29
-               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
+               if (p.stack && (error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {

[Survived] ConditionalExpression
q.js:389:63
-               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
+               if (p.stack && (!error.__minimumStackCounter__ || false)) {

[Survived] EqualityOperator
q.js:389:63
-               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
+               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ >= p.stackCounter)) {

[Survived] EqualityOperator
q.js:389:63
-               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
+               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ <= p.stackCounter)) {

[Survived] BlockStatement
q.js:389:112
-               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
-                   object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: true});
-                   stacks.unshift(p.stack);
-               }
+               if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {}

[Survived] StringLiteral
q.js:390:46
-                   object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: true});
+                   object_defineProperty(error, "", {value: p.stackCounter, configurable: true});

[Survived] ObjectLiteral
q.js:390:73
-                   object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: true});
+                   object_defineProperty(error, "__minimumStackCounter__", {});

[Survived] BooleanLiteral
q.js:390:111
-                   object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: true});
+                   object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: false});

[Survived] StringLiteral
q.js:396:42
-           var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
+           var concatedStacks = stacks.join("" + STACK_JUMP_SEPARATOR + "\n");

[Survived] StringLiteral
q.js:396:72
-           var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
+           var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "");

[Survived] StringLiteral
q.js:398:38
-           object_defineProperty(error, "stack", {value: stack, configurable: true});
+           object_defineProperty(error, "", {value: stack, configurable: true});

[Survived] ObjectLiteral
q.js:398:47
-           object_defineProperty(error, "stack", {value: stack, configurable: true});
+           object_defineProperty(error, "stack", {});

[Survived] BooleanLiteral
q.js:398:76
-           object_defineProperty(error, "stack", {value: stack, configurable: true});
+           object_defineProperty(error, "stack", {value: stack, configurable: false});

[Survived] BlockStatement
q.js:402:41
-   function filterStackString(stackString) {
-       var lines = stackString.split("\n");
-       var desiredLines = [];
-       for (var i = 0; i < lines.length; ++i) {
-           var line = lines[i];
-           if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
-               desiredLines.push(line);
-           }
-       }
-       return desiredLines.join("\n");
-   }
+   function filterStackString(stackString) {}

[Survived] StringLiteral
q.js:403:35
-       var lines = stackString.split("\n");
+       var lines = stackString.split("");

[Survived] ArrayDeclaration
q.js:404:24
-       var desiredLines = [];
+       var desiredLines = ["Stryker was here"];

[Survived] ConditionalExpression
q.js:405:21
-       for (var i = 0; i < lines.length; ++i) {
+       for (var i = 0; false; ++i) {

[Survived] EqualityOperator
q.js:405:21
-       for (var i = 0; i < lines.length; ++i) {
+       for (var i = 0; i <= lines.length; ++i) {

[Survived] EqualityOperator
q.js:405:21
-       for (var i = 0; i < lines.length; ++i) {
+       for (var i = 0; i >= lines.length; ++i) {

[Survived] UpdateOperator
q.js:405:39
-       for (var i = 0; i < lines.length; ++i) {
+       for (var i = 0; i < lines.length; --i) {

[Survived] BlockStatement
q.js:405:44
-       for (var i = 0; i < lines.length; ++i) {
-           var line = lines[i];
-           if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
-               desiredLines.push(line);
-           }
-       }
+       for (var i = 0; i < lines.length; ++i) {}

[Survived] ConditionalExpression
q.js:408:13
-           if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
+           if (true) {

[Survived] ConditionalExpression
q.js:408:13
-           if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
+           if (false) {

[Survived] LogicalOperator
q.js:408:13
-           if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
+           if (!isInternalFrame(line) && !isNodeFrame(line) || line) {

[Survived] ConditionalExpression
q.js:408:13
-           if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
+           if (true && line) {

[Survived] LogicalOperator
q.js:408:13
-           if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
+           if (!isInternalFrame(line) || !isNodeFrame(line) && line) {

[Survived] BooleanLiteral
q.js:408:13
-           if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
+           if (isInternalFrame(line) && !isNodeFrame(line) && line) {

[Survived] BooleanLiteral
q.js:408:39
-           if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
+           if (!isInternalFrame(line) && isNodeFrame(line) && line) {

[Survived] BlockStatement
q.js:408:67
-           if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
-               desiredLines.push(line);
-           }
+           if (!isInternalFrame(line) && !isNodeFrame(line) && line) {}

[Survived] StringLiteral
q.js:412:30
-       return desiredLines.join("\n");
+       return desiredLines.join("");

[Survived] BlockStatement
q.js:415:33
-   function isNodeFrame(stackLine) {
-       return stackLine.indexOf("(module.js:") !== -1 ||
-              stackLine.indexOf("(node.js:") !== -1;
-   }
+   function isNodeFrame(stackLine) {}

[Survived] ConditionalExpression
q.js:416:12
-       return stackLine.indexOf("(module.js:") !== -1 ||
-              stackLine.indexOf("(node.js:") !== -1;
+       return true;

[Survived] ConditionalExpression
q.js:416:12
-       return stackLine.indexOf("(module.js:") !== -1 ||
-              stackLine.indexOf("(node.js:") !== -1;
+       return false;

[Survived] LogicalOperator
q.js:416:12
-       return stackLine.indexOf("(module.js:") !== -1 ||
-              stackLine.indexOf("(node.js:") !== -1;
+       return stackLine.indexOf("(module.js:") !== -1 && stackLine.indexOf("(node.js:") !== -1;

[Survived] ConditionalExpression
q.js:416:12
-       return stackLine.indexOf("(module.js:") !== -1 ||
+       return false ||

[Survived] EqualityOperator
q.js:416:12
-       return stackLine.indexOf("(module.js:") !== -1 ||
+       return stackLine.indexOf("(module.js:") === -1 ||

[Survived] StringLiteral
q.js:416:30
-       return stackLine.indexOf("(module.js:") !== -1 ||
+       return stackLine.indexOf("") !== -1 ||

[Survived] UnaryOperator
q.js:416:49
-       return stackLine.indexOf("(module.js:") !== -1 ||
+       return stackLine.indexOf("(module.js:") !== +1 ||

[Survived] ConditionalExpression
q.js:417:12
-              stackLine.indexOf("(node.js:") !== -1;
+              false;

[Survived] EqualityOperator
q.js:417:12
-              stackLine.indexOf("(node.js:") !== -1;
+              stackLine.indexOf("(node.js:") === -1;

[Survived] StringLiteral
q.js:417:30
-              stackLine.indexOf("(node.js:") !== -1;
+              stackLine.indexOf("") !== -1;

[Survived] UnaryOperator
q.js:417:47
-              stackLine.indexOf("(node.js:") !== -1;
+              stackLine.indexOf("(node.js:") !== +1;

[Survived] BlockStatement
q.js:420:46
-   function getFileNameAndLineNumber(stackLine) {
-       // Named functions: "at functionName (filename:lineNumber:columnNumber)"
-       // In IE10 function name can have spaces ("Anonymous function") O_o
-       var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
-       if (attempt1) {
-           return [attempt1[1], Number(attempt1[2])];
-       }
-       // Anonymous functions: "at filename:lineNumber:columnNumber"
-       var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
-       if (attempt2) {
-           return [attempt2[1], Number(attempt2[2])];
-       }
-       // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
-       var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
-       if (attempt3) {
-           return [attempt3[1], Number(attempt3[2])];
-       }
-   }
+   function getFileNameAndLineNumber(stackLine) {}

[Survived] Regex
q.js:423:20
-       var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
+       var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)/.exec(stackLine);

[Survived] Regex
q.js:423:20
-       var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
+       var attempt1 = /at . \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);

[Survived] Regex
q.js:423:20
-       var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
+       var attempt1 = /at .+ \((.):(\d+):(?:\d+)\)$/.exec(stackLine);

[Survived] Regex
q.js:423:20
-       var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
+       var attempt1 = /at .+ \((.+):(\d):(?:\d+)\)$/.exec(stackLine);

[Survived] Regex
q.js:423:20
-       var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
+       var attempt1 = /at .+ \((.+):(\D+):(?:\d+)\)$/.exec(stackLine);

[Survived] Regex
q.js:423:20
-       var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
+       var attempt1 = /at .+ \((.+):(\d+):(?:\d)\)$/.exec(stackLine);

[Survived] Regex
q.js:423:20
-       var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
+       var attempt1 = /at .+ \((.+):(\d+):(?:\D+)\)$/.exec(stackLine);

[Survived] ConditionalExpression
q.js:424:9
-       if (attempt1) {
+       if (false) {

[Survived] BlockStatement
q.js:424:19
-       if (attempt1) {
-           return [attempt1[1], Number(attempt1[2])];
-       }
+       if (attempt1) {}

[Survived] ArrayDeclaration
q.js:425:16
-           return [attempt1[1], Number(attempt1[2])];
+           return [];

[Survived] Regex
q.js:429:20
-       var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
+       var attempt2 = /at ([^ ]+):(\d+):(?:\d+)/.exec(stackLine);

[Survived] Regex
q.js:429:20
-       var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
+       var attempt2 = /at ([^ ]):(\d+):(?:\d+)$/.exec(stackLine);

[Survived] Regex
q.js:429:20
-       var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
+       var attempt2 = /at ([ ]+):(\d+):(?:\d+)$/.exec(stackLine);

[Survived] Regex
q.js:429:20
-       var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
+       var attempt2 = /at ([^ ]+):(\d):(?:\d+)$/.exec(stackLine);

[Survived] Regex
q.js:429:20
-       var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
+       var attempt2 = /at ([^ ]+):(\D+):(?:\d+)$/.exec(stackLine);

[Survived] Regex
q.js:429:20
-       var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
+       var attempt2 = /at ([^ ]+):(\d+):(?:\d)$/.exec(stackLine);

[Survived] Regex
q.js:429:20
-       var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
+       var attempt2 = /at ([^ ]+):(\d+):(?:\D+)$/.exec(stackLine);

[Survived] ConditionalExpression
q.js:430:9
-       if (attempt2) {
+       if (true) {

[Survived] ConditionalExpression
q.js:430:9
-       if (attempt2) {
+       if (false) {

[Survived] BlockStatement
q.js:430:19
-       if (attempt2) {
-           return [attempt2[1], Number(attempt2[2])];
-       }
+       if (attempt2) {}

[Survived] ArrayDeclaration
q.js:431:16
-           return [attempt2[1], Number(attempt2[2])];
+           return [];

[Survived] Regex
q.js:435:20
-       var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
+       var attempt3 = /.*@(.+):(\d+)/.exec(stackLine);

[Survived] Regex
q.js:435:20
-       var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
+       var attempt3 = /.@(.+):(\d+)$/.exec(stackLine);

[Survived] Regex
q.js:435:20
-       var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
+       var attempt3 = /.*@(.):(\d+)$/.exec(stackLine);

[Survived] Regex
q.js:435:20
-       var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
+       var attempt3 = /.*@(.+):(\d)$/.exec(stackLine);

[Survived] Regex
q.js:435:20
-       var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
+       var attempt3 = /.*@(.+):(\D+)$/.exec(stackLine);

[Survived] ConditionalExpression
q.js:436:9
-       if (attempt3) {
+       if (true) {

[Survived] ConditionalExpression
q.js:436:9
-       if (attempt3) {
+       if (false) {

[Survived] BlockStatement
q.js:436:19
-       if (attempt3) {
-           return [attempt3[1], Number(attempt3[2])];
-       }
+       if (attempt3) {}

[Survived] ArrayDeclaration
q.js:437:16
-           return [attempt3[1], Number(attempt3[2])];
+           return [];

[Survived] BlockStatement
q.js:441:37
-   function isInternalFrame(stackLine) {
-       var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
-       if (!fileNameAndLineNumber) {
-           return false;
-       }
-       var fileName = fileNameAndLineNumber[0];
-       var lineNumber = fileNameAndLineNumber[1];
-       return fileName === qFileName &&
-           lineNumber >= qStartingLine &&
-           lineNumber <= qEndingLine;
-   }
+   function isInternalFrame(stackLine) {}

[Survived] BooleanLiteral
q.js:444:9
-       if (!fileNameAndLineNumber) {
+       if (fileNameAndLineNumber) {

[Survived] ConditionalExpression
q.js:444:9
-       if (!fileNameAndLineNumber) {
+       if (true) {

[Survived] ConditionalExpression
q.js:444:9
-       if (!fileNameAndLineNumber) {
+       if (false) {

[Survived] BlockStatement
q.js:444:33
-       if (!fileNameAndLineNumber) {
-           return false;
-       }
+       if (!fileNameAndLineNumber) {}

[Survived] BooleanLiteral
q.js:445:16
-           return false;
+           return true;

[Survived] ConditionalExpression
q.js:451:12
-       return fileName === qFileName &&
-           lineNumber >= qStartingLine &&
-           lineNumber <= qEndingLine;
+       return true;

[Survived] ConditionalExpression
q.js:451:12
-       return fileName === qFileName &&
-           lineNumber >= qStartingLine &&
-           lineNumber <= qEndingLine;
+       return false;

[Survived] LogicalOperator
q.js:451:12
-       return fileName === qFileName &&
-           lineNumber >= qStartingLine &&
-           lineNumber <= qEndingLine;
+       return fileName === qFileName && lineNumber >= qStartingLine || lineNumber <= qEndingLine;

[Survived] ConditionalExpression
q.js:451:12
-       return fileName === qFileName &&
-           lineNumber >= qStartingLine &&
+       return true &&

[Survived] LogicalOperator
q.js:451:12
-       return fileName === qFileName &&
-           lineNumber >= qStartingLine &&
+       return fileName === qFileName || lineNumber >= qStartingLine &&

[Survived] ConditionalExpression
q.js:451:12
-       return fileName === qFileName &&
+       return true &&

[Survived] EqualityOperator
q.js:451:12
-       return fileName === qFileName &&
+       return fileName !== qFileName &&

[Survived] ConditionalExpression
q.js:452:9
-           lineNumber >= qStartingLine &&
+           true &&

[Survived] EqualityOperator
q.js:452:9
-           lineNumber >= qStartingLine &&
+           lineNumber > qStartingLine &&

[Survived] EqualityOperator
q.js:452:9
-           lineNumber >= qStartingLine &&
+           lineNumber < qStartingLine &&

[Survived] ConditionalExpression
q.js:453:9
-           lineNumber <= qEndingLine;
+           true;

[Survived] EqualityOperator
q.js:453:9
-           lineNumber <= qEndingLine;
+           lineNumber < qEndingLine;

[Survived] EqualityOperator
q.js:453:9
-           lineNumber <= qEndingLine;
+           lineNumber > qEndingLine;

[Survived] BlockStatement
q.js:458:24
-   function captureLine() {
-       if (!hasStacks) {
-           return;
-       }
-       try {
-           throw new Error();
-       } catch (e) {
-           var lines = e.stack.split("\n");
-           var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
-           var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
-           if (!fileNameAndLineNumber) {
-               return;
-           }
-           qFileName = fileNameAndLineNumber[0];
-           return fileNameAndLineNumber[1];
-       }
-   }
+   function captureLine() {}

[Survived] BooleanLiteral
q.js:459:9
-       if (!hasStacks) {
+       if (hasStacks) {

[Survived] ConditionalExpression
q.js:459:9
-       if (!hasStacks) {
+       if (true) {

[Survived] ConditionalExpression
q.js:459:9
-       if (!hasStacks) {
+       if (false) {

[Survived] BlockStatement
q.js:459:21
-       if (!hasStacks) {
-           return;
-       }
+       if (!hasStacks) {}

[Survived] BlockStatement
q.js:463:9
-       try {
-           throw new Error();
-       } catch (e) {
+       try {} catch (e) {

[Survived] BlockStatement
q.js:465:17
-       } catch (e) {
-           var lines = e.stack.split("\n");
-           var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
-           var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
-           if (!fileNameAndLineNumber) {
-               return;
-           }
-           qFileName = fileNameAndLineNumber[0];
-           return fileNameAndLineNumber[1];
-       }
+       } catch (e) {}

[Survived] StringLiteral
q.js:466:35
-           var lines = e.stack.split("\n");
+           var lines = e.stack.split("");

[Survived] ConditionalExpression
q.js:467:25
-           var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
+           var firstLine = true ? lines[1] : lines[2];

[Survived] ConditionalExpression
q.js:467:25
-           var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
+           var firstLine = false ? lines[1] : lines[2];

[Survived] EqualityOperator
q.js:467:25
-           var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
+           var firstLine = lines[0].indexOf("@") >= 0 ? lines[1] : lines[2];

[Survived] EqualityOperator
q.js:467:25
-           var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
+           var firstLine = lines[0].indexOf("@") <= 0 ? lines[1] : lines[2];

[Survived] StringLiteral
q.js:467:42
-           var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
+           var firstLine = lines[0].indexOf("") > 0 ? lines[1] : lines[2];

[Survived] BooleanLiteral
q.js:469:13
-           if (!fileNameAndLineNumber) {
+           if (fileNameAndLineNumber) {

[Survived] ConditionalExpression
q.js:469:13
-           if (!fileNameAndLineNumber) {
+           if (true) {

[Survived] ConditionalExpression
q.js:469:13
-           if (!fileNameAndLineNumber) {
+           if (false) {

[Survived] BlockStatement
q.js:469:37
-           if (!fileNameAndLineNumber) {
-               return;
-           }
+           if (!fileNameAndLineNumber) {}

[Survived] BlockStatement
q.js:478:49
-   function deprecate(callback, name, alternative) {
-       return function () {
-           if (typeof console !== "undefined" &&
-               typeof console.warn === "function") {
-               console.warn(name + " is deprecated, use " + alternative +
-                            " instead.", new Error("").stack);
-           }
-           return callback.apply(callback, arguments);
-       };
-   }
+   function deprecate(callback, name, alternative) {}

[Survived] BlockStatement
q.js:479:24
-       return function () {
-           if (typeof console !== "undefined" &&
-               typeof console.warn === "function") {
-               console.warn(name + " is deprecated, use " + alternative +
-                            " instead.", new Error("").stack);
-           }
-           return callback.apply(callback, arguments);
-       };
+       return function () {};

[Survived] ConditionalExpression
q.js:480:13
-           if (typeof console !== "undefined" &&
-               typeof console.warn === "function") {
+           if (true) {

[Survived] ConditionalExpression
q.js:480:13
-           if (typeof console !== "undefined" &&
-               typeof console.warn === "function") {
+           if (false) {

[Survived] LogicalOperator
q.js:480:13
-           if (typeof console !== "undefined" &&
-               typeof console.warn === "function") {
+           if (typeof console !== "undefined" || typeof console.warn === "function") {

[Survived] ConditionalExpression
q.js:480:13
-           if (typeof console !== "undefined" &&
+           if (true &&

[Survived] EqualityOperator
q.js:480:13
-           if (typeof console !== "undefined" &&
+           if (typeof console === "undefined" &&

[Survived] StringLiteral
q.js:480:32
-           if (typeof console !== "undefined" &&
+           if (typeof console !== "" &&

[Survived] ConditionalExpression
q.js:481:13
-               typeof console.warn === "function") {
+               true) {

[Survived] EqualityOperator
q.js:481:13
-               typeof console.warn === "function") {
+               typeof console.warn !== "function") {

[Survived] StringLiteral
q.js:481:37
-               typeof console.warn === "function") {
+               typeof console.warn === "") {

[Survived] BlockStatement
q.js:481:49
-               typeof console.warn === "function") {
-               console.warn(name + " is deprecated, use " + alternative +
-                            " instead.", new Error("").stack);
-           }
+               typeof console.warn === "function") {}

[Survived] StringLiteral
q.js:482:33
-               console.warn(name + " is deprecated, use " + alternative +
+               console.warn(name + "" + alternative +

[Survived] StringLiteral
q.js:483:26
-                            " instead.", new Error("").stack);
+                            "", new Error("").stack);

[Survived] StringLiteral
q.js:483:49
-                            " instead.", new Error("").stack);
+                            " instead.", new Error("Stryker was here!").stack);

[Survived] ConditionalExpression
q.js:501:9
-       if (value instanceof Promise) {
+       if (false) {

[Survived] BlockStatement
q.js:501:35
-       if (value instanceof Promise) {
-           return value;
-       }
+       if (value instanceof Promise) {}

[Survived] BooleanLiteral
q.js:523:22
-   Q.longStackSupport = false;
+   Q.longStackSupport = true;

[Survived] ConditionalExpression
q.js:534:5
-   if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
+   if (true) {

[Survived] ConditionalExpression
q.js:534:5
-   if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
+   if (false) {

[Survived] LogicalOperator
q.js:534:5
-   if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
+   if (typeof process === "object" && process && process.env || process.env.Q_DEBUG) {

[Survived] ConditionalExpression
q.js:534:5
-   if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
+   if (true && process.env.Q_DEBUG) {

[Survived] LogicalOperator
q.js:534:5
-   if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
+   if (typeof process === "object" && process || process.env && process.env.Q_DEBUG) {

[Survived] ConditionalExpression
q.js:534:5
-   if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
+   if (true && process.env && process.env.Q_DEBUG) {

[Survived] LogicalOperator
q.js:534:5
-   if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
+   if (typeof process === "object" || process && process.env && process.env.Q_DEBUG) {

[Survived] ConditionalExpression
q.js:534:5
-   if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
+   if (true && process && process.env && process.env.Q_DEBUG) {

[Survived] EqualityOperator
q.js:534:5
-   if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
+   if (typeof process !== "object" && process && process.env && process.env.Q_DEBUG) {

[Survived] StringLiteral
q.js:534:24
-   if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
+   if (typeof process === "" && process && process.env && process.env.Q_DEBUG) {

[Survived] BlockStatement
q.js:534:83
-   if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
-       Q.longStackSupport = true;
-   }
+   if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {}

[Survived] BooleanLiteral
q.js:535:26
-       Q.longStackSupport = true;
+       Q.longStackSupport = false;

[Survived] ArrayDeclaration
q.js:556:44
-       var messages = [], progressListeners = [], resolvedPromise;
+       var messages = [], progressListeners = ["Stryker was here"], resolvedPromise;

[Survived] ConditionalExpression
q.js:565:17
-               if (op === "when" && operands[1]) { // progress operand
+               if (true) { // progress operand

[Survived] ConditionalExpression
q.js:565:17
-               if (op === "when" && operands[1]) { // progress operand
+               if (false) { // progress operand

[Survived] LogicalOperator
q.js:565:17
-               if (op === "when" && operands[1]) { // progress operand
+               if (op === "when" || operands[1]) { // progress operand

[Survived] ConditionalExpression
q.js:565:17
-               if (op === "when" && operands[1]) { // progress operand
+               if (true && operands[1]) { // progress operand

[Survived] EqualityOperator
q.js:565:17
-               if (op === "when" && operands[1]) { // progress operand
+               if (op !== "when" && operands[1]) { // progress operand

[Survived] StringLiteral
q.js:565:24
-               if (op === "when" && operands[1]) { // progress operand
+               if (op === "" && operands[1]) { // progress operand

[Survived] BlockStatement
q.js:565:47
-               if (op === "when" && operands[1]) { // progress operand
-                   progressListeners.push(operands[1]);
-               }
+               if (op === "when" && operands[1]) {}

[Survived] BlockStatement
q.js:576:35
-       promise.valueOf = function () {
-           if (messages) {
-               return promise;
-           }
-           var nearerValue = nearer(resolvedPromise);
-           if (isPromise(nearerValue)) {
-               resolvedPromise = nearerValue; // shorten chain
-           }
-           return nearerValue;
-       };
+       promise.valueOf = function () {};

[Survived] ConditionalExpression
q.js:577:13
-           if (messages) {
+           if (true) {

[Survived] ConditionalExpression
q.js:577:13
-           if (messages) {
+           if (false) {

[Survived] BlockStatement
q.js:577:23
-           if (messages) {
-               return promise;
-           }
+           if (messages) {}

[Survived] ConditionalExpression
q.js:581:13
-           if (isPromise(nearerValue)) {
+           if (true) {

[Survived] ConditionalExpression
q.js:581:13
-           if (isPromise(nearerValue)) {
+           if (false) {

[Survived] BlockStatement
q.js:581:37
-           if (isPromise(nearerValue)) {
-               resolvedPromise = nearerValue; // shorten chain
-           }
+           if (isPromise(nearerValue)) {}

[Survived] BlockStatement
q.js:587:35
-       promise.inspect = function () {
-           if (!resolvedPromise) {
-               return { state: "pending" };
-           }
-           return resolvedPromise.inspect();
-       };
+       promise.inspect = function () {};

[Survived] BooleanLiteral
q.js:588:13
-           if (!resolvedPromise) {
+           if (resolvedPromise) {

[Survived] ConditionalExpression
q.js:588:13
-           if (!resolvedPromise) {
+           if (true) {

[Survived] ConditionalExpression
q.js:588:13
-           if (!resolvedPromise) {
+           if (false) {

[Survived] BlockStatement
q.js:588:31
-           if (!resolvedPromise) {
-               return { state: "pending" };
-           }
+           if (!resolvedPromise) {}

[Survived] ObjectLiteral
q.js:589:20
-               return { state: "pending" };
+               return {};

[Survived] StringLiteral
q.js:589:29
-               return { state: "pending" };
+               return { state: "" };

[Survived] ConditionalExpression
q.js:594:9
-       if (Q.longStackSupport && hasStacks) {
+       if (true) {

[Survived] ConditionalExpression
q.js:594:9
-       if (Q.longStackSupport && hasStacks) {
+       if (false) {

[Survived] LogicalOperator
q.js:594:9
-       if (Q.longStackSupport && hasStacks) {
+       if (Q.longStackSupport || hasStacks) {

[Survived] BlockStatement
q.js:594:42
-       if (Q.longStackSupport && hasStacks) {
-           try {
-               throw new Error();
-           } catch (e) {
-               // NOTE: don't try to use `Error.captureStackTrace` or transfer the
-               // accessor around; that causes memory leaks as per GH-111. Just
-               // reify the stack trace as a string ASAP.
-               //
-               // At the same time, cut off the first line; it's always just
-               // "[object Promise]\n", as per the `toString`.
-               promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
-               promise.stackCounter = longStackCounter++;
-           }
-       }
+       if (Q.longStackSupport && hasStacks) {}

[Survived] BlockStatement
q.js:595:13
-           try {
-               throw new Error();
-           } catch (e) {
+           try {} catch (e) {

[Survived] BlockStatement
q.js:597:21
-           } catch (e) {
-               // NOTE: don't try to use `Error.captureStackTrace` or transfer the
-               // accessor around; that causes memory leaks as per GH-111. Just
-               // reify the stack trace as a string ASAP.
-               //
-               // At the same time, cut off the first line; it's always just
-               // "[object Promise]\n", as per the `toString`.
-               promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
-               promise.stackCounter = longStackCounter++;
-           }
+           } catch (e) {}

[Survived] MethodExpression
q.js:604:29
-               promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
+               promise.stack = e.stack;

[Survived] ArithmeticOperator
q.js:604:47
-               promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
+               promise.stack = e.stack.substring(e.stack.indexOf("\n") - 1);

[Survived] StringLiteral
q.js:604:63
-               promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
+               promise.stack = e.stack.substring(e.stack.indexOf("") + 1);

[Survived] UpdateOperator
q.js:605:36
-               promise.stackCounter = longStackCounter++;
+               promise.stackCounter = longStackCounter--;

[Survived] ConditionalExpression
q.js:616:13
-           if (Q.longStackSupport && hasStacks) {
+           if (true) {

[Survived] ConditionalExpression
q.js:616:13
-           if (Q.longStackSupport && hasStacks) {
+           if (false) {

[Survived] LogicalOperator
q.js:616:13
-           if (Q.longStackSupport && hasStacks) {
+           if (Q.longStackSupport || hasStacks) {

[Survived] BlockStatement
q.js:616:46
-           if (Q.longStackSupport && hasStacks) {
-               // Only hold a reference to the new promise if long stacks
-               // are enabled to reduce memory usage
-               promise.source = newPromise;
-           }
+           if (Q.longStackSupport && hasStacks) {}

[Survived] BlockStatement
q.js:641:41
-       deferred.fulfill = function (value) {
-           if (resolvedPromise) {
-               return;
-           }
-           become(fulfill(value));
-       };
+       deferred.fulfill = function (value) {};

[Survived] ConditionalExpression
q.js:642:13
-           if (resolvedPromise) {
+           if (true) {

[Survived] ConditionalExpression
q.js:642:13
-           if (resolvedPromise) {
+           if (false) {

[Survived] BlockStatement
q.js:642:30
-           if (resolvedPromise) {
-               return;
-           }
+           if (resolvedPromise) {}

[Survived] BlockStatement
q.js:655:43
-       deferred.notify = function (progress) {
-           if (resolvedPromise) {
-               return;
-           }
-           array_reduce(progressListeners, function (undefined, progressListener) {
-               Q.nextTick(function () {
-                   progressListener(progress);
-               });
-           }, void 0);
-       };
+       deferred.notify = function (progress) {};

[Survived] ConditionalExpression
q.js:656:13
-           if (resolvedPromise) {
+           if (true) {

[Survived] ConditionalExpression
q.js:656:13
-           if (resolvedPromise) {
+           if (false) {

[Survived] BlockStatement
q.js:656:30
-           if (resolvedPromise) {
-               return;
-           }
+           if (resolvedPromise) {}

[Survived] BlockStatement
q.js:660:80
-           array_reduce(progressListeners, function (undefined, progressListener) {
-               Q.nextTick(function () {
-                   progressListener(progress);
-               });
-           }, void 0);
+           array_reduce(progressListeners, function (undefined, progressListener) {}, void 0);

[Survived] BlockStatement
q.js:661:36
-               Q.nextTick(function () {
-                   progressListener(progress);
-               });
+               Q.nextTick(function () {});

[Survived] BlockStatement
q.js:675:48
-   defer.prototype.makeNodeResolver = function () {
-       var self = this;
-       return function (error, value) {
-           if (error) {
-               self.reject(error);
-           } else if (arguments.length > 2) {
-               self.resolve(array_slice(arguments, 1));
-           } else {
-               self.resolve(value);
-           }
-       };
-   };
+   defer.prototype.makeNodeResolver = function () {};

[Survived] BlockStatement
q.js:677:36
-       return function (error, value) {
-           if (error) {
-               self.reject(error);
-           } else if (arguments.length > 2) {
-               self.resolve(array_slice(arguments, 1));
-           } else {
-               self.resolve(value);
-           }
-       };
+       return function (error, value) {};

[Survived] ConditionalExpression
q.js:678:13
-           if (error) {
+           if (true) {

[Survived] ConditionalExpression
q.js:678:13
-           if (error) {
+           if (false) {

[Survived] BlockStatement
q.js:678:20
-           if (error) {
-               self.reject(error);
-           } else if (arguments.length > 2) {
+           if (error) {} else if (arguments.length > 2) {

[Survived] ConditionalExpression
q.js:680:20
-           } else if (arguments.length > 2) {
+           } else if (true) {

[Survived] ConditionalExpression
q.js:680:20
-           } else if (arguments.length > 2) {
+           } else if (false) {

[Survived] EqualityOperator
q.js:680:20
-           } else if (arguments.length > 2) {
+           } else if (arguments.length >= 2) {

[Survived] EqualityOperator
q.js:680:20
-           } else if (arguments.length > 2) {
+           } else if (arguments.length <= 2) {

[Survived] BlockStatement
q.js:680:42
-           } else if (arguments.length > 2) {
-               self.resolve(array_slice(arguments, 1));
-           } else {
+           } else if (arguments.length > 2) {} else {

[Survived] BlockStatement
q.js:682:16
-           } else {
-               self.resolve(value);
-           }
+           } else {}

[Survived] BlockStatement
q.js:696:28
-   function promise(resolver) {
-       if (typeof resolver !== "function") {
-           throw new TypeError("resolver must be a function.");
-       }
-       var deferred = defer();
-       try {
-           resolver(deferred.resolve, deferred.reject, deferred.notify);
-       } catch (reason) {
-           deferred.reject(reason);
-       }
-       return deferred.promise;
-   }
+   function promise(resolver) {}

[Survived] ConditionalExpression
q.js:697:9
-       if (typeof resolver !== "function") {
+       if (true) {

[Survived] ConditionalExpression
q.js:697:9
-       if (typeof resolver !== "function") {
+       if (false) {

[Survived] EqualityOperator
q.js:697:9
-       if (typeof resolver !== "function") {
+       if (typeof resolver === "function") {

[Survived] StringLiteral
q.js:697:29
-       if (typeof resolver !== "function") {
+       if (typeof resolver !== "") {

[Survived] BlockStatement
q.js:697:41
-       if (typeof resolver !== "function") {
-           throw new TypeError("resolver must be a function.");
-       }
+       if (typeof resolver !== "function") {}

[Survived] StringLiteral
q.js:698:29
-           throw new TypeError("resolver must be a function.");
+           throw new TypeError("");

[Survived] BlockStatement
q.js:701:9
-       try {
-           resolver(deferred.resolve, deferred.reject, deferred.notify);
-       } catch (reason) {
+       try {} catch (reason) {

[Survived] BlockStatement
q.js:703:22
-       } catch (reason) {
-           deferred.reject(reason);
-       }
+       } catch (reason) {}

[Survived] BlockStatement
q.js:717:34
-   Q.passByCopy = function (object) {
-       //freeze(object);
-       //passByCopies.set(object, true);
-       return object;
-   };
+   Q.passByCopy = function (object) {};

[Survived] BlockStatement
q.js:723:44
-   Promise.prototype.passByCopy = function () {
-       //freeze(object);
-       //passByCopies.set(object, true);
-       return this;
-   };
+   Promise.prototype.passByCopy = function () {};

[Survived] BlockStatement
q.js:738:26
-   Q.join = function (x, y) {
-       return Q(x).join(y);
-   };
+   Q.join = function (x, y) {};

[Survived] BlockStatement
q.js:742:42
-   Promise.prototype.join = function (that) {
-       return Q([this, that]).spread(function (x, y) {
-           if (x === y) {
-               // TODO: "===" should be Object.is or equiv
-               return x;
-           } else {
-               throw new Error("Q can't join: not the same: " + x + " " + y);
-           }
-       });
-   };
+   Promise.prototype.join = function (that) {};

[Survived] ArrayDeclaration
q.js:743:14
-       return Q([this, that]).spread(function (x, y) {
+       return Q([]).spread(function (x, y) {

[Survived] BlockStatement
q.js:743:51
-       return Q([this, that]).spread(function (x, y) {
-           if (x === y) {
-               // TODO: "===" should be Object.is or equiv
-               return x;
-           } else {
-               throw new Error("Q can't join: not the same: " + x + " " + y);
-           }
-       });
+       return Q([this, that]).spread(function (x, y) {});

[Survived] ConditionalExpression
q.js:744:13
-           if (x === y) {
+           if (true) {

[Survived] ConditionalExpression
q.js:744:13
-           if (x === y) {
+           if (false) {

[Survived] EqualityOperator
q.js:744:13
-           if (x === y) {
+           if (x !== y) {

[Survived] BlockStatement
q.js:744:22
-           if (x === y) {
-               // TODO: "===" should be Object.is or equiv
-               return x;
-           } else {
+           if (x === y) {} else {

[Survived] BlockStatement
q.js:747:16
-           } else {
-               throw new Error("Q can't join: not the same: " + x + " " + y);
-           }
+           } else {}

[Survived] StringLiteral
q.js:748:29
-               throw new Error("Q can't join: not the same: " + x + " " + y);
+               throw new Error("" + x + " " + y);

[Survived] StringLiteral
q.js:748:66
-               throw new Error("Q can't join: not the same: " + x + " " + y);
+               throw new Error("Q can't join: not the same: " + x + "" + y);

[Survived] BlockStatement
q.js:759:25
-   function race(answerPs) {
-       return promise(function (resolve, reject) {
-           // Switch to this once we can assume at least ES5
-           // answerPs.forEach(function (answerP) {
-           //     Q(answerP).then(resolve, reject);
-           // });
-           // Use this in the meantime
-           for (var i = 0, len = answerPs.length; i < len; i++) {
-               Q(answerPs[i]).then(resolve, reject);
-           }
-       });
-   }
+   function race(answerPs) {}

[Survived] BlockStatement
q.js:760:47
-       return promise(function (resolve, reject) {
-           // Switch to this once we can assume at least ES5
-           // answerPs.forEach(function (answerP) {
-           //     Q(answerP).then(resolve, reject);
-           // });
-           // Use this in the meantime
-           for (var i = 0, len = answerPs.length; i < len; i++) {
-               Q(answerPs[i]).then(resolve, reject);
-           }
-       });
+       return promise(function (resolve, reject) {});

[Survived] ConditionalExpression
q.js:766:48
-           for (var i = 0, len = answerPs.length; i < len; i++) {
+           for (var i = 0, len = answerPs.length; false; i++) {

[Survived] EqualityOperator
q.js:766:48
-           for (var i = 0, len = answerPs.length; i < len; i++) {
+           for (var i = 0, len = answerPs.length; i <= len; i++) {

[Survived] EqualityOperator
q.js:766:48
-           for (var i = 0, len = answerPs.length; i < len; i++) {
+           for (var i = 0, len = answerPs.length; i >= len; i++) {

[Survived] UpdateOperator
q.js:766:57
-           for (var i = 0, len = answerPs.length; i < len; i++) {
+           for (var i = 0, len = answerPs.length; i < len; i--) {

[Survived] BlockStatement
q.js:766:62
-           for (var i = 0, len = answerPs.length; i < len; i++) {
-               Q(answerPs[i]).then(resolve, reject);
-           }
+           for (var i = 0, len = answerPs.length; i < len; i++) {}

[Survived] BlockStatement
q.js:772:38
-   Promise.prototype.race = function () {
-       return this.then(Q.race);
-   };
+   Promise.prototype.race = function () {};

[Survived] ConditionalExpression
q.js:789:9
-       if (fallback === void 0) {
+       if (true) {

[Survived] ConditionalExpression
q.js:789:9
-       if (fallback === void 0) {
+       if (false) {

[Survived] EqualityOperator
q.js:789:9
-       if (fallback === void 0) {
+       if (fallback !== void 0) {

[Survived] BlockStatement
q.js:789:30
-       if (fallback === void 0) {
-           fallback = function (op) {
-               return reject(new Error(
-                   "Promise does not support operation: " + op
-               ));
-           };
-       }
+       if (fallback === void 0) {}

[Survived] BlockStatement
q.js:790:34
-           fallback = function (op) {
-               return reject(new Error(
-                   "Promise does not support operation: " + op
-               ));
-           };
+           fallback = function (op) {};

[Survived] StringLiteral
q.js:792:17
-                   "Promise does not support operation: " + op
+                   "" + op

[Survived] ConditionalExpression
q.js:796:9
-       if (inspect === void 0) {
+       if (true) {

[Survived] ConditionalExpression
q.js:796:9
-       if (inspect === void 0) {
+       if (false) {

[Survived] EqualityOperator
q.js:796:9
-       if (inspect === void 0) {
+       if (inspect !== void 0) {

[Survived] BlockStatement
q.js:796:29
-       if (inspect === void 0) {
-           inspect = function () {
-               return {state: "unknown"};
-           };
-       }
+       if (inspect === void 0) {}

[Survived] BlockStatement
q.js:797:31
-           inspect = function () {
-               return {state: "unknown"};
-           };
+           inspect = function () {};

[Survived] ObjectLiteral
q.js:798:20
-               return {state: "unknown"};
+               return {};

[Survived] StringLiteral
q.js:798:28
-               return {state: "unknown"};
+               return {state: ""};

[Survived] ConditionalExpression
q.js:807:17
-               if (descriptor[op]) {
+               if (true) {

[Survived] BlockStatement
q.js:809:20
-               } else {
-                   result = fallback.call(promise, op, args);
-               }
+               } else {}

[Survived] BlockStatement
q.js:812:29
-           } catch (exception) {
-               result = reject(exception);
-           }
+           } catch (exception) {}

[Survived] ConditionalExpression
q.js:823:9
-       if (inspect) {
+       if (true) {

[Survived] ConditionalExpression
q.js:823:9
-       if (inspect) {
+       if (false) {

[Survived] BlockStatement
q.js:823:18
-       if (inspect) {
-           var inspected = inspect();
-           if (inspected.state === "rejected") {
-               promise.exception = inspected.reason;
-           }
-           promise.valueOf = function () {
-               var inspected = inspect();
-               if (inspected.state === "pending" ||
-                   inspected.state === "rejected") {
-                   return promise;
-               }
-               return inspected.value;
-           };
-       }
+       if (inspect) {}

[Survived] ConditionalExpression
q.js:825:13
-           if (inspected.state === "rejected") {
+           if (true) {

[Survived] ConditionalExpression
q.js:825:13
-           if (inspected.state === "rejected") {
+           if (false) {

[Survived] EqualityOperator
q.js:825:13
-           if (inspected.state === "rejected") {
+           if (inspected.state !== "rejected") {

[Survived] StringLiteral
q.js:825:33
-           if (inspected.state === "rejected") {
+           if (inspected.state === "") {

[Survived] BlockStatement
q.js:825:45
-           if (inspected.state === "rejected") {
-               promise.exception = inspected.reason;
-           }
+           if (inspected.state === "rejected") {}

[Survived] BlockStatement
q.js:829:39
-           promise.valueOf = function () {
-               var inspected = inspect();
-               if (inspected.state === "pending" ||
-                   inspected.state === "rejected") {
-                   return promise;
-               }
-               return inspected.value;
-           };
+           promise.valueOf = function () {};

[Survived] ConditionalExpression
q.js:831:17
-               if (inspected.state === "pending" ||
-                   inspected.state === "rejected") {
+               if (true) {

[Survived] ConditionalExpression
q.js:831:17
-               if (inspected.state === "pending" ||
-                   inspected.state === "rejected") {
+               if (false) {

[Survived] LogicalOperator
q.js:831:17
-               if (inspected.state === "pending" ||
-                   inspected.state === "rejected") {
+               if (inspected.state === "pending" && inspected.state === "rejected") {

[Survived] ConditionalExpression
q.js:831:17
-               if (inspected.state === "pending" ||
+               if (false ||

[Survived] EqualityOperator
q.js:831:17
-               if (inspected.state === "pending" ||
+               if (inspected.state !== "pending" ||

[Survived] StringLiteral
q.js:831:37
-               if (inspected.state === "pending" ||
+               if (inspected.state === "" ||

[Survived] ConditionalExpression
q.js:832:17
-                   inspected.state === "rejected") {
+                   false) {

[Survived] EqualityOperator
q.js:832:17
-                   inspected.state === "rejected") {
+                   inspected.state !== "rejected") {

[Survived] StringLiteral
q.js:832:37
-                   inspected.state === "rejected") {
+                   inspected.state === "") {

[Survived] BlockStatement
q.js:832:49
-                   inspected.state === "rejected") {
-                   return promise;
-               }
+                   inspected.state === "rejected") {}

[Survived] BlockStatement
q.js:842:42
-   Promise.prototype.toString = function () {
-       return "[object Promise]";
-   };
+   Promise.prototype.toString = function () {};

[Survived] StringLiteral
q.js:843:12
-       return "[object Promise]";
+       return "";

[Survived] BlockStatement
q.js:872:33
-       function _progressed(value) {
-           return typeof progressed === "function" ? progressed(value) : value;
-       }
+       function _progressed(value) {}

[Survived] ConditionalExpression
q.js:873:16
-           return typeof progressed === "function" ? progressed(value) : value;
+           return true ? progressed(value) : value;

[Survived] ConditionalExpression
q.js:873:16
-           return typeof progressed === "function" ? progressed(value) : value;
+           return false ? progressed(value) : value;

[Survived] EqualityOperator
q.js:873:16
-           return typeof progressed === "function" ? progressed(value) : value;
+           return typeof progressed !== "function" ? progressed(value) : value;

[Survived] StringLiteral
q.js:873:38
-           return typeof progressed === "function" ? progressed(value) : value;
+           return typeof progressed === "" ? progressed(value) : value;

[Survived] BooleanLiteral
q.js:881:20
-               done = true;
+               done = false;

[Survived] ConditionalExpression
q.js:885:17
-               if (done) {
+               if (false) {

[Survived] BlockStatement
q.js:885:23
-               if (done) {
-                   return;
-               }
+               if (done) {}

[Survived] StringLiteral
q.js:895:34
-       self.promiseDispatch(void 0, "when", [void 0, function (value) {
+       self.promiseDispatch(void 0, "", [void 0, function (value) {

[Survived] ArrayDeclaration
q.js:895:42
-       self.promiseDispatch(void 0, "when", [void 0, function (value) {
-           var newValue;
-           var threw = false;
-           try {
-               newValue = _progressed(value);
-           } catch (e) {
-               threw = true;
-               if (Q.onerror) {
-                   Q.onerror(e);
-               } else {
-                   throw e;
-               }
-           }
-           if (!threw) {
-               deferred.notify(newValue);
-           }
-       }]);
+       self.promiseDispatch(void 0, "when", []);

[Survived] BlockStatement
q.js:895:68
-       self.promiseDispatch(void 0, "when", [void 0, function (value) {
-           var newValue;
-           var threw = false;
-           try {
-               newValue = _progressed(value);
-           } catch (e) {
-               threw = true;
-               if (Q.onerror) {
-                   Q.onerror(e);
-               } else {
-                   throw e;
-               }
-           }
-           if (!threw) {
-               deferred.notify(newValue);
-           }
-       }]);
+       self.promiseDispatch(void 0, "when", [void 0, function (value) {}]);

[Survived] BooleanLiteral
q.js:897:21
-           var threw = false;
+           var threw = true;

[Survived] BlockStatement
q.js:898:13
-           try {
-               newValue = _progressed(value);
-           } catch (e) {
+           try {} catch (e) {

[Survived] BlockStatement
q.js:900:21
-           } catch (e) {
-               threw = true;
-               if (Q.onerror) {
-                   Q.onerror(e);
-               } else {
-                   throw e;
-               }
-           }
+           } catch (e) {}

[Survived] BooleanLiteral
q.js:901:21
-               threw = true;
+               threw = false;

[Survived] ConditionalExpression
q.js:902:17
-               if (Q.onerror) {
+               if (true) {

[Survived] ConditionalExpression
q.js:902:17
-               if (Q.onerror) {
+               if (false) {

[Survived] BlockStatement
q.js:902:28
-               if (Q.onerror) {
-                   Q.onerror(e);
-               } else {
+               if (Q.onerror) {} else {

[Survived] BlockStatement
q.js:904:20
-               } else {
-                   throw e;
-               }
+               } else {}

[Survived] BooleanLiteral
q.js:909:13
-           if (!threw) {
+           if (threw) {

[Survived] ConditionalExpression
q.js:909:13
-           if (!threw) {
+           if (true) {

[Survived] ConditionalExpression
q.js:909:13
-           if (!threw) {
+           if (false) {

[Survived] BlockStatement
q.js:909:21
-           if (!threw) {
-               deferred.notify(newValue);
-           }
+           if (!threw) {}

[Survived] BlockStatement
q.js:917:38
-   Q.tap = function (promise, callback) {
-       return Q(promise).tap(callback);
-   };
+   Q.tap = function (promise, callback) {};

[Survived] BlockStatement
q.js:933:45
-   Promise.prototype.tap = function (callback) {
-       callback = Q(callback);
-       return this.then(function (value) {
-           return callback.fcall(value).thenResolve(value);
-       });
-   };
+   Promise.prototype.tap = function (callback) {};

[Survived] BlockStatement
q.js:936:39
-       return this.then(function (value) {
-           return callback.fcall(value).thenResolve(value);
-       });
+       return this.then(function (value) {});

[Survived] BlockStatement
q.js:958:55
-   function when(value, fulfilled, rejected, progressed) {
-       return Q(value).then(fulfilled, rejected, progressed);
-   }
+   function when(value, fulfilled, rejected, progressed) {}

[Survived] BlockStatement
q.js:962:50
-   Promise.prototype.thenResolve = function (value) {
-       return this.then(function () { return value; });
-   };
+   Promise.prototype.thenResolve = function (value) {};

[Survived] BlockStatement
q.js:963:34
-       return this.then(function () { return value; });
+       return this.then(function () {});

[Survived] BlockStatement
q.js:966:43
-   Q.thenResolve = function (promise, value) {
-       return Q(promise).thenResolve(value);
-   };
+   Q.thenResolve = function (promise, value) {};

[Survived] BlockStatement
q.js:970:50
-   Promise.prototype.thenReject = function (reason) {
-       return this.then(function () { throw reason; });
-   };
+   Promise.prototype.thenReject = function (reason) {};

[Survived] BlockStatement
q.js:971:34
-       return this.then(function () { throw reason; });
+       return this.then(function () {});

[Survived] BlockStatement
q.js:974:43
-   Q.thenReject = function (promise, reason) {
-       return Q(promise).thenReject(reason);
-   };
+   Q.thenReject = function (promise, reason) {};

[Survived] BlockStatement
q.js:990:24
-   function nearer(value) {
-       if (isPromise(value)) {
-           var inspected = value.inspect();
-           if (inspected.state === "fulfilled") {
-               return inspected.value;
-           }
-       }
-       return value;
-   }
+   function nearer(value) {}

[Survived] ConditionalExpression
q.js:991:9
-       if (isPromise(value)) {
+       if (true) {

[Survived] ConditionalExpression
q.js:991:9
-       if (isPromise(value)) {
+       if (false) {

[Survived] BlockStatement
q.js:991:27
-       if (isPromise(value)) {
-           var inspected = value.inspect();
-           if (inspected.state === "fulfilled") {
-               return inspected.value;
-           }
-       }
+       if (isPromise(value)) {}

[Survived] ConditionalExpression
q.js:993:13
-           if (inspected.state === "fulfilled") {
+           if (true) {

[Survived] ConditionalExpression
q.js:993:13
-           if (inspected.state === "fulfilled") {
+           if (false) {

[Survived] EqualityOperator
q.js:993:13
-           if (inspected.state === "fulfilled") {
+           if (inspected.state !== "fulfilled") {

[Survived] StringLiteral
q.js:993:33
-           if (inspected.state === "fulfilled") {
+           if (inspected.state === "") {

[Survived] BlockStatement
q.js:993:46
-           if (inspected.state === "fulfilled") {
-               return inspected.value;
-           }
+           if (inspected.state === "fulfilled") {}

[Survived] BlockStatement
q.js:1005:28
-   function isPromise(object) {
-       return object instanceof Promise;
-   }
+   function isPromise(object) {}

[Survived] BlockStatement
q.js:1019:28
-   function isPending(object) {
-       return isPromise(object) && object.inspect().state === "pending";
-   }
+   function isPending(object) {}

[Survived] ConditionalExpression
q.js:1020:12
-       return isPromise(object) && object.inspect().state === "pending";
+       return true;

[Survived] ConditionalExpression
q.js:1020:12
-       return isPromise(object) && object.inspect().state === "pending";
+       return false;

[Survived] LogicalOperator
q.js:1020:12
-       return isPromise(object) && object.inspect().state === "pending";
+       return isPromise(object) || object.inspect().state === "pending";

[Survived] ConditionalExpression
q.js:1020:33
-       return isPromise(object) && object.inspect().state === "pending";
+       return isPromise(object) && true;

[Survived] EqualityOperator
q.js:1020:33
-       return isPromise(object) && object.inspect().state === "pending";
+       return isPromise(object) && object.inspect().state !== "pending";

[Survived] StringLiteral
q.js:1020:60
-       return isPromise(object) && object.inspect().state === "pending";
+       return isPromise(object) && object.inspect().state === "";

[Survived] BlockStatement
q.js:1023:43
-   Promise.prototype.isPending = function () {
-       return this.inspect().state === "pending";
-   };
+   Promise.prototype.isPending = function () {};

[Survived] ConditionalExpression
q.js:1024:12
-       return this.inspect().state === "pending";
+       return true;

[Survived] ConditionalExpression
q.js:1024:12
-       return this.inspect().state === "pending";
+       return false;

[Survived] EqualityOperator
q.js:1024:12
-       return this.inspect().state === "pending";
+       return this.inspect().state !== "pending";

[Survived] StringLiteral
q.js:1024:37
-       return this.inspect().state === "pending";
+       return this.inspect().state === "";

[Survived] BlockStatement
q.js:1032:30
-   function isFulfilled(object) {
-       return !isPromise(object) || object.inspect().state === "fulfilled";
-   }
+   function isFulfilled(object) {}

[Survived] ConditionalExpression
q.js:1033:12
-       return !isPromise(object) || object.inspect().state === "fulfilled";
+       return true;

[Survived] ConditionalExpression
q.js:1033:12
-       return !isPromise(object) || object.inspect().state === "fulfilled";
+       return false;

[Survived] LogicalOperator
q.js:1033:12
-       return !isPromise(object) || object.inspect().state === "fulfilled";
+       return !isPromise(object) && object.inspect().state === "fulfilled";

[Survived] BooleanLiteral
q.js:1033:12
-       return !isPromise(object) || object.inspect().state === "fulfilled";
+       return isPromise(object) || object.inspect().state === "fulfilled";

[Survived] ConditionalExpression
q.js:1033:34
-       return !isPromise(object) || object.inspect().state === "fulfilled";
+       return !isPromise(object) || false;

[Survived] EqualityOperator
q.js:1033:34
-       return !isPromise(object) || object.inspect().state === "fulfilled";
+       return !isPromise(object) || object.inspect().state !== "fulfilled";

[Survived] StringLiteral
q.js:1033:61
-       return !isPromise(object) || object.inspect().state === "fulfilled";
+       return !isPromise(object) || object.inspect().state === "";

[Survived] BlockStatement
q.js:1036:45
-   Promise.prototype.isFulfilled = function () {
-       return this.inspect().state === "fulfilled";
-   };
+   Promise.prototype.isFulfilled = function () {};

[Survived] ConditionalExpression
q.js:1037:12
-       return this.inspect().state === "fulfilled";
+       return true;

[Survived] ConditionalExpression
q.js:1037:12
-       return this.inspect().state === "fulfilled";
+       return false;

[Survived] EqualityOperator
q.js:1037:12
-       return this.inspect().state === "fulfilled";
+       return this.inspect().state !== "fulfilled";

[Survived] StringLiteral
q.js:1037:37
-       return this.inspect().state === "fulfilled";
+       return this.inspect().state === "";

[Survived] BlockStatement
q.js:1044:29
-   function isRejected(object) {
-       return isPromise(object) && object.inspect().state === "rejected";
-   }
+   function isRejected(object) {}

[Survived] ConditionalExpression
q.js:1045:12
-       return isPromise(object) && object.inspect().state === "rejected";
+       return true;

[Survived] ConditionalExpression
q.js:1045:12
-       return isPromise(object) && object.inspect().state === "rejected";
+       return false;

[Survived] LogicalOperator
q.js:1045:12
-       return isPromise(object) && object.inspect().state === "rejected";
+       return isPromise(object) || object.inspect().state === "rejected";

[Survived] ConditionalExpression
q.js:1045:33
-       return isPromise(object) && object.inspect().state === "rejected";
+       return isPromise(object) && true;

[Survived] EqualityOperator
q.js:1045:33
-       return isPromise(object) && object.inspect().state === "rejected";
+       return isPromise(object) && object.inspect().state !== "rejected";

[Survived] StringLiteral
q.js:1045:60
-       return isPromise(object) && object.inspect().state === "rejected";
+       return isPromise(object) && object.inspect().state === "";

[Survived] BlockStatement
q.js:1048:44
-   Promise.prototype.isRejected = function () {
-       return this.inspect().state === "rejected";
-   };
+   Promise.prototype.isRejected = function () {};

[Survived] ConditionalExpression
q.js:1049:12
-       return this.inspect().state === "rejected";
+       return true;

[Survived] ConditionalExpression
q.js:1049:12
-       return this.inspect().state === "rejected";
+       return false;

[Survived] EqualityOperator
q.js:1049:12
-       return this.inspect().state === "rejected";
+       return this.inspect().state !== "rejected";

[Survived] StringLiteral
q.js:1049:37
-       return this.inspect().state === "rejected";
+       return this.inspect().state === "";

[Survived] ArrayDeclaration
q.js:1058:24
-   var unhandledReasons = [];
+   var unhandledReasons = ["Stryker was here"];

[Survived] ArrayDeclaration
q.js:1059:27
-   var unhandledRejections = [];
+   var unhandledRejections = ["Stryker was here"];

[Survived] ArrayDeclaration
q.js:1060:35
-   var reportedUnhandledRejections = [];
+   var reportedUnhandledRejections = ["Stryker was here"];

[Survived] BooleanLiteral
q.js:1061:32
-   var trackUnhandledRejections = true;
+   var trackUnhandledRejections = false;

[Survived] BlockStatement
q.js:1063:37
-   function resetUnhandledRejections() {
-       unhandledReasons.length = 0;
-       unhandledRejections.length = 0;
-       if (!trackUnhandledRejections) {
-           trackUnhandledRejections = true;
-       }
-   }
+   function resetUnhandledRejections() {}

[Survived] BooleanLiteral
q.js:1067:9
-       if (!trackUnhandledRejections) {
+       if (trackUnhandledRejections) {

[Survived] ConditionalExpression
q.js:1067:9
-       if (!trackUnhandledRejections) {
+       if (true) {

[Survived] ConditionalExpression
q.js:1067:9
-       if (!trackUnhandledRejections) {
+       if (false) {

[Survived] BlockStatement
q.js:1067:36
-       if (!trackUnhandledRejections) {
-           trackUnhandledRejections = true;
-       }
+       if (!trackUnhandledRejections) {}

[Survived] BooleanLiteral
q.js:1068:36
-           trackUnhandledRejections = true;
+           trackUnhandledRejections = false;

[Survived] BlockStatement
q.js:1072:42
-   function trackRejection(promise, reason) {
-       if (!trackUnhandledRejections) {
-           return;
-       }
-       if (typeof process === "object" && typeof process.emit === "function") {
-           Q.nextTick.runAfter(function () {
-               if (array_indexOf(unhandledRejections, promise) !== -1) {
-                   process.emit("unhandledRejection", reason, promise);
-                   reportedUnhandledRejections.push(promise);
-               }
-           });
-       }
-       unhandledRejections.push(promise);
-       if (reason && typeof reason.stack !== "undefined") {
-           unhandledReasons.push(reason.stack);
-       } else {
-           unhandledReasons.push("(no stack) " + reason);
-       }
-   }
+   function trackRejection(promise, reason) {}

[Survived] BooleanLiteral
q.js:1073:9
-       if (!trackUnhandledRejections) {
+       if (trackUnhandledRejections) {

[Survived] ConditionalExpression
q.js:1073:9
-       if (!trackUnhandledRejections) {
+       if (true) {

[Survived] ConditionalExpression
q.js:1073:9
-       if (!trackUnhandledRejections) {
+       if (false) {

[Survived] BlockStatement
q.js:1073:36
-       if (!trackUnhandledRejections) {
-           return;
-       }
+       if (!trackUnhandledRejections) {}

[Survived] ConditionalExpression
q.js:1076:9
-       if (typeof process === "object" && typeof process.emit === "function") {
+       if (true) {

[Survived] ConditionalExpression
q.js:1076:9
-       if (typeof process === "object" && typeof process.emit === "function") {
+       if (false) {

[Survived] LogicalOperator
q.js:1076:9
-       if (typeof process === "object" && typeof process.emit === "function") {
+       if (typeof process === "object" || typeof process.emit === "function") {

[Survived] ConditionalExpression
q.js:1076:9
-       if (typeof process === "object" && typeof process.emit === "function") {
+       if (true && typeof process.emit === "function") {

[Survived] EqualityOperator
q.js:1076:9
-       if (typeof process === "object" && typeof process.emit === "function") {
+       if (typeof process !== "object" && typeof process.emit === "function") {

[Survived] StringLiteral
q.js:1076:28
-       if (typeof process === "object" && typeof process.emit === "function") {
+       if (typeof process === "" && typeof process.emit === "function") {

[Survived] ConditionalExpression
q.js:1076:40
-       if (typeof process === "object" && typeof process.emit === "function") {
+       if (typeof process === "object" && true) {

[Survived] EqualityOperator
q.js:1076:40
-       if (typeof process === "object" && typeof process.emit === "function") {
+       if (typeof process === "object" && typeof process.emit !== "function") {

[Survived] StringLiteral
q.js:1076:64
-       if (typeof process === "object" && typeof process.emit === "function") {
+       if (typeof process === "object" && typeof process.emit === "") {

[Survived] BlockStatement
q.js:1076:76
-       if (typeof process === "object" && typeof process.emit === "function") {
-           Q.nextTick.runAfter(function () {
-               if (array_indexOf(unhandledRejections, promise) !== -1) {
-                   process.emit("unhandledRejection", reason, promise);
-                   reportedUnhandledRejections.push(promise);
-               }
-           });
-       }
+       if (typeof process === "object" && typeof process.emit === "function") {}

[Survived] BlockStatement
q.js:1077:41
-           Q.nextTick.runAfter(function () {
-               if (array_indexOf(unhandledRejections, promise) !== -1) {
-                   process.emit("unhandledRejection", reason, promise);
-                   reportedUnhandledRejections.push(promise);
-               }
-           });
+           Q.nextTick.runAfter(function () {});

[Survived] ConditionalExpression
q.js:1078:17
-               if (array_indexOf(unhandledRejections, promise) !== -1) {
+               if (true) {

[Survived] ConditionalExpression
q.js:1078:17
-               if (array_indexOf(unhandledRejections, promise) !== -1) {
+               if (false) {

[Survived] EqualityOperator
q.js:1078:17
-               if (array_indexOf(unhandledRejections, promise) !== -1) {
+               if (array_indexOf(unhandledRejections, promise) === -1) {

[Survived] UnaryOperator
q.js:1078:65
-               if (array_indexOf(unhandledRejections, promise) !== -1) {
+               if (array_indexOf(unhandledRejections, promise) !== +1) {

[Survived] BlockStatement
q.js:1078:69
-               if (array_indexOf(unhandledRejections, promise) !== -1) {
-                   process.emit("unhandledRejection", reason, promise);
-                   reportedUnhandledRejections.push(promise);
-               }
+               if (array_indexOf(unhandledRejections, promise) !== -1) {}

[Survived] StringLiteral
q.js:1079:30
-                   process.emit("unhandledRejection", reason, promise);
+                   process.emit("", reason, promise);

[Survived] ConditionalExpression
q.js:1086:9
-       if (reason && typeof reason.stack !== "undefined") {
+       if (false) {

[Survived] ConditionalExpression
q.js:1086:19
-       if (reason && typeof reason.stack !== "undefined") {
+       if (reason && true) {

[Survived] EqualityOperator
q.js:1086:19
-       if (reason && typeof reason.stack !== "undefined") {
+       if (reason && typeof reason.stack === "undefined") {

[Survived] StringLiteral
q.js:1086:43
-       if (reason && typeof reason.stack !== "undefined") {
+       if (reason && typeof reason.stack !== "") {

[Survived] BlockStatement
q.js:1086:56
-       if (reason && typeof reason.stack !== "undefined") {
-           unhandledReasons.push(reason.stack);
-       } else {
+       if (reason && typeof reason.stack !== "undefined") {} else {

[Survived] BlockStatement
q.js:1088:12
-       } else {
-           unhandledReasons.push("(no stack) " + reason);
-       }
+       } else {}

[Survived] StringLiteral
q.js:1089:31
-           unhandledReasons.push("(no stack) " + reason);
+           unhandledReasons.push("" + reason);

[Survived] BlockStatement
q.js:1093:36
-   function untrackRejection(promise) {
-       if (!trackUnhandledRejections) {
-           return;
-       }
-       var at = array_indexOf(unhandledRejections, promise);
-       if (at !== -1) {
-           if (typeof process === "object" && typeof process.emit === "function") {
-               Q.nextTick.runAfter(function () {
-                   var atReport = array_indexOf(reportedUnhandledRejections, promise);
-                   if (atReport !== -1) {
-                       process.emit("rejectionHandled", unhandledReasons[at], promise);
-                       reportedUnhandledRejections.splice(atReport, 1);
-                   }
-               });
-           }
-           unhandledRejections.splice(at, 1);
-           unhandledReasons.splice(at, 1);
-       }
-   }
+   function untrackRejection(promise) {}

[Survived] BooleanLiteral
q.js:1094:9
-       if (!trackUnhandledRejections) {
+       if (trackUnhandledRejections) {

[Survived] ConditionalExpression
q.js:1094:9
-       if (!trackUnhandledRejections) {
+       if (true) {

[Survived] ConditionalExpression
q.js:1094:9
-       if (!trackUnhandledRejections) {
+       if (false) {

[Survived] BlockStatement
q.js:1094:36
-       if (!trackUnhandledRejections) {
-           return;
-       }
+       if (!trackUnhandledRejections) {}

[Survived] ConditionalExpression
q.js:1099:9
-       if (at !== -1) {
+       if (true) {

[Survived] ConditionalExpression
q.js:1099:9
-       if (at !== -1) {
+       if (false) {

[Survived] EqualityOperator
q.js:1099:9
-       if (at !== -1) {
+       if (at === -1) {

[Survived] UnaryOperator
q.js:1099:16
-       if (at !== -1) {
+       if (at !== +1) {

[Survived] BlockStatement
q.js:1099:20
-       if (at !== -1) {
-           if (typeof process === "object" && typeof process.emit === "function") {
-               Q.nextTick.runAfter(function () {
-                   var atReport = array_indexOf(reportedUnhandledRejections, promise);
-                   if (atReport !== -1) {
-                       process.emit("rejectionHandled", unhandledReasons[at], promise);
-                       reportedUnhandledRejections.splice(atReport, 1);
-                   }
-               });
-           }
-           unhandledRejections.splice(at, 1);
-           unhandledReasons.splice(at, 1);
-       }
+       if (at !== -1) {}

[Survived] ConditionalExpression
q.js:1100:13
-           if (typeof process === "object" && typeof process.emit === "function") {
+           if (true) {

[Survived] ConditionalExpression
q.js:1100:13
-           if (typeof process === "object" && typeof process.emit === "function") {
+           if (false) {

[Survived] LogicalOperator
q.js:1100:13
-           if (typeof process === "object" && typeof process.emit === "function") {
+           if (typeof process === "object" || typeof process.emit === "function") {

[Survived] ConditionalExpression
q.js:1100:13
-           if (typeof process === "object" && typeof process.emit === "function") {
+           if (true && typeof process.emit === "function") {

[Survived] EqualityOperator
q.js:1100:13
-           if (typeof process === "object" && typeof process.emit === "function") {
+           if (typeof process !== "object" && typeof process.emit === "function") {

[Survived] StringLiteral
q.js:1100:32
-           if (typeof process === "object" && typeof process.emit === "function") {
+           if (typeof process === "" && typeof process.emit === "function") {

[Survived] ConditionalExpression
q.js:1100:44
-           if (typeof process === "object" && typeof process.emit === "function") {
+           if (typeof process === "object" && true) {

[Survived] EqualityOperator
q.js:1100:44
-           if (typeof process === "object" && typeof process.emit === "function") {
+           if (typeof process === "object" && typeof process.emit !== "function") {

[Survived] StringLiteral
q.js:1100:68
-           if (typeof process === "object" && typeof process.emit === "function") {
+           if (typeof process === "object" && typeof process.emit === "") {

[Survived] BlockStatement
q.js:1100:80
-           if (typeof process === "object" && typeof process.emit === "function") {
-               Q.nextTick.runAfter(function () {
-                   var atReport = array_indexOf(reportedUnhandledRejections, promise);
-                   if (atReport !== -1) {
-                       process.emit("rejectionHandled", unhandledReasons[at], promise);
-                       reportedUnhandledRejections.splice(atReport, 1);
-                   }
-               });
-           }
+           if (typeof process === "object" && typeof process.emit === "function") {}

[Survived] BlockStatement
q.js:1101:45
-               Q.nextTick.runAfter(function () {
-                   var atReport = array_indexOf(reportedUnhandledRejections, promise);
-                   if (atReport !== -1) {
-                       process.emit("rejectionHandled", unhandledReasons[at], promise);
-                       reportedUnhandledRejections.splice(atReport, 1);
-                   }
-               });
+               Q.nextTick.runAfter(function () {});

[Survived] ConditionalExpression
q.js:1103:21
-                   if (atReport !== -1) {
+                   if (true) {

[Survived] ConditionalExpression
q.js:1103:21
-                   if (atReport !== -1) {
+                   if (false) {

[Survived] EqualityOperator
q.js:1103:21
-                   if (atReport !== -1) {
+                   if (atReport === -1) {

[Survived] UnaryOperator
q.js:1103:34
-                   if (atReport !== -1) {
+                   if (atReport !== +1) {

[Survived] BlockStatement
q.js:1103:38
-                   if (atReport !== -1) {
-                       process.emit("rejectionHandled", unhandledReasons[at], promise);
-                       reportedUnhandledRejections.splice(atReport, 1);
-                   }
+                   if (atReport !== -1) {}

[Survived] StringLiteral
q.js:1104:34
-                       process.emit("rejectionHandled", unhandledReasons[at], promise);
+                       process.emit("", unhandledReasons[at], promise);

[Survived] BlockStatement
q.js:1116:37
-   Q.getUnhandledReasons = function () {
-       // Make a copy so that consumers can't interfere with our internal state.
-       return unhandledReasons.slice();
-   };
+   Q.getUnhandledReasons = function () {};

[Survived] MethodExpression
q.js:1118:12
-       return unhandledReasons.slice();
+       return unhandledReasons;

[Survived] BlockStatement
q.js:1121:48
-   Q.stopUnhandledRejectionTracking = function () {
-       resetUnhandledRejections();
-       trackUnhandledRejections = false;
-   };
+   Q.stopUnhandledRejectionTracking = function () {};

[Survived] BooleanLiteral
q.js:1123:32
-       trackUnhandledRejections = false;
+       trackUnhandledRejections = true;

[Survived] ConditionalExpression
q.js:1139:17
-               if (rejected) {
+               if (true) {

[Survived] ConditionalExpression
q.js:1139:17
-               if (rejected) {
+               if (false) {

[Survived] BlockStatement
q.js:1139:27
-               if (rejected) {
-                   untrackRejection(this);
-               }
+               if (rejected) {}

[Survived] BlockStatement
q.js:1144:28
-       }, function fallback() {
-           return this;
-       }, function inspect() {
+       }, function fallback() {}, function inspect() {

[Survived] ObjectLiteral
q.js:1147:16
-           return { state: "rejected", reason: reason };
+           return {};

[Survived] StringLiteral
q.js:1147:25
-           return { state: "rejected", reason: reason };
+           return { state: "", reason: reason };

[Survived] BlockStatement
q.js:1166:32
-           "get": function (name) {
-               return value[name];
-           },
+           "get": function (name) {},

[Survived] BlockStatement
q.js:1169:37
-           "set": function (name, rhs) {
-               value[name] = rhs;
-           },
+           "set": function (name, rhs) {},

[Survived] BlockStatement
q.js:1172:35
-           "delete": function (name) {
-               delete value[name];
-           },
+           "delete": function (name) {},

[Survived] BlockStatement
q.js:1175:39
-           "post": function (name, args) {
-               // Mark Miller proposes that post with no name should apply a
-               // promised function.
-               if (name === null || name === void 0) {
-                   return value.apply(void 0, args);
-               } else {
-                   return value[name].apply(value, args);
-               }
-           },
+           "post": function (name, args) {},

[Survived] ConditionalExpression
q.js:1178:17
-               if (name === null || name === void 0) {
+               if (true) {

[Survived] ConditionalExpression
q.js:1178:17
-               if (name === null || name === void 0) {
+               if (false) {

[Survived] LogicalOperator
q.js:1178:17
-               if (name === null || name === void 0) {
+               if (name === null && name === void 0) {

[Survived] ConditionalExpression
q.js:1178:17
-               if (name === null || name === void 0) {
+               if (false || name === void 0) {

[Survived] EqualityOperator
q.js:1178:17
-               if (name === null || name === void 0) {
+               if (name !== null || name === void 0) {

[Survived] ConditionalExpression
q.js:1178:34
-               if (name === null || name === void 0) {
+               if (name === null || false) {

[Survived] EqualityOperator
q.js:1178:34
-               if (name === null || name === void 0) {
+               if (name === null || name !== void 0) {

[Survived] BlockStatement
q.js:1178:51
-               if (name === null || name === void 0) {
-                   return value.apply(void 0, args);
-               } else {
+               if (name === null || name === void 0) {} else {

[Survived] BlockStatement
q.js:1180:20
-               } else {
-                   return value[name].apply(value, args);
-               }
+               } else {}

[Survived] BlockStatement
q.js:1184:41
-           "apply": function (thisp, args) {
-               return value.apply(thisp, args);
-           },
+           "apply": function (thisp, args) {},

[Survived] BlockStatement
q.js:1187:29
-           "keys": function () {
-               return object_keys(value);
-           }
+           "keys": function () {}

[Survived] ObjectLiteral
q.js:1191:16
-           return { state: "fulfilled", value: value };
+           return {};

[Survived] StringLiteral
q.js:1191:25
-           return { state: "fulfilled", value: value };
+           return { state: "", value: value };

[Survived] BlockStatement
q.js:1205:29
-           } catch (exception) {
-               deferred.reject(exception);
-           }
+           } catch (exception) {}

[Survived] BlockStatement
q.js:1222:25
-   function master(object) {
-       return Promise({
-           "isDef": function () {}
-       }, function fallback(op, args) {
-           return dispatch(object, op, args);
-       }, function () {
-           return Q(object).inspect();
-       });
-   }
+   function master(object) {}

[Survived] ObjectLiteral
q.js:1223:20
-       return Promise({
-           "isDef": function () {}
-       }, function fallback(op, args) {
+       return Promise({}, function fallback(op, args) {

[Survived] BlockStatement
q.js:1225:36
-       }, function fallback(op, args) {
-           return dispatch(object, op, args);
-       }, function () {
+       }, function fallback(op, args) {}, function () {

[Survived] BlockStatement
q.js:1227:20
-       }, function () {
-           return Q(object).inspect();
-       });
+       }, function () {});

[Survived] BlockStatement
q.js:1243:45
-   function spread(value, fulfilled, rejected) {
-       return Q(value).spread(fulfilled, rejected);
-   }
+   function spread(value, fulfilled, rejected) {}

[Survived] BlockStatement
q.js:1247:59
-   Promise.prototype.spread = function (fulfilled, rejected) {
-       return this.all().then(function (array) {
-           return fulfilled.apply(void 0, array);
-       }, rejected);
-   };
+   Promise.prototype.spread = function (fulfilled, rejected) {};

[Survived] BlockStatement
q.js:1248:45
-       return this.all().then(function (array) {
-           return fulfilled.apply(void 0, array);
-       }, rejected);
+       return this.all().then(function (array) {}, rejected);

[Survived] BlockStatement
q.js:1280:31
-   function async(makeGenerator) {
-       return function () {
-           // when verb is "send", arg is a value
-           // when verb is "throw", arg is an exception
-           function continuer(verb, arg) {
-               var result;
-               // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
-               // engine that has a deployed base of browsers that support generators.
-               // However, SM's generators use the Python-inspired semantics of
-               // outdated ES6 drafts.  We would like to support ES6, but we'd also
-               // like to make it possible to use generators in deployed browsers, so
-               // we also support Python-style generators.  At some point we can remove
-               // this block.
-               if (typeof StopIteration === "undefined") {
-                   // ES6 Generators
-                   try {
-                       result = generator[verb](arg);
-                   } catch (exception) {
-                       return reject(exception);
-                   }
-                   if (result.done) {
-                       return Q(result.value);
-                   } else {
-                       return when(result.value, callback, errback);
-                   }
-               } else {
-                   // SpiderMonkey Generators
-                   // FIXME: Remove this case when SM does ES6 generators.
-                   try {
-                       result = generator[verb](arg);
-                   } catch (exception) {
-                       if (isStopIteration(exception)) {
-                           return Q(exception.value);
-                       } else {
-                           return reject(exception);
-                       }
-                   }
-                   return when(result, callback, errback);
-               }
-           }
-           var generator = makeGenerator.apply(this, arguments);
-           var callback = continuer.bind(continuer, "next");
-           var errback = continuer.bind(continuer, "throw");
-           return callback();
-       };
-   }
+   function async(makeGenerator) {}

[Survived] BlockStatement
q.js:1281:24
-       return function () {
-           // when verb is "send", arg is a value
-           // when verb is "throw", arg is an exception
-           function continuer(verb, arg) {
-               var result;
-               // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
-               // engine that has a deployed base of browsers that support generators.
-               // However, SM's generators use the Python-inspired semantics of
-               // outdated ES6 drafts.  We would like to support ES6, but we'd also
-               // like to make it possible to use generators in deployed browsers, so
-               // we also support Python-style generators.  At some point we can remove
-               // this block.
-               if (typeof StopIteration === "undefined") {
-                   // ES6 Generators
-                   try {
-                       result = generator[verb](arg);
-                   } catch (exception) {
-                       return reject(exception);
-                   }
-                   if (result.done) {
-                       return Q(result.value);
-                   } else {
-                       return when(result.value, callback, errback);
-                   }
-               } else {
-                   // SpiderMonkey Generators
-                   // FIXME: Remove this case when SM does ES6 generators.
-                   try {
-                       result = generator[verb](arg);
-                   } catch (exception) {
-                       if (isStopIteration(exception)) {
-                           return Q(exception.value);
-                       } else {
-                           return reject(exception);
-                       }
-                   }
-                   return when(result, callback, errback);
-               }
-           }
-           var generator = makeGenerator.apply(this, arguments);
-           var callback = continuer.bind(continuer, "next");
-           var errback = continuer.bind(continuer, "throw");
-           return callback();
-       };
+       return function () {};

[Survived] BlockStatement
q.js:1284:39
-           function continuer(verb, arg) {
-               var result;
-               // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
-               // engine that has a deployed base of browsers that support generators.
-               // However, SM's generators use the Python-inspired semantics of
-               // outdated ES6 drafts.  We would like to support ES6, but we'd also
-               // like to make it possible to use generators in deployed browsers, so
-               // we also support Python-style generators.  At some point we can remove
-               // this block.
-               if (typeof StopIteration === "undefined") {
-                   // ES6 Generators
-                   try {
-                       result = generator[verb](arg);
-                   } catch (exception) {
-                       return reject(exception);
-                   }
-                   if (result.done) {
-                       return Q(result.value);
-                   } else {
-                       return when(result.value, callback, errback);
-                   }
-               } else {
-                   // SpiderMonkey Generators
-                   // FIXME: Remove this case when SM does ES6 generators.
-                   try {
-                       result = generator[verb](arg);
-                   } catch (exception) {
-                       if (isStopIteration(exception)) {
-                           return Q(exception.value);
-                       } else {
-                           return reject(exception);
-                       }
-                   }
-                   return when(result, callback, errback);
-               }
-           }
+           function continuer(verb, arg) {}

[Survived] ConditionalExpression
q.js:1295:17
-               if (typeof StopIteration === "undefined") {
+               if (true) {

[Survived] ConditionalExpression
q.js:1295:17
-               if (typeof StopIteration === "undefined") {
+               if (false) {

[Survived] EqualityOperator
q.js:1295:17
-               if (typeof StopIteration === "undefined") {
+               if (typeof StopIteration !== "undefined") {

[Survived] StringLiteral
q.js:1295:42
-               if (typeof StopIteration === "undefined") {
+               if (typeof StopIteration === "") {

[Survived] BlockStatement
q.js:1295:55
-               if (typeof StopIteration === "undefined") {
-                   // ES6 Generators
-                   try {
-                       result = generator[verb](arg);
-                   } catch (exception) {
-                       return reject(exception);
-                   }
-                   if (result.done) {
-                       return Q(result.value);
-                   } else {
-                       return when(result.value, callback, errback);
-                   }
-               } else {
+               if (typeof StopIteration === "undefined") {} else {

[Survived] BlockStatement
q.js:1297:21
-                   try {
-                       result = generator[verb](arg);
-                   } catch (exception) {
+                   try {} catch (exception) {

[Survived] BlockStatement
q.js:1299:37
-                   } catch (exception) {
-                       return reject(exception);
-                   }
+                   } catch (exception) {}

[Survived] ConditionalExpression
q.js:1302:21
-                   if (result.done) {
+                   if (true) {

[Survived] ConditionalExpression
q.js:1302:21
-                   if (result.done) {
+                   if (false) {

[Survived] BlockStatement
q.js:1302:34
-                   if (result.done) {
-                       return Q(result.value);
-                   } else {
+                   if (result.done) {} else {

[Survived] BlockStatement
q.js:1304:24
-                   } else {
-                       return when(result.value, callback, errback);
-                   }
+                   } else {}

[Survived] BlockStatement
q.js:1307:20
-               } else {
-                   // SpiderMonkey Generators
-                   // FIXME: Remove this case when SM does ES6 generators.
-                   try {
-                       result = generator[verb](arg);
-                   } catch (exception) {
-                       if (isStopIteration(exception)) {
-                           return Q(exception.value);
-                       } else {
-                           return reject(exception);
-                       }
-                   }
-                   return when(result, callback, errback);
-               }
+               } else {}

[Survived] BlockStatement
q.js:1310:21
-                   try {
-                       result = generator[verb](arg);
-                   } catch (exception) {
+                   try {} catch (exception) {

[Survived] BlockStatement
q.js:1312:37
-                   } catch (exception) {
-                       if (isStopIteration(exception)) {
-                           return Q(exception.value);
-                       } else {
-                           return reject(exception);
-                       }
-                   }
+                   } catch (exception) {}

[Survived] ConditionalExpression
q.js:1313:25
-                       if (isStopIteration(exception)) {
+                       if (true) {

[Survived] ConditionalExpression
q.js:1313:25
-                       if (isStopIteration(exception)) {
+                       if (false) {

[Survived] BlockStatement
q.js:1313:53
-                       if (isStopIteration(exception)) {
-                           return Q(exception.value);
-                       } else {
+                       if (isStopIteration(exception)) {} else {

[Survived] BlockStatement
q.js:1315:28
-                       } else {
-                           return reject(exception);
-                       }
+                       } else {}

[Survived] StringLiteral
q.js:1323:50
-           var callback = continuer.bind(continuer, "next");
+           var callback = continuer.bind(continuer, "");

[Survived] StringLiteral
q.js:1324:49
-           var errback = continuer.bind(continuer, "throw");
+           var errback = continuer.bind(continuer, "");

[Survived] BlockStatement
q.js:1337:31
-   function spawn(makeGenerator) {
-       Q.done(Q.async(makeGenerator)());
-   }
+   function spawn(makeGenerator) {}

[Survived] StringLiteral
q.js:1366:3
-   Q["return"] = _return;
+   Q[""] = _return;

[Survived] BlockStatement
q.js:1367:25
-   function _return(value) {
-       throw new QReturnValue(value);
-   }
+   function _return(value) {}

[Survived] BlockStatement
q.js:1387:29
-   function promised(callback) {
-       return function () {
-           return spread([this, all(arguments)], function (self, args) {
-               return callback.apply(self, args);
-           });
-       };
-   }
+   function promised(callback) {}

[Survived] BlockStatement
q.js:1388:24
-       return function () {
-           return spread([this, all(arguments)], function (self, args) {
-               return callback.apply(self, args);
-           });
-       };
+       return function () {};

[Survived] ArrayDeclaration
q.js:1389:23
-           return spread([this, all(arguments)], function (self, args) {
+           return spread([], function (self, args) {

[Survived] BlockStatement
q.js:1389:69
-           return spread([this, all(arguments)], function (self, args) {
-               return callback.apply(self, args);
-           });
+           return spread([this, all(arguments)], function (self, args) {});

[Survived] BlockStatement
q.js:1403:37
-   function dispatch(object, op, args) {
-       return Q(object).dispatch(op, args);
-   }
+   function dispatch(object, op, args) {}

[Survived] BlockStatement
q.js:1407:50
-   Promise.prototype.dispatch = function (op, args) {
-       var self = this;
-       var deferred = defer();
-       Q.nextTick(function () {
-           self.promiseDispatch(deferred.resolve, op, args);
-       });
-       return deferred.promise;
-   };
+   Promise.prototype.dispatch = function (op, args) {};

[Survived] BlockStatement
q.js:1410:28
-       Q.nextTick(function () {
-           self.promiseDispatch(deferred.resolve, op, args);
-       });
+       Q.nextTick(function () {});

[Survived] BlockStatement
q.js:1422:32
-   Q.get = function (object, key) {
-       return Q(object).dispatch("get", [key]);
-   };
+   Q.get = function (object, key) {};

[Survived] StringLiteral
q.js:1423:31
-       return Q(object).dispatch("get", [key]);
+       return Q(object).dispatch("", [key]);

[Survived] ArrayDeclaration
q.js:1423:38
-       return Q(object).dispatch("get", [key]);
+       return Q(object).dispatch("get", []);

[Survived] BlockStatement
q.js:1426:40
-   Promise.prototype.get = function (key) {
-       return this.dispatch("get", [key]);
-   };
+   Promise.prototype.get = function (key) {};

[Survived] StringLiteral
q.js:1427:26
-       return this.dispatch("get", [key]);
+       return this.dispatch("", [key]);

[Survived] ArrayDeclaration
q.js:1427:33
-       return this.dispatch("get", [key]);
+       return this.dispatch("get", []);

[Survived] BlockStatement
q.js:1437:39
-   Q.set = function (object, key, value) {
-       return Q(object).dispatch("set", [key, value]);
-   };
+   Q.set = function (object, key, value) {};

[Survived] StringLiteral
q.js:1438:31
-       return Q(object).dispatch("set", [key, value]);
+       return Q(object).dispatch("", [key, value]);

[Survived] ArrayDeclaration
q.js:1438:38
-       return Q(object).dispatch("set", [key, value]);
+       return Q(object).dispatch("set", []);

[Survived] BlockStatement
q.js:1441:47
-   Promise.prototype.set = function (key, value) {
-       return this.dispatch("set", [key, value]);
-   };
+   Promise.prototype.set = function (key, value) {};

[Survived] StringLiteral
q.js:1442:26
-       return this.dispatch("set", [key, value]);
+       return this.dispatch("", [key, value]);

[Survived] ArrayDeclaration
q.js:1442:33
-       return this.dispatch("set", [key, value]);
+       return this.dispatch("set", []);

[Survived] StringLiteral
q.js:1452:3
-   Q["delete"] = function (object, key) {
+   Q[""] = function (object, key) {

[Survived] BlockStatement
q.js:1452:38
-   Q["delete"] = function (object, key) {
-       return Q(object).dispatch("delete", [key]);
-   };
+   Q["delete"] = function (object, key) {};

[Survived] StringLiteral
q.js:1453:31
-       return Q(object).dispatch("delete", [key]);
+       return Q(object).dispatch("", [key]);

[Survived] ArrayDeclaration
q.js:1453:41
-       return Q(object).dispatch("delete", [key]);
+       return Q(object).dispatch("delete", []);

[Survived] StringLiteral
q.js:1457:19
-   Promise.prototype["delete"] = function (key) {
+   Promise.prototype[""] = function (key) {

[Survived] BlockStatement
q.js:1457:46
-   Promise.prototype["delete"] = function (key) {
-       return this.dispatch("delete", [key]);
-   };
+   Promise.prototype["delete"] = function (key) {};

[Survived] StringLiteral
q.js:1458:26
-       return this.dispatch("delete", [key]);
+       return this.dispatch("", [key]);

[Survived] ArrayDeclaration
q.js:1458:36
-       return this.dispatch("delete", [key]);
+       return this.dispatch("delete", []);

[Survived] BlockStatement
q.js:1475:40
-   Q.post = function (object, name, args) {
-       return Q(object).dispatch("post", [name, args]);
-   };
+   Q.post = function (object, name, args) {};

[Survived] StringLiteral
q.js:1476:31
-       return Q(object).dispatch("post", [name, args]);
+       return Q(object).dispatch("", [name, args]);

[Survived] ArrayDeclaration
q.js:1476:39
-       return Q(object).dispatch("post", [name, args]);
+       return Q(object).dispatch("post", []);

[Survived] BlockStatement
q.js:1480:48
-   Promise.prototype.post = function (name, args) {
-       return this.dispatch("post", [name, args]);
-   };
+   Promise.prototype.post = function (name, args) {};

[Survived] StringLiteral
q.js:1481:26
-       return this.dispatch("post", [name, args]);
+       return this.dispatch("", [name, args]);

[Survived] ArrayDeclaration
q.js:1481:34
-       return this.dispatch("post", [name, args]);
+       return this.dispatch("post", []);

[Survived] BlockStatement
q.js:1493:48
-   Q.invoke = function (object, name /*...args*/) {
-       return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
-   };
+   Q.invoke = function (object, name /*...args*/) {};

[Survived] StringLiteral
q.js:1494:31
-       return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
+       return Q(object).dispatch("", [name, array_slice(arguments, 2)]);

[Survived] ArrayDeclaration
q.js:1494:39
-       return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
+       return Q(object).dispatch("post", []);

[Survived] BlockStatement
q.js:1499:56
-   Promise.prototype.invoke = function (name /*...args*/) {
-       return this.dispatch("post", [name, array_slice(arguments, 1)]);
-   };
+   Promise.prototype.invoke = function (name /*...args*/) {};

[Survived] StringLiteral
q.js:1500:26
-       return this.dispatch("post", [name, array_slice(arguments, 1)]);
+       return this.dispatch("", [name, array_slice(arguments, 1)]);

[Survived] ArrayDeclaration
q.js:1500:34
-       return this.dispatch("post", [name, array_slice(arguments, 1)]);
+       return this.dispatch("post", []);

[Survived] BlockStatement
q.js:1508:36
-   Q.fapply = function (object, args) {
-       return Q(object).dispatch("apply", [void 0, args]);
-   };
+   Q.fapply = function (object, args) {};

[Survived] StringLiteral
q.js:1509:31
-       return Q(object).dispatch("apply", [void 0, args]);
+       return Q(object).dispatch("", [void 0, args]);

[Survived] ArrayDeclaration
q.js:1509:40
-       return Q(object).dispatch("apply", [void 0, args]);
+       return Q(object).dispatch("apply", []);

[Survived] BlockStatement
q.js:1512:44
-   Promise.prototype.fapply = function (args) {
-       return this.dispatch("apply", [void 0, args]);
-   };
+   Promise.prototype.fapply = function (args) {};

[Survived] StringLiteral
q.js:1513:26
-       return this.dispatch("apply", [void 0, args]);
+       return this.dispatch("", [void 0, args]);

[Survived] ArrayDeclaration
q.js:1513:35
-       return this.dispatch("apply", [void 0, args]);
+       return this.dispatch("apply", []);

[Survived] StringLiteral
q.js:1521:3
-   Q["try"] =
+   Q[""] =

[Survived] BlockStatement
q.js:1522:42
-   Q.fcall = function (object /* ...args*/) {
-       return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
-   };
+   Q.fcall = function (object /* ...args*/) {};

[Survived] StringLiteral
q.js:1523:31
-       return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
+       return Q(object).dispatch("", [void 0, array_slice(arguments, 1)]);

[Survived] ArrayDeclaration
q.js:1523:40
-       return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
+       return Q(object).dispatch("apply", []);

[Survived] BlockStatement
q.js:1526:50
-   Promise.prototype.fcall = function (/*...args*/) {
-       return this.dispatch("apply", [void 0, array_slice(arguments)]);
-   };
+   Promise.prototype.fcall = function (/*...args*/) {};

[Survived] StringLiteral
q.js:1527:26
-       return this.dispatch("apply", [void 0, array_slice(arguments)]);
+       return this.dispatch("", [void 0, array_slice(arguments)]);

[Survived] ArrayDeclaration
q.js:1527:35
-       return this.dispatch("apply", [void 0, array_slice(arguments)]);
+       return this.dispatch("apply", []);

[Survived] BlockStatement
q.js:1536:41
-   Q.fbind = function (object /*...args*/) {
-       var promise = Q(object);
-       var args = array_slice(arguments, 1);
-       return function fbound() {
-           return promise.dispatch("apply", [
-               this,
-               args.concat(array_slice(arguments))
-           ]);
-       };
-   };
+   Q.fbind = function (object /*...args*/) {};

[Survived] BlockStatement
q.js:1539:30
-       return function fbound() {
-           return promise.dispatch("apply", [
-               this,
-               args.concat(array_slice(arguments))
-           ]);
-       };
+       return function fbound() {};

[Survived] StringLiteral
q.js:1540:33
-           return promise.dispatch("apply", [
+           return promise.dispatch("", [

[Survived] ArrayDeclaration
q.js:1540:42
-           return promise.dispatch("apply", [
-               this,
-               args.concat(array_slice(arguments))
-           ]);
+           return promise.dispatch("apply", []);

[Survived] BlockStatement
q.js:1546:50
-   Promise.prototype.fbind = function (/*...args*/) {
-       var promise = this;
-       var args = array_slice(arguments);
-       return function fbound() {
-           return promise.dispatch("apply", [
-               this,
-               args.concat(array_slice(arguments))
-           ]);
-       };
-   };
+   Promise.prototype.fbind = function (/*...args*/) {};

[Survived] BlockStatement
q.js:1549:30
-       return function fbound() {
-           return promise.dispatch("apply", [
-               this,
-               args.concat(array_slice(arguments))
-           ]);
-       };
+       return function fbound() {};

[Survived] StringLiteral
q.js:1550:33
-           return promise.dispatch("apply", [
+           return promise.dispatch("", [

[Survived] ArrayDeclaration
q.js:1550:42
-           return promise.dispatch("apply", [
-               this,
-               args.concat(array_slice(arguments))
-           ]);
+           return promise.dispatch("apply", []);

[Survived] BlockStatement
q.js:1563:28
-   Q.keys = function (object) {
-       return Q(object).dispatch("keys", []);
-   };
+   Q.keys = function (object) {};

[Survived] StringLiteral
q.js:1564:31
-       return Q(object).dispatch("keys", []);
+       return Q(object).dispatch("", []);

[Survived] ArrayDeclaration
q.js:1564:39
-       return Q(object).dispatch("keys", []);
+       return Q(object).dispatch("keys", ["Stryker was here"]);

[Survived] BlockStatement
q.js:1567:38
-   Promise.prototype.keys = function () {
-       return this.dispatch("keys", []);
-   };
+   Promise.prototype.keys = function () {};

[Survived] StringLiteral
q.js:1568:26
-       return this.dispatch("keys", []);
+       return this.dispatch("", []);

[Survived] ArrayDeclaration
q.js:1568:34
-       return this.dispatch("keys", []);
+       return this.dispatch("keys", ["Stryker was here"]);

[Survived] BlockStatement
q.js:1581:24
-   function all(promises) {
-       return when(promises, function (promises) {
-           var pendingCount = 0;
-           var deferred = defer();
-           array_reduce(promises, function (undefined, promise, index) {
-               var snapshot;
-               if (
-                   isPromise(promise) &&
-                   (snapshot = promise.inspect()).state === "fulfilled"
-               ) {
-                   promises[index] = snapshot.value;
-               } else {
-                   ++pendingCount;
-                   when(
-                       promise,
-                       function (value) {
-                           promises[index] = value;
-                           if (--pendingCount === 0) {
-                               deferred.resolve(promises);
-                           }
-                       },
-                       deferred.reject,
-                       function (progress) {
-                           deferred.notify({ index: index, value: progress });
-                       }
-                   );
-               }
-           }, void 0);
-           if (pendingCount === 0) {
-               deferred.resolve(promises);
-           }
-           return deferred.promise;
-       });
-   }
+   function all(promises) {}

[Survived] BlockStatement
q.js:1582:47
-       return when(promises, function (promises) {
-           var pendingCount = 0;
-           var deferred = defer();
-           array_reduce(promises, function (undefined, promise, index) {
-               var snapshot;
-               if (
-                   isPromise(promise) &&
-                   (snapshot = promise.inspect()).state === "fulfilled"
-               ) {
-                   promises[index] = snapshot.value;
-               } else {
-                   ++pendingCount;
-                   when(
-                       promise,
-                       function (value) {
-                           promises[index] = value;
-                           if (--pendingCount === 0) {
-                               deferred.resolve(promises);
-                           }
-                       },
-                       deferred.reject,
-                       function (progress) {
-                           deferred.notify({ index: index, value: progress });
-                       }
-                   );
-               }
-           }, void 0);
-           if (pendingCount === 0) {
-               deferred.resolve(promises);
-           }
-           return deferred.promise;
-       });
+       return when(promises, function (promises) {});

[Survived] BlockStatement
q.js:1585:69
-           array_reduce(promises, function (undefined, promise, index) {
-               var snapshot;
-               if (
-                   isPromise(promise) &&
-                   (snapshot = promise.inspect()).state === "fulfilled"
-               ) {
-                   promises[index] = snapshot.value;
-               } else {
-                   ++pendingCount;
-                   when(
-                       promise,
-                       function (value) {
-                           promises[index] = value;
-                           if (--pendingCount === 0) {
-                               deferred.resolve(promises);
-                           }
-                       },
-                       deferred.reject,
-                       function (progress) {
-                           deferred.notify({ index: index, value: progress });
-                       }
-                   );
-               }
-           }, void 0);
+           array_reduce(promises, function (undefined, promise, index) {}, void 0);

[Survived] ConditionalExpression
q.js:1588:17
-                   isPromise(promise) &&
-                   (snapshot = promise.inspect()).state === "fulfilled"
+                   true

[Survived] ConditionalExpression
q.js:1588:17
-                   isPromise(promise) &&
-                   (snapshot = promise.inspect()).state === "fulfilled"
+                   false

[Survived] LogicalOperator
q.js:1588:17
-                   isPromise(promise) &&
-                   (snapshot = promise.inspect()).state === "fulfilled"
+                   isPromise(promise) || (snapshot = promise.inspect()).state === "fulfilled"

[Survived] ConditionalExpression
q.js:1589:17
-                   (snapshot = promise.inspect()).state === "fulfilled"
+                   true

[Survived] EqualityOperator
q.js:1589:17
-                   (snapshot = promise.inspect()).state === "fulfilled"
+                   (snapshot = promise.inspect()).state !== "fulfilled"

[Survived] StringLiteral
q.js:1589:58
-                   (snapshot = promise.inspect()).state === "fulfilled"
+                   (snapshot = promise.inspect()).state === ""

[Survived] BlockStatement
q.js:1590:15
-               ) {
-                   promises[index] = snapshot.value;
-               } else {
+               ) {} else {

[Survived] BlockStatement
q.js:1592:20
-               } else {
-                   ++pendingCount;
-                   when(
-                       promise,
-                       function (value) {
-                           promises[index] = value;
-                           if (--pendingCount === 0) {
-                               deferred.resolve(promises);
-                           }
-                       },
-                       deferred.reject,
-                       function (progress) {
-                           deferred.notify({ index: index, value: progress });
-                       }
-                   );
-               }
+               } else {}

[Survived] UpdateOperator
q.js:1593:17
-                   ++pendingCount;
+                   --pendingCount;

[Survived] BlockStatement
q.js:1596:38
-                       function (value) {
-                           promises[index] = value;
-                           if (--pendingCount === 0) {
-                               deferred.resolve(promises);
-                           }
-                       },
+                       function (value) {},

[Survived] ConditionalExpression
q.js:1598:29
-                           if (--pendingCount === 0) {
+                           if (true) {

[Survived] ConditionalExpression
q.js:1598:29
-                           if (--pendingCount === 0) {
+                           if (false) {

[Survived] EqualityOperator
q.js:1598:29
-                           if (--pendingCount === 0) {
+                           if (--pendingCount !== 0) {

[Survived] UpdateOperator
q.js:1598:29
-                           if (--pendingCount === 0) {
+                           if (++pendingCount === 0) {

[Survived] BlockStatement
q.js:1598:51
-                           if (--pendingCount === 0) {
-                               deferred.resolve(promises);
-                           }
+                           if (--pendingCount === 0) {}

[Survived] BlockStatement
q.js:1603:41
-                       function (progress) {
-                           deferred.notify({ index: index, value: progress });
-                       }
+                       function (progress) {}

[Survived] ObjectLiteral
q.js:1604:41
-                           deferred.notify({ index: index, value: progress });
+                           deferred.notify({});

[Survived] ConditionalExpression
q.js:1609:13
-           if (pendingCount === 0) {
+           if (true) {

[Survived] ConditionalExpression
q.js:1609:13
-           if (pendingCount === 0) {
+           if (false) {

[Survived] EqualityOperator
q.js:1609:13
-           if (pendingCount === 0) {
+           if (pendingCount !== 0) {

[Survived] BlockStatement
q.js:1609:33
-           if (pendingCount === 0) {
-               deferred.resolve(promises);
-           }
+           if (pendingCount === 0) {}

[Survived] BlockStatement
q.js:1616:37
-   Promise.prototype.all = function () {
-       return all(this);
-   };
+   Promise.prototype.all = function () {};

[Survived] BlockStatement
q.js:1629:24
-   function any(promises) {
-       if (promises.length === 0) {
-           return Q.resolve();
-       }
-       var deferred = Q.defer();
-       var pendingCount = 0;
-       array_reduce(promises, function (prev, current, index) {
-           var promise = promises[index];
-           pendingCount++;
-           when(promise, onFulfilled, onRejected, onProgress);
-           function onFulfilled(result) {
-               deferred.resolve(result);
-           }
-           function onRejected(err) {
-               pendingCount--;
-               if (pendingCount === 0) {
-                   var rejection = err || new Error("" + err);
-                   rejection.message = ("Q can't get fulfillment value from any promise, all " +
-                       "promises were rejected. Last error message: " + rejection.message);
-                   deferred.reject(rejection);
-               }
-           }
-           function onProgress(progress) {
-               deferred.notify({
-                   index: index,
-                   value: progress
-               });
-           }
-       }, undefined);
-       return deferred.promise;
-   }
+   function any(promises) {}

[Survived] ConditionalExpression
q.js:1630:9
-       if (promises.length === 0) {
+       if (true) {

[Survived] ConditionalExpression
q.js:1630:9
-       if (promises.length === 0) {
+       if (false) {

[Survived] EqualityOperator
q.js:1630:9
-       if (promises.length === 0) {
+       if (promises.length !== 0) {

[Survived] BlockStatement
q.js:1630:32
-       if (promises.length === 0) {
-           return Q.resolve();
-       }
+       if (promises.length === 0) {}

[Survived] BlockStatement
q.js:1636:60
-       array_reduce(promises, function (prev, current, index) {
-           var promise = promises[index];
-           pendingCount++;
-           when(promise, onFulfilled, onRejected, onProgress);
-           function onFulfilled(result) {
-               deferred.resolve(result);
-           }
-           function onRejected(err) {
-               pendingCount--;
-               if (pendingCount === 0) {
-                   var rejection = err || new Error("" + err);
-                   rejection.message = ("Q can't get fulfillment value from any promise, all " +
-                       "promises were rejected. Last error message: " + rejection.message);
-                   deferred.reject(rejection);
-               }
-           }
-           function onProgress(progress) {
-               deferred.notify({
-                   index: index,
-                   value: progress
-               });
-           }
-       }, undefined);
+       array_reduce(promises, function (prev, current, index) {}, undefined);

[Survived] UpdateOperator
q.js:1639:9
-           pendingCount++;
+           pendingCount--;

[Survived] BlockStatement
q.js:1642:38
-           function onFulfilled(result) {
-               deferred.resolve(result);
-           }
+           function onFulfilled(result) {}

[Survived] BlockStatement
q.js:1645:34
-           function onRejected(err) {
-               pendingCount--;
-               if (pendingCount === 0) {
-                   var rejection = err || new Error("" + err);
-                   rejection.message = ("Q can't get fulfillment value from any promise, all " +
-                       "promises were rejected. Last error message: " + rejection.message);
-                   deferred.reject(rejection);
-               }
-           }
+           function onRejected(err) {}

[Survived] UpdateOperator
q.js:1646:13
-               pendingCount--;
+               pendingCount++;

[Survived] ConditionalExpression
q.js:1647:17
-               if (pendingCount === 0) {
+               if (true) {

[Survived] ConditionalExpression
q.js:1647:17
-               if (pendingCount === 0) {
+               if (false) {

[Survived] EqualityOperator
q.js:1647:17
-               if (pendingCount === 0) {
+               if (pendingCount !== 0) {

[Survived] BlockStatement
q.js:1647:37
-               if (pendingCount === 0) {
-                   var rejection = err || new Error("" + err);
-                   rejection.message = ("Q can't get fulfillment value from any promise, all " +
-                       "promises were rejected. Last error message: " + rejection.message);
-                   deferred.reject(rejection);
-               }
+               if (pendingCount === 0) {}

[Survived] ConditionalExpression
q.js:1648:33
-                   var rejection = err || new Error("" + err);
+                   var rejection = true;

[Survived] ConditionalExpression
q.js:1648:33
-                   var rejection = err || new Error("" + err);
+                   var rejection = false;

[Survived] LogicalOperator
q.js:1648:33
-                   var rejection = err || new Error("" + err);
+                   var rejection = err && new Error("" + err);

[Survived] StringLiteral
q.js:1648:50
-                   var rejection = err || new Error("" + err);
+                   var rejection = err || new Error("Stryker was here!" + err);

[Survived] StringLiteral
q.js:1650:38
-                   rejection.message = ("Q can't get fulfillment value from any promise, all " +
+                   rejection.message = ("" +

[Survived] StringLiteral
q.js:1651:21
-                       "promises were rejected. Last error message: " + rejection.message);
+                       "" + rejection.message);

[Survived] BlockStatement
q.js:1656:39
-           function onProgress(progress) {
-               deferred.notify({
-                   index: index,
-                   value: progress
-               });
-           }
+           function onProgress(progress) {}

[Survived] ObjectLiteral
q.js:1657:29
-               deferred.notify({
-                   index: index,
-                   value: progress
-               });
+               deferred.notify({});

[Survived] BlockStatement
q.js:1667:37
-   Promise.prototype.any = function () {
-       return any(this);
-   };
+   Promise.prototype.any = function () {};

[Survived] StringLiteral
q.js:1680:40
-   Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
+   Q.allResolved = deprecate(allResolved, "", "allSettled");

[Survived] StringLiteral
q.js:1680:55
-   Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
+   Q.allResolved = deprecate(allResolved, "allResolved", "");

[Survived] BlockStatement
q.js:1681:32
-   function allResolved(promises) {
-       return when(promises, function (promises) {
-           promises = array_map(promises, Q);
-           return when(all(array_map(promises, function (promise) {
-               return when(promise, noop, noop);
-           })), function () {
-               return promises;
-           });
-       });
-   }
+   function allResolved(promises) {}

[Survived] BlockStatement
q.js:1682:47
-       return when(promises, function (promises) {
-           promises = array_map(promises, Q);
-           return when(all(array_map(promises, function (promise) {
-               return when(promise, noop, noop);
-           })), function () {
-               return promises;
-           });
-       });
+       return when(promises, function (promises) {});

[Survived] BlockStatement
q.js:1684:64
-           return when(all(array_map(promises, function (promise) {
-               return when(promise, noop, noop);
-           })), function () {
+           return when(all(array_map(promises, function (promise) {})), function () {

[Survived] BlockStatement
q.js:1686:26
-           })), function () {
-               return promises;
-           });
+           })), function () {});

[Survived] BlockStatement
q.js:1692:45
-   Promise.prototype.allResolved = function () {
-       return allResolved(this);
-   };
+   Promise.prototype.allResolved = function () {};

[Survived] BlockStatement
q.js:1700:31
-   function allSettled(promises) {
-       return Q(promises).allSettled();
-   }
+   function allSettled(promises) {}

[Survived] BlockStatement
q.js:1711:44
-   Promise.prototype.allSettled = function () {
-       return this.then(function (promises) {
-           return all(array_map(promises, function (promise) {
-               promise = Q(promise);
-               function regardless() {
-                   return promise.inspect();
-               }
-               return promise.then(regardless, regardless);
-           }));
-       });
-   };
+   Promise.prototype.allSettled = function () {};

[Survived] BlockStatement
q.js:1712:42
-       return this.then(function (promises) {
-           return all(array_map(promises, function (promise) {
-               promise = Q(promise);
-               function regardless() {
-                   return promise.inspect();
-               }
-               return promise.then(regardless, regardless);
-           }));
-       });
+       return this.then(function (promises) {});

[Survived] BlockStatement
q.js:1713:59
-           return all(array_map(promises, function (promise) {
-               promise = Q(promise);
-               function regardless() {
-                   return promise.inspect();
-               }
-               return promise.then(regardless, regardless);
-           }));
+           return all(array_map(promises, function (promise) {}));

[Survived] BlockStatement
q.js:1715:35
-               function regardless() {
-                   return promise.inspect();
-               }
+               function regardless() {}

[Survived] StringLiteral
q.js:1733:3
-   Q["catch"] = function (object, rejected) {
+   Q[""] = function (object, rejected) {

[Survived] BlockStatement
q.js:1733:42
-   Q["catch"] = function (object, rejected) {
-       return Q(object).then(void 0, rejected);
-   };
+   Q["catch"] = function (object, rejected) {};

[Survived] StringLiteral
q.js:1738:19
-   Promise.prototype["catch"] = function (rejected) {
+   Promise.prototype[""] = function (rejected) {

[Survived] BlockStatement
q.js:1738:50
-   Promise.prototype["catch"] = function (rejected) {
-       return this.then(void 0, rejected);
-   };
+   Promise.prototype["catch"] = function (rejected) {};

[Survived] BlockStatement
q.js:1751:39
-   function progress(object, progressed) {
-       return Q(object).then(void 0, void 0, progressed);
-   }
+   function progress(object, progressed) {}

[Survived] BlockStatement
q.js:1755:52
-   Promise.prototype.progress = function (progressed) {
-       return this.then(void 0, void 0, progressed);
-   };
+   Promise.prototype.progress = function (progressed) {};

[Survived] StringLiteral
q.js:1771:3
-   Q["finally"] = function (object, callback) {
+   Q[""] = function (object, callback) {

[Survived] BlockStatement
q.js:1771:44
-   Q["finally"] = function (object, callback) {
-       return Q(object)["finally"](callback);
-   };
+   Q["finally"] = function (object, callback) {};

[Survived] StringLiteral
q.js:1772:22
-       return Q(object)["finally"](callback);
+       return Q(object)[""](callback);

[Survived] StringLiteral
q.js:1776:19
-   Promise.prototype["finally"] = function (callback) {
+   Promise.prototype[""] = function (callback) {

[Survived] BlockStatement
q.js:1776:52
-   Promise.prototype["finally"] = function (callback) {
-       if (!callback || typeof callback.apply !== "function") {
-           throw new Error("Q can't apply finally callback");
-       }
-       callback = Q(callback);
-       return this.then(function (value) {
-           return callback.fcall().then(function () {
-               return value;
-           });
-       }, function (reason) {
-           // TODO attempt to recycle the rejection with "this".
-           return callback.fcall().then(function () {
-               throw reason;
-           });
-       });
-   };
+   Promise.prototype["finally"] = function (callback) {};

[Survived] ConditionalExpression
q.js:1777:9
-       if (!callback || typeof callback.apply !== "function") {
+       if (true) {

[Survived] ConditionalExpression
q.js:1777:9
-       if (!callback || typeof callback.apply !== "function") {
+       if (false) {

[Survived] LogicalOperator
q.js:1777:9
-       if (!callback || typeof callback.apply !== "function") {
+       if (!callback && typeof callback.apply !== "function") {

[Survived] BooleanLiteral
q.js:1777:9
-       if (!callback || typeof callback.apply !== "function") {
+       if (callback || typeof callback.apply !== "function") {

[Survived] ConditionalExpression
q.js:1777:22
-       if (!callback || typeof callback.apply !== "function") {
+       if (!callback || false) {

[Survived] EqualityOperator
q.js:1777:22
-       if (!callback || typeof callback.apply !== "function") {
+       if (!callback || typeof callback.apply === "function") {

[Survived] StringLiteral
q.js:1777:48
-       if (!callback || typeof callback.apply !== "function") {
+       if (!callback || typeof callback.apply !== "") {

[Survived] BlockStatement
q.js:1777:60
-       if (!callback || typeof callback.apply !== "function") {
-           throw new Error("Q can't apply finally callback");
-       }
+       if (!callback || typeof callback.apply !== "function") {}

[Survived] StringLiteral
q.js:1778:25
-           throw new Error("Q can't apply finally callback");
+           throw new Error("");

[Survived] BlockStatement
q.js:1781:39
-       return this.then(function (value) {
-           return callback.fcall().then(function () {
-               return value;
-           });
-       }, function (reason) {
+       return this.then(function (value) {}, function (reason) {

[Survived] BlockStatement
q.js:1782:50
-           return callback.fcall().then(function () {
-               return value;
-           });
+           return callback.fcall().then(function () {});

[Survived] BlockStatement
q.js:1785:26
-       }, function (reason) {
-           // TODO attempt to recycle the rejection with "this".
-           return callback.fcall().then(function () {
-               throw reason;
-           });
-       });
+       }, function (reason) {});

[Survived] BlockStatement
q.js:1787:50
-           return callback.fcall().then(function () {
-               throw reason;
-           });
+           return callback.fcall().then(function () {});

[Survived] BlockStatement
q.js:1799:59
-   Q.done = function (object, fulfilled, rejected, progress) {
-       return Q(object).done(fulfilled, rejected, progress);
-   };
+   Q.done = function (object, fulfilled, rejected, progress) {};

[Survived] BlockStatement
q.js:1803:67
-   Promise.prototype.done = function (fulfilled, rejected, progress) {
-       var onUnhandledError = function (error) {
-           // forward to a future turn so that ``when``
-           // does not catch it and turn it into a rejection.
-           Q.nextTick(function () {
-               makeStackTraceLong(error, promise);
-               if (Q.onerror) {
-                   Q.onerror(error);
-               } else {
-                   throw error;
-               }
-           });
-       };
-       // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
-       var promise = fulfilled || rejected || progress ?
-           this.then(fulfilled, rejected, progress) :
-           this;
-       if (typeof process === "object" && process && process.domain) {
-           onUnhandledError = process.domain.bind(onUnhandledError);
-       }
-       promise.then(void 0, onUnhandledError);
-   };
+   Promise.prototype.done = function (fulfilled, rejected, progress) {};

[Survived] BlockStatement
q.js:1804:45
-       var onUnhandledError = function (error) {
-           // forward to a future turn so that ``when``
-           // does not catch it and turn it into a rejection.
-           Q.nextTick(function () {
-               makeStackTraceLong(error, promise);
-               if (Q.onerror) {
-                   Q.onerror(error);
-               } else {
-                   throw error;
-               }
-           });
-       };
+       var onUnhandledError = function (error) {};

[Survived] BlockStatement
q.js:1807:32
-           Q.nextTick(function () {
-               makeStackTraceLong(error, promise);
-               if (Q.onerror) {
-                   Q.onerror(error);
-               } else {
-                   throw error;
-               }
-           });
+           Q.nextTick(function () {});

[Survived] ConditionalExpression
q.js:1809:17
-               if (Q.onerror) {
+               if (true) {

[Survived] ConditionalExpression
q.js:1809:17
-               if (Q.onerror) {
+               if (false) {

[Survived] BlockStatement
q.js:1809:28
-               if (Q.onerror) {
-                   Q.onerror(error);
-               } else {
+               if (Q.onerror) {} else {

[Survived] BlockStatement
q.js:1811:20
-               } else {
-                   throw error;
-               }
+               } else {}

[Survived] ConditionalExpression
q.js:1818:19
-       var promise = fulfilled || rejected || progress ?
+       var promise = true ?

[Survived] ConditionalExpression
q.js:1818:19
-       var promise = fulfilled || rejected || progress ?
+       var promise = false ?

[Survived] LogicalOperator
q.js:1818:19
-       var promise = fulfilled || rejected || progress ?
+       var promise = (fulfilled || rejected) && progress ?

[Survived] ConditionalExpression
q.js:1818:19
-       var promise = fulfilled || rejected || progress ?
+       var promise = false || progress ?

[Survived] LogicalOperator
q.js:1818:19
-       var promise = fulfilled || rejected || progress ?
+       var promise = fulfilled && rejected || progress ?

[Survived] ConditionalExpression
q.js:1822:9
-       if (typeof process === "object" && process && process.domain) {
+       if (true) {

[Survived] ConditionalExpression
q.js:1822:9
-       if (typeof process === "object" && process && process.domain) {
+       if (false) {

[Survived] LogicalOperator
q.js:1822:9
-       if (typeof process === "object" && process && process.domain) {
+       if (typeof process === "object" && process || process.domain) {

[Survived] ConditionalExpression
q.js:1822:9
-       if (typeof process === "object" && process && process.domain) {
+       if (true && process.domain) {

[Survived] LogicalOperator
q.js:1822:9
-       if (typeof process === "object" && process && process.domain) {
+       if (typeof process === "object" || process && process.domain) {

[Survived] ConditionalExpression
q.js:1822:9
-       if (typeof process === "object" && process && process.domain) {
+       if (true && process && process.domain) {

[Survived] EqualityOperator
q.js:1822:9
-       if (typeof process === "object" && process && process.domain) {
+       if (typeof process !== "object" && process && process.domain) {

[Survived] StringLiteral
q.js:1822:28
-       if (typeof process === "object" && process && process.domain) {
+       if (typeof process === "" && process && process.domain) {

[Survived] BlockStatement
q.js:1822:67
-       if (typeof process === "object" && process && process.domain) {
-           onUnhandledError = process.domain.bind(onUnhandledError);
-       }
+       if (typeof process === "object" && process && process.domain) {}

[Survived] BlockStatement
q.js:1838:42
-   Q.timeout = function (object, ms, error) {
-       return Q(object).timeout(ms, error);
-   };
+   Q.timeout = function (object, ms, error) {};

[Survived] BlockStatement
q.js:1842:50
-   Promise.prototype.timeout = function (ms, error) {
-       var deferred = defer();
-       var timeoutId = setTimeout(function () {
-           if (!error || "string" === typeof error) {
-               error = new Error(error || "Timed out after " + ms + " ms");
-               error.code = "ETIMEDOUT";
-           }
-           deferred.reject(error);
-       }, ms);
-       this.then(function (value) {
-           clearTimeout(timeoutId);
-           deferred.resolve(value);
-       }, function (exception) {
-           clearTimeout(timeoutId);
-           deferred.reject(exception);
-       }, deferred.notify);
-       return deferred.promise;
-   };
+   Promise.prototype.timeout = function (ms, error) {};

[Survived] BlockStatement
q.js:1844:44
-       var timeoutId = setTimeout(function () {
-           if (!error || "string" === typeof error) {
-               error = new Error(error || "Timed out after " + ms + " ms");
-               error.code = "ETIMEDOUT";
-           }
-           deferred.reject(error);
-       }, ms);
+       var timeoutId = setTimeout(function () {}, ms);

[Survived] ConditionalExpression
q.js:1845:13
-           if (!error || "string" === typeof error) {
+           if (true) {

[Survived] ConditionalExpression
q.js:1845:13
-           if (!error || "string" === typeof error) {
+           if (false) {

[Survived] LogicalOperator
q.js:1845:13
-           if (!error || "string" === typeof error) {
+           if (!error && "string" === typeof error) {

[Survived] BooleanLiteral
q.js:1845:13
-           if (!error || "string" === typeof error) {
+           if (error || "string" === typeof error) {

[Survived] ConditionalExpression
q.js:1845:23
-           if (!error || "string" === typeof error) {
+           if (!error || false) {

[Survived] EqualityOperator
q.js:1845:23
-           if (!error || "string" === typeof error) {
+           if (!error || "string" !== typeof error) {

[Survived] StringLiteral
q.js:1845:23
-           if (!error || "string" === typeof error) {
+           if (!error || "" === typeof error) {

[Survived] BlockStatement
q.js:1845:50
-           if (!error || "string" === typeof error) {
-               error = new Error(error || "Timed out after " + ms + " ms");
-               error.code = "ETIMEDOUT";
-           }
+           if (!error || "string" === typeof error) {}

[Survived] ConditionalExpression
q.js:1846:31
-               error = new Error(error || "Timed out after " + ms + " ms");
+               error = new Error(true);

[Survived] ConditionalExpression
q.js:1846:31
-               error = new Error(error || "Timed out after " + ms + " ms");
+               error = new Error(false);

[Survived] LogicalOperator
q.js:1846:31
-               error = new Error(error || "Timed out after " + ms + " ms");
+               error = new Error(error && "Timed out after " + ms + " ms");

[Survived] StringLiteral
q.js:1846:40
-               error = new Error(error || "Timed out after " + ms + " ms");
+               error = new Error(error || "" + ms + " ms");

[Survived] StringLiteral
q.js:1846:66
-               error = new Error(error || "Timed out after " + ms + " ms");
+               error = new Error(error || "Timed out after " + ms + "");

[Survived] StringLiteral
q.js:1847:26
-               error.code = "ETIMEDOUT";
+               error.code = "";

[Survived] BlockStatement
q.js:1852:32
-       this.then(function (value) {
-           clearTimeout(timeoutId);
-           deferred.resolve(value);
-       }, function (exception) {
+       this.then(function (value) {}, function (exception) {

[Survived] BlockStatement
q.js:1855:29
-       }, function (exception) {
-           clearTimeout(timeoutId);
-           deferred.reject(exception);
-       }, deferred.notify);
+       }, function (exception) {}, deferred.notify);

[Survived] BlockStatement
q.js:1872:38
-   Q.delay = function (object, timeout) {
-       if (timeout === void 0) {
-           timeout = object;
-           object = void 0;
-       }
-       return Q(object).delay(timeout);
-   };
+   Q.delay = function (object, timeout) {};

[Survived] ConditionalExpression
q.js:1873:9
-       if (timeout === void 0) {
+       if (true) {

[Survived] ConditionalExpression
q.js:1873:9
-       if (timeout === void 0) {
+       if (false) {

[Survived] EqualityOperator
q.js:1873:9
-       if (timeout === void 0) {
+       if (timeout !== void 0) {

[Survived] BlockStatement
q.js:1873:29
-       if (timeout === void 0) {
-           timeout = object;
-           object = void 0;
-       }
+       if (timeout === void 0) {}

[Survived] BlockStatement
q.js:1880:46
-   Promise.prototype.delay = function (timeout) {
-       return this.then(function (value) {
-           var deferred = defer();
-           setTimeout(function () {
-               deferred.resolve(value);
-           }, timeout);
-           return deferred.promise;
-       });
-   };
+   Promise.prototype.delay = function (timeout) {};

[Survived] BlockStatement
q.js:1881:39
-       return this.then(function (value) {
-           var deferred = defer();
-           setTimeout(function () {
-               deferred.resolve(value);
-           }, timeout);
-           return deferred.promise;
-       });
+       return this.then(function (value) {});

[Survived] BlockStatement
q.js:1883:32
-           setTimeout(function () {
-               deferred.resolve(value);
-           }, timeout);
+           setTimeout(function () {}, timeout);

[Survived] BlockStatement
q.js:1899:39
-   Q.nfapply = function (callback, args) {
-       return Q(callback).nfapply(args);
-   };
+   Q.nfapply = function (callback, args) {};

[Survived] BlockStatement
q.js:1903:45
-   Promise.prototype.nfapply = function (args) {
-       var deferred = defer();
-       var nodeArgs = array_slice(args);
-       nodeArgs.push(deferred.makeNodeResolver());
-       this.fapply(nodeArgs).fail(deferred.reject);
-       return deferred.promise;
-   };
+   Promise.prototype.nfapply = function (args) {};

[Survived] BlockStatement
q.js:1920:44
-   Q.nfcall = function (callback /*...args*/) {
-       var args = array_slice(arguments, 1);
-       return Q(callback).nfapply(args);
-   };
+   Q.nfcall = function (callback /*...args*/) {};

[Survived] BlockStatement
q.js:1925:51
-   Promise.prototype.nfcall = function (/*...args*/) {
-       var nodeArgs = array_slice(arguments);
-       var deferred = defer();
-       nodeArgs.push(deferred.makeNodeResolver());
-       this.fapply(nodeArgs).fail(deferred.reject);
-       return deferred.promise;
-   };
+   Promise.prototype.nfcall = function (/*...args*/) {};

[Survived] BlockStatement
q.js:1942:47
-   Q.denodeify = function (callback /*...args*/) {
-       if (callback === undefined) {
-           throw new Error("Q can't wrap an undefined function");
-       }
-       var baseArgs = array_slice(arguments, 1);
-       return function () {
-           var nodeArgs = baseArgs.concat(array_slice(arguments));
-           var deferred = defer();
-           nodeArgs.push(deferred.makeNodeResolver());
-           Q(callback).fapply(nodeArgs).fail(deferred.reject);
-           return deferred.promise;
-       };
-   };
+   Q.denodeify = function (callback /*...args*/) {};

[Survived] ConditionalExpression
q.js:1943:9
-       if (callback === undefined) {
+       if (true) {

[Survived] ConditionalExpression
q.js:1943:9
-       if (callback === undefined) {
+       if (false) {

[Survived] EqualityOperator
q.js:1943:9
-       if (callback === undefined) {
+       if (callback !== undefined) {

[Survived] BlockStatement
q.js:1943:33
-       if (callback === undefined) {
-           throw new Error("Q can't wrap an undefined function");
-       }
+       if (callback === undefined) {}

[Survived] StringLiteral
q.js:1944:25
-           throw new Error("Q can't wrap an undefined function");
+           throw new Error("");

[Survived] BlockStatement
q.js:1947:24
-       return function () {
-           var nodeArgs = baseArgs.concat(array_slice(arguments));
-           var deferred = defer();
-           nodeArgs.push(deferred.makeNodeResolver());
-           Q(callback).fapply(nodeArgs).fail(deferred.reject);
-           return deferred.promise;
-       };
+       return function () {};

[Survived] BlockStatement
q.js:1957:54
-   Promise.prototype.denodeify = function (/*...args*/) {
-       var args = array_slice(arguments);
-       args.unshift(this);
-       return Q.denodeify.apply(void 0, args);
-   };
+   Promise.prototype.denodeify = function (/*...args*/) {};

[Survived] BlockStatement
q.js:1963:50
-   Q.nbind = function (callback, thisp /*...args*/) {
-       var baseArgs = array_slice(arguments, 2);
-       return function () {
-           var nodeArgs = baseArgs.concat(array_slice(arguments));
-           var deferred = defer();
-           nodeArgs.push(deferred.makeNodeResolver());
-           function bound() {
-               return callback.apply(thisp, arguments);
-           }
-           Q(bound).fapply(nodeArgs).fail(deferred.reject);
-           return deferred.promise;
-       };
-   };
+   Q.nbind = function (callback, thisp /*...args*/) {};

[Survived] BlockStatement
q.js:1965:24
-       return function () {
-           var nodeArgs = baseArgs.concat(array_slice(arguments));
-           var deferred = defer();
-           nodeArgs.push(deferred.makeNodeResolver());
-           function bound() {
-               return callback.apply(thisp, arguments);
-           }
-           Q(bound).fapply(nodeArgs).fail(deferred.reject);
-           return deferred.promise;
-       };
+       return function () {};

[Survived] BlockStatement
q.js:1969:26
-           function bound() {
-               return callback.apply(thisp, arguments);
-           }
+           function bound() {}

[Survived] BlockStatement
q.js:1977:57
-   Promise.prototype.nbind = function (/*thisp, ...args*/) {
-       var args = array_slice(arguments, 0);
-       args.unshift(this);
-       return Q.nbind.apply(void 0, args);
-   };
+   Promise.prototype.nbind = function (/*thisp, ...args*/) {};

[Survived] BlockStatement
q.js:1993:41
-   Q.npost = function (object, name, args) {
-       return Q(object).npost(name, args);
-   };
+   Q.npost = function (object, name, args) {};

[Survived] BlockStatement
q.js:1998:49
-   Promise.prototype.npost = function (name, args) {
-       var nodeArgs = array_slice(args || []);
-       var deferred = defer();
-       nodeArgs.push(deferred.makeNodeResolver());
-       this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
-       return deferred.promise;
-   };
+   Promise.prototype.npost = function (name, args) {};

[Survived] ConditionalExpression
q.js:1999:32
-       var nodeArgs = array_slice(args || []);
+       var nodeArgs = array_slice(true);

[Survived] ConditionalExpression
q.js:1999:32
-       var nodeArgs = array_slice(args || []);
+       var nodeArgs = array_slice(false);

[Survived] LogicalOperator
q.js:1999:32
-       var nodeArgs = array_slice(args || []);
+       var nodeArgs = array_slice(args && []);

[Survived] ArrayDeclaration
q.js:1999:40
-       var nodeArgs = array_slice(args || []);
+       var nodeArgs = array_slice(args || ["Stryker was here"]);

[Survived] StringLiteral
q.js:2002:19
-       this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
+       this.dispatch("", [name, nodeArgs]).fail(deferred.reject);

[Survived] ArrayDeclaration
q.js:2002:27
-       this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
+       this.dispatch("post", []).fail(deferred.reject);

[Survived] BlockStatement
q.js:2018:49
-   Q.ninvoke = function (object, name /*...args*/) {
-       var nodeArgs = array_slice(arguments, 2);
-       var deferred = defer();
-       nodeArgs.push(deferred.makeNodeResolver());
-       Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
-       return deferred.promise;
-   };
+   Q.ninvoke = function (object, name /*...args*/) {};

[Survived] StringLiteral
q.js:2022:24
-       Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
+       Q(object).dispatch("", [name, nodeArgs]).fail(deferred.reject);

[Survived] ArrayDeclaration
q.js:2022:32
-       Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
+       Q(object).dispatch("post", []).fail(deferred.reject);

[Survived] BlockStatement
q.js:2028:57
-   Promise.prototype.ninvoke = function (name /*...args*/) {
-       var nodeArgs = array_slice(arguments, 1);
-       var deferred = defer();
-       nodeArgs.push(deferred.makeNodeResolver());
-       this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
-       return deferred.promise;
-   };
+   Promise.prototype.ninvoke = function (name /*...args*/) {};

[Survived] StringLiteral
q.js:2032:19
-       this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
+       this.dispatch("", [name, nodeArgs]).fail(deferred.reject);

[Survived] ArrayDeclaration
q.js:2032:27
-       this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
+       this.dispatch("post", []).fail(deferred.reject);

[Survived] BlockStatement
q.js:2047:36
-   function nodeify(object, nodeback) {
-       return Q(object).nodeify(nodeback);
-   }
+   function nodeify(object, nodeback) {}

[Survived] BlockStatement
q.js:2051:49
-   Promise.prototype.nodeify = function (nodeback) {
-       if (nodeback) {
-           this.then(function (value) {
-               Q.nextTick(function () {
-                   nodeback(null, value);
-               });
-           }, function (error) {
-               Q.nextTick(function () {
-                   nodeback(error);
-               });
-           });
-       } else {
-           return this;
-       }
-   };
+   Promise.prototype.nodeify = function (nodeback) {};

[Survived] ConditionalExpression
q.js:2052:9
-       if (nodeback) {
+       if (true) {

[Survived] ConditionalExpression
q.js:2052:9
-       if (nodeback) {
+       if (false) {

[Survived] BlockStatement
q.js:2052:19
-       if (nodeback) {
-           this.then(function (value) {
-               Q.nextTick(function () {
-                   nodeback(null, value);
-               });
-           }, function (error) {
-               Q.nextTick(function () {
-                   nodeback(error);
-               });
-           });
-       } else {
+       if (nodeback) {} else {

[Survived] BlockStatement
q.js:2053:36
-           this.then(function (value) {
-               Q.nextTick(function () {
-                   nodeback(null, value);
-               });
-           }, function (error) {
+           this.then(function (value) {}, function (error) {

[Survived] BlockStatement
q.js:2054:36
-               Q.nextTick(function () {
-                   nodeback(null, value);
-               });
+               Q.nextTick(function () {});

[Survived] BlockStatement
q.js:2057:29
-           }, function (error) {
-               Q.nextTick(function () {
-                   nodeback(error);
-               });
-           });
+           }, function (error) {});

[Survived] BlockStatement
q.js:2058:36
-               Q.nextTick(function () {
-                   nodeback(error);
-               });
+               Q.nextTick(function () {});

[Survived] BlockStatement
q.js:2062:12
-       } else {
-           return this;
-       }
+       } else {}

[Survived] BlockStatement
q.js:2067:27
-   Q.noConflict = function() {
-       throw new Error("Q.noConflict only works when Q is used as a global");
-   };
+   Q.noConflict = function() {};

[Survived] StringLiteral
q.js:2068:21
-       throw new Error("Q.noConflict only works when Q is used as a global");
+       throw new Error("");

[Survived] BlockStatement
queue.js:5:18
-   function Queue() {
-       var ends = Q.defer();
-       var closed = Q.defer();
-       return {
-           put: function (value) {
-               var next = Q.defer();
-               ends.resolve({
-                   head: value,
-                   tail: next.promise
-               });
-               ends.resolve = next.resolve;
-           },
-           get: function () {
-               var result = ends.promise.get("head");
-               ends.promise = ends.promise.get("tail");
-               return result.fail(function (error) {
-                   closed.resolve(error);
-                   throw error;
-               });
-           },
-           closed: closed.promise,
-           close: function (error) {
-               error = error || new Error("Can't get value from closed queue");
-               var end = {head: Q.reject(error)};
-               end.tail = end;
-               ends.resolve(end);
-               return closed.promise;
-           }
-       };
-   }
+   function Queue() {}

[Survived] ObjectLiteral
queue.js:8:12
-       return {
-           put: function (value) {
-               var next = Q.defer();
-               ends.resolve({
-                   head: value,
-                   tail: next.promise
-               });
-               ends.resolve = next.resolve;
-           },
-           get: function () {
-               var result = ends.promise.get("head");
-               ends.promise = ends.promise.get("tail");
-               return result.fail(function (error) {
-                   closed.resolve(error);
-                   throw error;
-               });
-           },
-           closed: closed.promise,
-           close: function (error) {
-               error = error || new Error("Can't get value from closed queue");
-               var end = {head: Q.reject(error)};
-               end.tail = end;
-               ends.resolve(end);
-               return closed.promise;
-           }
-       };
+       return {};

[Survived] BlockStatement
queue.js:9:31
-           put: function (value) {
-               var next = Q.defer();
-               ends.resolve({
-                   head: value,
-                   tail: next.promise
-               });
-               ends.resolve = next.resolve;
-           },
+           put: function (value) {},

[Survived] ObjectLiteral
queue.js:11:26
-               ends.resolve({
-                   head: value,
-                   tail: next.promise
-               });
+               ends.resolve({});

[Survived] BlockStatement
queue.js:17:26
-           get: function () {
-               var result = ends.promise.get("head");
-               ends.promise = ends.promise.get("tail");
-               return result.fail(function (error) {
-                   closed.resolve(error);
-                   throw error;
-               });
-           },
+           get: function () {},

[Survived] StringLiteral
queue.js:18:43
-               var result = ends.promise.get("head");
+               var result = ends.promise.get("");

[Survived] StringLiteral
queue.js:19:45
-               ends.promise = ends.promise.get("tail");
+               ends.promise = ends.promise.get("");

[Survived] BlockStatement
queue.js:20:49
-               return result.fail(function (error) {
-                   closed.resolve(error);
-                   throw error;
-               });
+               return result.fail(function (error) {});

[Survived] BlockStatement
queue.js:26:33
-           close: function (error) {
-               error = error || new Error("Can't get value from closed queue");
-               var end = {head: Q.reject(error)};
-               end.tail = end;
-               ends.resolve(end);
-               return closed.promise;
-           }
+           close: function (error) {}

[Survived] ConditionalExpression
queue.js:27:21
-               error = error || new Error("Can't get value from closed queue");
+               error = true;

[Survived] ConditionalExpression
queue.js:27:21
-               error = error || new Error("Can't get value from closed queue");
+               error = false;

[Survived] LogicalOperator
queue.js:27:21
-               error = error || new Error("Can't get value from closed queue");
+               error = error && new Error("Can't get value from closed queue");

[Survived] StringLiteral
queue.js:27:40
-               error = error || new Error("Can't get value from closed queue");
+               error = error || new Error("");

[Survived] ObjectLiteral
queue.js:28:23
-               var end = {head: Q.reject(error)};
+               var end = {};

Ran 0.94 tests per mutant on average.
----------|---------|----------|-----------|------------|----------|----------|
File      | % score | # killed | # timeout | # survived | # no cov | # errors |
----------|---------|----------|-----------|------------|----------|----------|
All files |   12.38 |       68 |        63 |        927 |        0 |        0 |
 q.js     |   12.55 |       68 |        63 |        913 |        0 |        0 |
 queue.js |    0.00 |        0 |         0 |         14 |        0 |        0 |
----------|---------|----------|-----------|------------|----------|----------|
[32m15:11:13 (2224) INFO HtmlReporter[39m Your report can be found at: file:///home/runner/work/llm-mutation-testing/llm-mutation-testing/q/reports/mutation/mutation.html
[32m15:11:13 (2224) INFO MutationTestExecutor[39m Done in 125 minutes 14 seconds.

real	125m16.194s
user	20m52.196s
sys	3m40.454s
