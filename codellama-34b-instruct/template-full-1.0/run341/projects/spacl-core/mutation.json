{"files":{"src/matcher.ts":{"language":"typescript","mutants":[{"id":"0","mutatorName":"PrecomputedMutator","replacement":"spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48\n(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✕ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains invalid characters\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with invalid characters\n\n    expected path spec '/ ' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9f\na48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /\n^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : \nstryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nTest Suites: 4 failed, 4 total\nTests:       30 failed, 8 passed, 38 total\nSnapshots:   0 total\nTime:        3.267 s, estimated 4 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":55,"line":12},"start":{"column":9,"line":12}}},{"id":"1","mutatorName":"PrecomputedMutator","replacement":"!spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/)","status":"Survived","testsCompleted":1,"location":{"end":{"column":55,"line":12},"start":{"column":9,"line":12}}},{"id":"2","mutatorName":"PrecomputedMutator","replacement":"spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null","status":"Survived","testsCompleted":1,"location":{"end":{"column":55,"line":12},"start":{"column":9,"line":12}}},{"id":"3","mutatorName":"PrecomputedMutator","replacement":"/^[a-zA-Z0-9_/:~.$+*-.]*$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (12 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✕ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures (2 ms)\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly (2 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly (6 ms)\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with invalid characters\n\n    expected path spec '/,' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        3.025 s, estimated 4 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":12},"start":{"column":20,"line":12}}},{"id":"4","mutatorName":"PrecomputedMutator","replacement":"/^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (6 ms)\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (5 ms)\n    ✓ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✕ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with invalid characters\n\n    expected path spec '/,' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.878 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":12},"start":{"column":20,"line":12}}},{"id":"5","mutatorName":"PrecomputedMutator","replacement":"/^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec\n.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryM\nutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✕ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (1 ms)\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains invalid characters\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with invalid characters\n\n    expected path spec '/ ' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must \nbegin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      \n60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       30 failed, 8 passed, 38 total\nSnapshots:   0 total\nTime:        3.023 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":12},"start":{"column":20,"line":12}}},{"id":"6","mutatorName":"PrecomputedMutator","replacement":"/^\\\\/.test(spec) !== null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (1 ms)\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path must begin with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at Function.for (src/matcher.ts:95:12)\n \n     at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        2.866 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":15},"start":{"column":9,"line":15}}},{"id":"7","mutatorName":"PrecomputedMutator","replacement":"spec.charAt(0) !== '/'","status":"Survived","testsCompleted":1,"location":{"end":{"column":35,"line":15},"start":{"column":9,"line":15}}},{"id":"8","mutatorName":"PrecomputedMutator","replacement":"spec.search","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n    ✕ rejects empty paths\n\n    ✕ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects empty paths\n\n    expected path spec '' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths without leading slashes\n\n    expected path spec '+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.585 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":15},"start":{"column":9,"line":15}}},{"id":"9","mutatorName":"PrecomputedMutator","replacement":"spec.includes","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: First argument to String.prototype.includes must not be a regular expression\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\\n//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec\n.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:210)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    TypeError: First argument to String.prototype.includes must not be a regular expression\n        at String.includes (<anonymous>)\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                                                                  ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher\n (src/matcher.ts:61:210)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        2.571 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":15},"start":{"column":9,"line":15}}},{"id":"10","mutatorName":"PrecomputedMutator","replacement":"spec.find","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: spec.find is not a function\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Ob\nject.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.m\natch(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    TypeError: spec.find is not a function\n\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n    > 61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n         |                                                                                                                                                                       ^\n      62 |       throw new Error('Path must begin with a slash');\n      63 |     }\n      64 |     if (stryMutAct_9fa48(\"12\") ? spec.match(/[/]{2}/) !== null : stryMutAct_9fa48(\"11\") ? spec.match(/(\\/\\/)/) !== null : (stryCov_9fa48(\"11\", \"12\"), spec.match(stryMutAct_9fa48(\"13\") ? /\\/\\/+/ : (stryCov_9fa48(\"13\"), /\\/\\//)) !== null)) {\n\n      at new Matcher (src/matcher.ts:61:167)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        2.599 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":15},"start":{"column":9,"line":15}}},{"id":"11","mutatorName":"PrecomputedMutator","replacement":"spec.match(/(\\/\\/)/) !== null","status":"Survived","testsCompleted":1,"location":{"end":{"column":36,"line":18},"start":{"column":9,"line":18}}},{"id":"12","mutatorName":"PrecomputedMutator","replacement":"spec.match(/[/]{2}/) !== null","status":"Survived","testsCompleted":1,"location":{"end":{"column":36,"line":18},"start":{"column":9,"line":18}}},{"id":"13","mutatorName":"PrecomputedMutator","replacement":"/\\/\\/+/","status":"Survived","testsCompleted":1,"location":{"end":{"column":26,"line":18},"start":{"column":20,"line":18}}},{"id":"14","mutatorName":"PrecomputedMutator","replacement":"spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths (2 ms)\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✕ rejects paths with malformed wildcards (1 ms)\n\n    ✕ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n      ✕ rejects specs with match-one-or-none wildcards\n      ✕ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains malformed wildcards\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with malformed wildcards\n\n    expected path spec '/foo+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:foo+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : \n(stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wild\ncard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › when using version 1 › rejects specs with match-one-or-none wildcards\n\n    expected path spec '/++' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › when using version 1 › rejects specs with match-many-or-none wildcards\n\n    expected path spec '/**' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       33 failed, 5 passed, 38 total\nSnapshots:   0 total\nTime:        2.583 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":66,"line":23},"start":{"column":9,"line":21}}},{"id":"15","mutatorName":"PrecomputedMutator","replacement":"spec.match(/[^/]:|:\\/|:$/) == null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (2 ms)\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✕ rejects paths with malformed captures (1 ms)\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains malformed captures\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.mat\nch(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? \n/:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       30 failed, 8 passed, 38 total\nSnapshots:   0 total\nTime:        2.666 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":44,"line":26},"start":{"column":9,"line":26}}},{"id":"16","mutatorName":"PrecomputedMutator","replacement":"spec.match(/[^/]:|:\\/|:$/) !== undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly (9 ms)\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains malformed captures\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw \nnew Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_\n9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        2.506 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":44,"line":26},"start":{"column":9,"line":26}}},{"id":"17","mutatorName":"PrecomputedMutator","replacement":"spec.match(/[^/]:|:\\/|:$/) == 'something'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (4 ms)\n\n    ✓ answers queries correctly (9 ms)\n    ✓ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✕ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        3.024 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":44,"line":26},"start":{"column":9,"line":26}}},{"id":"18","mutatorName":"PrecomputedMutator","replacement":"/[^/]:|\\/:|:$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly\n    ✓ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:20:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:62:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/:foo' to be accepted: Path contains malformed captures\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"17\") ? spec.match(/[^/]:|:\\/|:$/) == 'something' : stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== undefined : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) == null : (stryCov_9fa48(\"15\", \"16\", \"17\"), spec.match(stryMutAct_9fa48(\"19\") ? /:\\/|[^/]:|:$/ : stryMutAct_9fa48(\"18\") ? /[^/]:|\\/:|:$/ : (stryCov_9fa48(\"18\", \"19\"), /[^/]:|:\\/|:$/)) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.481 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":26},"start":{"column":20,"line":26}}},{"id":"19","mutatorName":"PrecomputedMutator","replacement":"/:\\/|[^/]:|:$/","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":26},"start":{"column":20,"line":26}}},{"id":"20","mutatorName":"PrecomputedMutator","replacement":"spec.match(/^.+?\\./) !== null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (3 ms)\n\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (3 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✕ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/_~.$-' to be accepted: Path must not end with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with trailing slashes\n\n    expected path spec '/+/' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.44 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":29},"start":{"column":9,"line":29}}},{"id":"21","mutatorName":"PrecomputedMutator","replacement":"spec.match(/^.+?[^\\/]/) !== null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (3 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (1 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/+' to be accepted: Path must not end with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMut\nAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        2.419 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":29},"start":{"column":9,"line":29}}},{"id":"22","mutatorName":"PrecomputedMutator","replacement":"/^[^/]+\\/$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (2 ms)\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (3 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (2 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (4 ms)\n    ✓ answers queries correctly (3 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✕ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with trailing slashes\n\n    expected path spec '/+/' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.735 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":29},"start":{"column":20,"line":29}}},{"id":"23","mutatorName":"PrecomputedMutator","replacement":"/^.+\\/+$/","status":"Survived","testsCompleted":1,"location":{"end":{"column":28,"line":29},"start":{"column":20,"line":29}}},{"id":"24","mutatorName":"PrecomputedMutator","replacement":"/^.+\\/+\\*$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (4 ms)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:28:21)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✕ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/+/*' to be accepted: Path must not end with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with trailing slashes\n\n    expected path spec '/+/' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"21\") ? spec.match(/^.+?[^\\/]/) !== null : stryMutAct_9fa48(\"20\") ? spec.match(/^.+?\\./) !== null : (stryCov_9fa48(\"20\", \"21\"), spec.match(stryMutAct_9fa48(\"24\") ? /^.+\\/+\\*$/ : stryMutAct_9fa48(\"23\") ? /^.+\\/+$/ : stryMutAct_9fa48(\"22\") ? /^[^/]+\\/$/ : (stryCov_9fa48(\"22\", \"23\", \"24\"), /^.+\\/$/)) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.537 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":29},"start":{"column":20,"line":29}}},{"id":"25","mutatorName":"PrecomputedMutator","replacement":"undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (7 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Cannot read properties of undefined (reading 'split')\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matc\nher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                      \n                                                                                                                                    ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'split')\n\n      209 |   } else {\n      210 |     stryCov_9fa48(\"58\", \"59\", \"60\");\n    > 211 |     for (const part of stryMutAct_9fa48(\"63\") ? spec.split('*').slice(1).reverse() : stryMutAct_9fa48(\"62\") ? spec.split('/').slice(2).reverse() : stryMutAct_9fa48(\"61\") ? spec.split('\\n').slice(1).reverse() : (stryCov_9fa48(\"61\", \"62\", \"63\"), spec.split(stryMutAct_9fa48(\"64\") ? '\\/' : (stryCov_9fa48(\"64\"), '/')).slice(1).reverse())) {\n          |                                                                                                                                                                                                                                                          ^\n      212 |       switch (stryMutAct_9fa48(\"66\") ? part.split('/').pop() : stryMutAct_9fa48(\"65\") ? part + '/' : (stryCov_9fa48(\"65\", \"66\"), part)) {\n      213 |         case '+':\n      214 |           min++;\n\n      at compile (src/matcher.ts:211:250)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        2.84 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":42,"line":32},"start":{"column":38,"line":32}}},{"id":"26","mutatorName":"PrecomputedMutator","replacement":"'/'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (6 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (7 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (3 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (4 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly (1 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo$\"\n    Received:\n      \"^\\\\/$\"\n\n    Message:\n      path spec '/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo$\n    + ^\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |         \n           ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        2.523 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":42,"line":32},"start":{"column":38,"line":32}}},{"id":"27","mutatorName":"PrecomputedMutator","replacement":"string.length < 1 || !string.endsWith('/')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (6 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (5 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly (1 ms)\n    ✕ matches literal path segments correctly (7 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (2 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        2.549 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":50,"line":39},"start":{"column":9,"line":39}}},{"id":"28","mutatorName":"PrecomputedMutator","replacement":"!string.endsWith('/*')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (28 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (5 ms)\n    ✕ prioritises deny over allow (3 ms)\n\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (5 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        2.515 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":50,"line":39},"start":{"column":9,"line":39}}},{"id":"29","mutatorName":"PrecomputedMutator","replacement":"string.length === 0","status":"Survived","testsCompleted":1,"location":{"end":{"column":50,"line":39},"start":{"column":9,"line":39}}},{"id":"30","mutatorName":"PrecomputedMutator","replacement":"string.includes","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (2 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly (2 ms)\n\n    ✕ matches literal path segments correctly (5 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        2.433 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":39},"start":{"column":30,"line":39}}},{"id":"31","mutatorName":"PrecomputedMutator","replacement":"'B'","status":"Survived","testsCompleted":1,"location":{"end":{"column":49,"line":39},"start":{"column":46,"line":39}}},{"id":"32","mutatorName":"PrecomputedMutator","replacement":"42","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (6 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n  rule\n\n    ✕ matches paths correctly (7 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✕ matches literal path segments correctly (9 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        2.833 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":42},"start":{"column":32,"line":42}}},{"id":"33","mutatorName":"PrecomputedMutator","replacement":"undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (17 ms)\n    ✕ answers queries correctly (4 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly (1 ms)\n    ✕ matches literal path segments correctly (4 ms)\n    ✕ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly (2 ms)\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (6 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (2 ms)\n\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        2.585 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":42},"start":{"column":32,"line":42}}},{"id":"34","mutatorName":"PrecomputedMutator","replacement":"null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (14 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (2 ms)\n    ✕ clones itself correctly (2 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (2 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (12 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✕ matches literal path segments correctly (4 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        2.625 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":42},"start":{"column":32,"line":42}}},{"id":"35","mutatorName":"PrecomputedMutator","replacement":"min > 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (10 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (3 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (6 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.552 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":64},"start":{"column":9,"line":64}}},{"id":"36","mutatorName":"PrecomputedMutator","replacement":"parts.length > 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (7 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (7 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (2 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (18 ms)\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^(?:\\\\/[^/]+){0}\\\\/$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^(?:\\/[^/]+){0}\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^(?:\\\\/[^/]+){0}\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^(?:\\/[^/]+){0}\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const matc\nh = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       18 failed, 20 passed, 38 total\nSnapshots:   0 total\nTime:        2.506 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":64},"start":{"column":9,"line":64}}},{"id":"37","mutatorName":"PrecomputedMutator","replacement":"props.length > 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (10 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (3 ms)\n    ✕ compiles match-one wildcard segments correctly (7 ms)\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^(?:\\\\/[^/]+){0}\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^(?:\\/[^/]+){0}\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' t\no${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       17 failed, 21 passed, 38 total\nSnapshots:   0 total\nTime:        3.649 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":64},"start":{"column":9,"line":64}}},{"id":"38","mutatorName":"PrecomputedMutator","replacement":"final && !opt && min < 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (3 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (2 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.568 s, estimated 4 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":65},"start":{"column":11,"line":65}}},{"id":"39","mutatorName":"PrecomputedMutator","replacement":"final && opt && min > 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n  rule\n\n    ✕ matches paths correctly (6 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/*/*'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:27:5)\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (9 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (3 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2,}$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/+/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2,}$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.474 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":65},"start":{"column":11,"line":65}}},{"id":"40","mutatorName":"PrecomputedMutator","replacement":"final && !opt && min === 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (2 ms)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly (5 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.461 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":65},"start":{"column":11,"line":65}}},{"id":"41","mutatorName":"PrecomputedMutator","replacement":"min >= 1","status":"Survived","testsCompleted":1,"location":{"end":{"column":25,"line":67},"start":{"column":18,"line":67}}},{"id":"42","mutatorName":"PrecomputedMutator","replacement":"min !== 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (4 ms)\n\n    ✓ answers queries correctly (3 ms)\n\n\nFAIL test/rule.ts\n  rule\n\n    ✕ matches paths correctly (9 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly (5 ms)\n    ✕ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        2.398 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":25,"line":67},"start":{"column":18,"line":67}}},{"id":"43","mutatorName":"PrecomputedMutator","replacement":"(min & 1) === 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly (4 ms)\n    ✕ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        2.568 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":25,"line":67},"start":{"column":18,"line":67}}},{"id":"44","mutatorName":"PrecomputedMutator","replacement":"max--","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutA\nct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undef\nined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : st\nryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : str\nyMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly\n\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    TypeError: (intermediate value)(intermediate value)(intermediate value) is not a function\n\n      120 |   }\n      121 |   function finalise(): string {\n    > 122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n          |                                                                      ^\n      123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n\n      at finalise (src/matcher.ts:122:70)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        2.385 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":12,"line":89},"start":{"column":5,"line":89}}},{"id":"45","mutatorName":"PrecomputedMutator","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (7 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (2 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (5 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.658 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":17,"line":89},"start":{"column":13,"line":89}}},{"id":"46","mutatorName":"PrecomputedMutator","replacement":"null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly (3 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✕ compiles match-one-or-none wildcard segments correctly (4 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.298 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":17,"line":89},"start":{"column":13,"line":89}}},{"id":"47","mutatorName":"PrecomputedMutator","replacement":"undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly (3 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policy.ts\n  policy\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.261 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":17,"line":89},"start":{"column":13,"line":89}}},{"id":"48","mutatorName":"PrecomputedMutator","replacement":"parts.reduce((acc, seg) => acc + seg)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (6 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n\nFAIL test/rule.ts\n  rule\n    ✕ matches paths correctly (5 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (3 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match '/food'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |        \n if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/**' to not match '/bar/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/foo/bar/boo/baz'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       19 failed, 19 passed, 38 total\nSnapshots:   0 total\nTime:        2.596 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":78,"line":90},"start":{"column":36,"line":90}}},{"id":"49","mutatorName":"PrecomputedMutator","replacement":"parts.reduce((acc, seg) => acc.concat(seg))","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (6 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (4 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (3 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match '/food'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match \n= value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/**' to not match '/bar/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/foo/bar/boo/baz'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       19 failed, 19 passed, 38 total\nSnapshots:   0 total\nTime:        2.547 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":78,"line":90},"start":{"column":36,"line":90}}},{"id":"50","mutatorName":"PrecomputedMutator","replacement":"parts.reduce((acc, seg) => seg.concat(acc))","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (2 ms)\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (5 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (6 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/yeah/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (14 ms)\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly (1 ms)\n    ✕ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match '/food'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path s\npec '/+' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*/bar' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**/boo' to not match '/boo/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/foo/bar/boo/baz'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       19 failed, 19 passed, 38 total\nSnapshots:   0 total\nTime:        2.496 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":78,"line":90},"start":{"column":36,"line":90}}},{"id":"51","mutatorName":"PrecomputedMutator","replacement":"parts.length","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● rule › matches paths correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.\nts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes (6 ms)\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: parts.length is not a function\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc\n, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + s\neg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: parts.length is not a function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    TypeError: parts.length is not \na function\n\n      121 |   function finalise(): string {\n      122 |     (stryMutAct_9fa48(\"44\") ? max-- : (stryCov_9fa48(\"44\"), flatten))(stryMutAct_9fa48(\"47\") ? undefined : stryMutAct_9fa48(\"46\") ? null : stryMutAct_9fa48(\"45\") ? false : (stryCov_9fa48(\"45\", \"46\", \"47\"), true));\n    > 123 |     return (opt ? '^/$|^' : '^') + (stryMutAct_9fa48(\"51\") ? parts.length((acc, seg) => seg + acc, '$') : stryMutAct_9fa48(\"50\") ? parts.reduce((acc, seg) => seg.concat(acc)) : stryMutAct_9fa48(\"49\") ? parts.reduce((acc, seg) => acc.concat(seg)) : stryMutAct_9fa48(\"48\") ? parts.reduce((acc, seg) => acc + seg) : (stryCov_9fa48(\"48\", \"49\", \"50\", \"51\"), parts.reduce(stryMutAct_9fa48(\"54\") ? (acc, seg) => acc + Math.random() : stryMutAct_9fa48(\"53\") ? (acc, seg) => acc + '*' + seg : stryMutAct_9fa48(\"52\") ? (acc, seg) => acc + seg : (stryCov_9fa48(\"52\", \"53\", \"54\"), (acc, seg) => seg + acc), stryMutAct_9fa48(\"57\") ? '/' : stryMutAct_9fa48(\"56\") ? '/\\\\' : stryMutAct_9fa48(\"55\") ? '$$' : (stryCov_9fa48(\"55\", \"56\", \"57\"), '$'))));\n          |                                                                    ^\n      124 |   }\n      125 |   if (stryMutAct_9fa48(\"60\")) {\n      126 |     for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n\n      at finalise (src/matcher.ts:123:68)\n      at compile (src/matcher.ts:240:12)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        2.698 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":48,"line":90},"start":{"column":36,"line":90}}},{"id":"52","mutatorName":"PrecomputedMutator","replacement":"(acc, seg) => acc + seg","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (5 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (7 ms)\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly (1 ms)\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^$\\\\/\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^$\\/\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^$\\\\/[^/]+\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^$\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^$(?:\\\\/[^/]+)+\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^$(?:\\/[^/]+)+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\\\\/[^/]+\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$(?:\\\\/[^/]+)+\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$(?:\\/[^/]+)+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^$\\\\/[^/]+\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^$\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^$\\\\/([^/]+)\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^$\\/([^/]+)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value\n.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        2.451 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":72,"line":90},"start":{"column":49,"line":90}}},{"id":"53","mutatorName":"PrecomputedMutator","replacement":"(acc, seg) => acc + '*' + seg","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    SyntaxError: Invalid regular expression: /^$*/yeah/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    SyntaxError: Invalid regular expression: /^$*/nah/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    SyntaxError: Invalid regular expression: /^$*/yeah/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    SyntaxError: Invalid regular expression: /^$*/([^/]+)/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    SyntaxError: Invalid regular expression: /^$*/foo/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    SyntaxError: Invalid regular expression: /^$*/([^/]+)/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    SyntaxError: Invalid regular expression: /^$*(?:/[^/]+)+/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    SyntaxError: Invalid regular expression: /^$*/test/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly (1 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Invalid regular expression: /^$*//: Nothing to repeat\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    SyntaxError: Invalid regular expression: /^$*//: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^$*/[^/]+/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^$*(?:/[^/]+)+/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^$*/[^/]+/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^$*(?:/[^/]+)+/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^$*/[^/]+/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    SyntaxError: Invalid regular expression: /^$*/([^/]+)/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    SyntaxError: Invalid regular expression: /^$*/foo/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^$*/[^/]+/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^$*(?:/[^/]+)+/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^$*/[^/]+/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^$*(?:/[^/]+)+/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^$*(?:/[^/]+){2,}/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    SyntaxError: Invalid regular expression: /^$*/([^/]+)/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    SyntaxError: Invalid regular expression: /^$*/yeah/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    SyntaxError: Invalid regular expression: /^$*/([^/]+)/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    SyntaxError: Invalid regular expression: /^$*/test/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    SyntaxError: Invalid regular expression: /^$*/([^/]+)/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    SyntaxError: Invalid regular expression: /^$*/test/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    SyntaxError: Invalid regular expression: /^$*/nah/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        2.531 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":72,"line":90},"start":{"column":49,"line":90}}},{"id":"54","mutatorName":"PrecomputedMutator","replacement":"(acc, seg) => acc + Math.random()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (11 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (4 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (5 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (4 ms)\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^$0.9581768705964211\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^$0.9581768705964211\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^$0.3030049348207289\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^$0.3030049348207289\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^$0.21207565747388935\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^$0.21207565747388935\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$0.35478045094707156\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$0.35478045094707156\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$0.85054835171795\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$0.85054835171795\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^$0.5140694384265505\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^$0.5140694384265505\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^$0.9059536148765313\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^$0.9059536148765313\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expe\ncted)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        2.553 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":72,"line":90},"start":{"column":49,"line":90}}},{"id":"55","mutatorName":"PrecomputedMutator","replacement":"'$$'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (3 ms)\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (2 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+$$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+$$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+$$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+$$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+$$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)$$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)$$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.508 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":77,"line":90},"start":{"column":74,"line":90}}},{"id":"56","mutatorName":"PrecomputedMutator","replacement":"'/\\\\'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    SyntaxError: Invalid regular expression: /^/yeah/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    SyntaxError: Invalid regular expression: /^/([^/]+)/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    SyntaxError: Invalid regular expression: /^/foo/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    SyntaxError: Invalid regular expression: /^/([^/]+)/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    SyntaxError: Invalid regular expression: /^(?:/[^/]+)+/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    SyntaxError: Invalid regular expression: /^/test/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    SyntaxError: Invalid regular expression: /^/yeah/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    SyntaxError: Invalid regular expression: /^/([^/]+)/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    SyntaxError: Invalid regular expression: /^/test/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    SyntaxError: Invalid regular expression: /^/([^/]+)/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    SyntaxError: Invalid regular expression: /^/test/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    SyntaxError: Invalid regular expression: /^/nah/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    SyntaxError: Invalid regular expression: /^/yeah/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    SyntaxError: Invalid regular expression: /^/nah/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Invalid regular expression: /^//\\/: \\ at end of pattern\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    SyntaxError: Invalid regular expression: /^//\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/[^/]+/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^(?:/[^/]+)+/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^/[^/]+/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^(?:/[^/]+)+/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/[^/]+/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    SyntaxError: Invalid regular expression: /^/([^/]+)/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    SyntaxError: Invalid regular expression: /^/foo/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/[^/]+/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^(?:/[^/]+)+/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^/[^/]+/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^(?:/[^/]+)+/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n      \n   |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^(?:/[^/]+){2,}/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    SyntaxError: Invalid regular expression: /^/([^/]+)/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        2.472 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":77,"line":90},"start":{"column":74,"line":90}}},{"id":"57","mutatorName":"PrecomputedMutator","replacement":"'/'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (6 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (5 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/\\\\/\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/\\/\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+\\/\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+\\/\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+\\\\/\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+\\/\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+\\\\/\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+\\/\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+\\/\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)\\\\/\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)\\/\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |       \n  const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        2.309 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":77,"line":90},"start":{"column":74,"line":90}}},{"id":"58","mutatorName":"PrecomputedMutator","replacement":"for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n  switch (part) {\n    case '+':\n      min++;\n      max++;\n      break;\n    case '++':\n      max++;\n      break;\n    case '*':\n      min++;\n      any = true;\n      break;\n    case '**':\n      any = true;\n      break;\n    default:\n      flatten();\n      opt = false;\n      if (part.match(/:.+/) !== null) {\n        props.push(part.slice(1));\n        parts.push('/([^/]+)');\n      } else {\n        parts.push(`/${part.replace(/([.$])/g, '\\\\$1')}`);\n      }\n  }\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (1 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly (1 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: spec.split(...).slice(...).reverse(...).split is not a function\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (par\nt) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    TypeError: spec.split(...).slice(...).reverse(...).split is not a function\n\n      180 |     }\n      181 |   } else if (stryMutAct_9fa48(\"58\")) {\n    > 182 |     for (const part of spec.split('/').slice(1).reverse().split('').reverse().join('')) {\n          |                                                           ^\n      183 |       switch (part) {\n      184 |         case '+':\n      185 |           min++;\n\n      at compile (src/matcher.ts:182:59)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        2.346 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":118},"start":{"column":3,"line":92}}},{"id":"59","mutatorName":"PrecomputedMutator","replacement":"for (const part of spec.split('/').slice(1).map(segment => segment.toUpperCase())) {\n  switch (part) {\n    case '+':\n      min++;\n      max++;\n      break;\n    case '++':\n      max++;\n      break;\n    case '*':\n      min++;\n      any = true;\n      break;\n    case '**':\n      any = true;\n      break;\n    default:\n      flatten();\n      opt = false;\n      if (part.match(/:.+/) !== null) {\n        props.push(part.slice(1));\n        parts.push('/([^/]+)');\n      } else {\n        parts.push(`/${part.replace(/([.$])/g, '\\\\$1')}`);\n      }\n  }\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (7 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (5 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (3 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (1 ms)\n\n    ✕ matches literal path segments correctly (1 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo$\"\n    Received:\n      \"^\\\\/FOO$\"\n\n    Message:\n      path spec '/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo$\n    + ^\\/FOO$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/FOO\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/FOO\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^\\\\/FOO(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^\\/FOO(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^\\\\/FOO(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^\\/FOO(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^\\\\/FOO(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^\\/FOO(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/FOO\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^\\/[^/]+\\/FOO\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\"]\n    Received:\n      [\"FOO\"]\n\n    Message:\n      path spec '/:foo' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"foo\",\n    +   \"FOO\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/*' to\n match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"bar\", \"baz\"]\n    Received:\n      [\"foo\", \"boo\"]\n\n    Message:\n      path spec '/+/:a/*/:b' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"bar\",\n    -   \"baz\",\n    +   \"foo\",\n    +   \"boo\",\n      ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n\nTest Suites: 4 failed, 4 total\nTests:       26 failed, 12 passed, 38 total\nSnapshots:   0 total\nTime:        2.346 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":118},"start":{"column":3,"line":92}}},{"id":"60","mutatorName":"PrecomputedMutator","replacement":"for (const part of spec.split('/').slice(1).filter(segment => segment.match(/[a-zA-Z]/))) {\n  switch (part) {\n    case '+':\n      min++;\n      max++;\n      break;\n    case '++':\n      max++;\n      break;\n    case '*':\n      min++;\n      any = true;\n      break;\n    case '**':\n      any = true;\n      break;\n    default:\n      flatten();\n      opt = false;\n      if (part.match(/:.+/) !== null) {\n        props.push(part.slice(1));\n        parts.push('/([^/]+)');\n      } else {\n        parts.push(`/${part.replace(/([.$])/g, '\\\\$1')}`);\n      }\n  }\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (3 ms)\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (14 ms)\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (3 ms)\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (2 ms)\n\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\", \"bar\"]\n    Received:\n      [\"bar\", \"foo\"]\n\n    Message:\n      path spec '/:foo/:bar' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"foo\",\n        \"bar\",\n    +   \"foo\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/bar' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), \nexpected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (8 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        2.285 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":118},"start":{"column":3,"line":92}}},{"id":"61","mutatorName":"PrecomputedMutator","replacement":"spec.split('\\n').slice(1).reverse()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (3 ms)\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✕ compiles literal path segments correctly (3 ms)\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), \nexpected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        2.287 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":92},"start":{"column":22,"line":92}}},{"id":"62","mutatorName":"PrecomputedMutator","replacement":"spec.split('/').slice(2).reverse()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (6 ms)\n\n    ✕ answers queries correctly (9 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n  rule\n    ✕ matches paths correctly (6 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (5 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (4 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), \nexpected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        2.322 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":92},"start":{"column":22,"line":92}}},{"id":"63","mutatorName":"PrecomputedMutator","replacement":"spec.split('*').slice(1).reverse()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (5 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✕ compiles literal path segments correctly (4 ms)\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/\\\\/$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        2.482 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":92},"start":{"column":22,"line":92}}},{"id":"64","mutatorName":"PrecomputedMutator","replacement":"'\\/'","status":"Survived","testsCompleted":1,"location":{"end":{"column":36,"line":92},"start":{"column":33,"line":92}}},{"id":"65","mutatorName":"PrecomputedMutator","replacement":"part + '/'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (10 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('dynamic', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (3 ms)\n\n    ✕ compiles match-one wildcard segments correctly (10 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/++' to be accepted: Invalid regular expression: /^/++$/: Nothing to repeat\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/*$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/++$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/**$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/+\\\\/([^/]+)\\\\/*\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/+\\/([^/]+)\\/*\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/++$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/**$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"26\") ? '/' : stryMutAct_9fa48(\"25\") ? undefined : (stryCov_9fa48(\"25\", \"26\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new M\natcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/:a/*/:b' to match '/foo/bar/boo/baz'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (5 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       19 failed, 19 passed, 38 total\nSnapshots:   0 total\nTime:        2.37 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":17,"line":93},"start":{"column":13,"line":93}}},{"id":"66","mutatorName":"PrecomputedMutator","replacement":"part.split('/').pop()","status":"Survived","testsCompleted":1,"location":{"end":{"column":17,"line":93},"start":{"column":13,"line":93}}},{"id":"67","mutatorName":"PrecomputedMutator","replacement":"part.search(/:.+/) !== -1","status":"Survived","testsCompleted":1,"location":{"end":{"column":39,"line":111},"start":{"column":13,"line":111}}},{"id":"68","mutatorName":"PrecomputedMutator","replacement":"part.match(/:\\w+/) !== null","status":"Survived","testsCompleted":1,"location":{"end":{"column":39,"line":111},"start":{"column":13,"line":111}}},{"id":"69","mutatorName":"PrecomputedMutator","replacement":"part.match(/\\W+/) !== null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (6 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✕ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/\\\\.foo$\"\n    Received:\n      \"^\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/.foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/\\.foo$\n    + ^\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/.foo' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.274 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":39,"line":111},"start":{"column":13,"line":111}}},{"id":"70","mutatorName":"PrecomputedMutator","replacement":"/:.*/","status":"Survived","testsCompleted":1,"location":{"end":{"column":29,"line":111},"start":{"column":24,"line":111}}},{"id":"71","mutatorName":"PrecomputedMutator","replacement":"/:+/","status":"Survived","testsCompleted":1,"location":{"end":{"column":29,"line":111},"start":{"column":24,"line":111}}},{"id":"72","mutatorName":"PrecomputedMutator","replacement":"/:([^/]+)/","status":"Survived","testsCompleted":1,"location":{"end":{"column":29,"line":111},"start":{"column":24,"line":111}}},{"id":"73","mutatorName":"PrecomputedMutator","replacement":"part[1]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (7 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (3 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (4 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\"]\n    Received:\n      [\"f\"]\n\n    Message:\n      path spec '/:foo' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"foo\",\n    +   \"f\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.859 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":112},"start":{"column":22,"line":112}}},{"id":"74","mutatorName":"PrecomputedMutator","replacement":"part.substr(1)","status":"Survived","testsCompleted":1,"location":{"end":{"column":35,"line":112},"start":{"column":22,"line":112}}},{"id":"75","mutatorName":"PrecomputedMutator","replacement":"part.substring(1)","status":"Survived","testsCompleted":1,"location":{"end":{"column":35,"line":112},"start":{"column":22,"line":112}}},{"id":"76","mutatorName":"PrecomputedMutator","replacement":"0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (9 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (11 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (3 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (4 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\"]\n    Received:\n      [\":foo\"]\n\n    Message:\n      path spec '/:foo' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"foo\",\n    +   \":foo\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.336 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":112},"start":{"column":33,"line":112}}},{"id":"77","mutatorName":"PrecomputedMutator","replacement":"-1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly (4 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (6 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\"]\n    Received:\n      [\"o\"]\n\n    Message:\n      path spec '/:foo' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"foo\",\n    +   \"o\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.609 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":112},"start":{"column":33,"line":112}}},{"id":"78","mutatorName":"PrecomputedMutator","replacement":"props.length","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (4 ms)\n\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (5 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly (4 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\"]\n    Received:\n      [\":foo\"]\n\n    Message:\n      path spec '/:foo' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"foo\",\n    +   \":foo\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.796 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":112},"start":{"column":33,"line":112}}},{"id":"79","mutatorName":"PrecomputedMutator","replacement":"parts.add","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: parts.add is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                                                                     ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:149)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: parts.add is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                                                                     ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:149)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: parts.add is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                                                                     ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:149)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: parts.add is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                                                                     ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:149)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: parts.add is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                                                                     ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:149)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:20:17)\n\n  ● policymap › answers queries correctly\n\n    TypeError: parts.add is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                                                                     ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:149)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:62:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/:foo' to be accepted: parts.add is not a function\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles capture segments correctly\n\n    TypeError: parts.add is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                                                                     ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:149)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches capture segments correctly\n\n    TypeError: parts.add is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                                                                     ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:149)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.389 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":113},"start":{"column":11,"line":113}}},{"id":"80","mutatorName":"PrecomputedMutator","replacement":"parts.insert","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: parts.insert is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                 ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:97)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: parts.insert is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                 ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:97)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    TypeError: parts.insert is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                 ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:97)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:20:17)\n\n  ● policymap › answers queries correctly\n\n    TypeError: parts.insert is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                 ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:97)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:62:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (6 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/:foo' to be accepted: parts.insert is not a function\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles capture segments correctly\n\n    TypeError: parts.insert is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                 ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:97)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches capture segments correctly\n\n    TypeError: parts.insert is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                 ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:97)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: parts.insert is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                 ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:97)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: parts.insert is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                                                                                 ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:97)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n\nTest Suites: 4 failed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.477 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":113},"start":{"column":11,"line":113}}},{"id":"81","mutatorName":"PrecomputedMutator","replacement":"parts.replace","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: parts.replace is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                            ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:44)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:20:17)\n\n  ● policymap › answers queries correctly\n\n    TypeError: parts.replace is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                            ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:44)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:62:17)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: parts.replace is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                            ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:44)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: parts.replace is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                            ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:44)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly (2 ms)\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (2 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/:foo' to be accepted: parts.replace is not a function\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles capture segments correctly\n\n    TypeError: parts.replace is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                            ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:44)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches capture segments correctly\n\n    TypeError: parts.replace is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                            ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:44)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: parts.replace is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                            ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:44)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: parts.replace is not a function\n\n      230 |           if (stryMutAct_9fa48(\"69\") ? part.match(/\\W+/) !== null : stryMutAct_9fa48(\"68\") ? part.match(/:\\w+/) !== null : stryMutAct_9fa48(\"67\") ? part.search(/:.+/) !== -1 : (stryCov_9fa48(\"67\", \"68\", \"69\"), part.match(stryMutAct_9fa48(\"72\") ? /:([^/]+)/ : stryMutAct_9fa48(\"71\") ? /:+/ : stryMutAct_9fa48(\"70\") ? /:.*/ : (stryCov_9fa48(\"70\", \"71\", \"72\"), /:.+/)) !== null)) {\n      231 |             props.push(stryMutAct_9fa48(\"75\") ? part.substring(1) : stryMutAct_9fa48(\"74\") ? part.substr(1) : stryMutAct_9fa48(\"73\") ? part[1] : (stryCov_9fa48(\"73\", \"74\", \"75\"), part.slice(stryMutAct_9fa48(\"78\") ? props.length : stryMutAct_9fa48(\"77\") ? -1 : stryMutAct_9fa48(\"76\") ? 0 : (stryCov_9fa48(\"76\", \"77\", \"78\"), 1))));\n    > 232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n          |                                            ^\n      233 |           } else {\n      234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n      235 |           }\n\n      at compile (src/matcher.ts:232:44)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n\nTest Suites: 4 failed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.41 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":113},"start":{"column":11,"line":113}}},{"id":"82","mutatorName":"PrecomputedMutator","replacement":"'/([^/]+?)'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (10 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly (4 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+?)$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+?)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.443 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":113},"start":{"column":22,"line":113}}},{"id":"83","mutatorName":"PrecomputedMutator","replacement":"'/(.*)'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (6 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (4 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (3 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly (4 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/(.*)$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/(.*)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.39 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":113},"start":{"column":22,"line":113}}},{"id":"84","mutatorName":"PrecomputedMutator","replacement":"`/${part.replace(/([.$])/g, '')}`","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (8 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/\\\\.foo$\"\n    Received:\n      \"^\\\\/foo$\"\n\n    Message:\n      path spec '/.foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/\\.foo$\n    + ^\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/.foo' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (4 ms)\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (6 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.976 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":59,"line":115},"start":{"column":22,"line":115}}},{"id":"85","mutatorName":"PrecomputedMutator","replacement":"`/${part.replace(/([.$])/g, '$12')}`","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (11 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nFAIL test/matcher.ts\n  matcher\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (5 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✕ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/\\\\.foo$\"\n    Received:\n      \"^\\\\/.2foo$\"\n\n    Message:\n      path spec '/.foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/\\.foo$\n    + ^\\/.2foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/.foo' to match '/.foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.727 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":59,"line":115},"start":{"column":22,"line":115}}},{"id":"86","mutatorName":"PrecomputedMutator","replacement":"`/${part.replace(/([.$])/g, '$2')}`","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (3 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (7 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly (2 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (2 ms)\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/\\\\.foo$\"\n    Received:\n      \"^\\\\/$2foo$\"\n\n    Message:\n      path spec '/.foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/\\.foo$\n    + ^\\/$2foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/.foo' to match '/.foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (3 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (3 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.438 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":59,"line":115},"start":{"column":22,"line":115}}},{"id":"87","mutatorName":"PrecomputedMutator","replacement":"part.replace(/([$/])/g, '\\\\$1')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (7 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (5 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✕ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/\\\\.foo$\"\n    Received:\n      \"^\\\\/.foo$\"\n\n    Message:\n      path spec '/.foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/\\.foo$\n    + ^\\/.foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/.foo' to not match '/Afoo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.376 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":57,"line":115},"start":{"column":26,"line":115}}},{"id":"88","mutatorName":"PrecomputedMutator","replacement":"part.replace(/([^$/])/g, '\\\\$1')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n  matcher\n\n    ✓ accepts valid paths (6 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (4 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo$\"\n    Received:\n      \"^\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo$\n    + ^\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^(?:\\/[^/]+)?\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)*\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/\\\\f\\\\o\\\\o\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^\\/[^/]+\\/\\f\\o\\o\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches m\natch-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (5 ms)\n    ✕ matches context-dependent paths correctly (4 ms)\n    ✕ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n  rule\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       19 failed, 19 passed, 38 total\nSnapshots:   0 total\nTime:        2.393 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":57,"line":115},"start":{"column":26,"line":115}}},{"id":"89","mutatorName":"PrecomputedMutator","replacement":"'\\\\' + $1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (5 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:43:17)\n\n  ● policy › answers queries correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › prioritises deny over allow\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:103:17)\n\n  ● policy › clones itself correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          \n|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (2 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › answers queries correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › prioritises deny over allow\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: $1 is not defined\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^\n/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                         \n                                                                                                                                                                                                                                                                                                                                                                                ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    ReferenceError: $1 is not defined\n\n      232 |             stryMutAct_9fa48(\"81\") ? parts.replace('/([^/]+)') : stryMutAct_9fa48(\"80\") ? parts.insert('/([^/]+)') : stryMutAct_9fa48(\"79\") ? parts.add('/([^/]+)') : (stryCov_9fa48(\"79\", \"80\", \"81\"), parts.push(stryMutAct_9fa48(\"83\") ? '/(.*)' : stryMutAct_9fa48(\"82\") ? '/([^/]+?)' : (stryCov_9fa48(\"82\", \"83\"), '/([^/]+)')));\n      233 |           } else {\n    > 234 |             parts.push(stryMutAct_9fa48(\"86\") ? `/${part.replace(/([.$])/g, '$2')}` : stryMutAct_9fa48(\"85\") ? `/${part.replace(/([.$])/g, '$12')}` : stryMutAct_9fa48(\"84\") ? `/${part.replace(/([.$])/g, '')}` : (stryCov_9fa48(\"84\", \"85\", \"86\"), `/${stryMutAct_9fa48(\"88\") ? part.replace(/([^$/])/g, '\\\\$1') : stryMutAct_9fa48(\"87\") ? part.replace(/([$/])/g, '\\\\$1') : (stryCov_9fa48(\"87\", \"88\"), part.replace(/([.$])/g, stryMutAct_9fa48(\"90\") ? ' життя' : stryMutAct_9fa48(\"89\") ? '\\\\' + $1 : (stryCov_9fa48(\"89\", \"90\"), '\\\\$1')))}`));\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      235 |           }\n      236 |       }\n      237 |     }\n\n      at compile (src/matcher.ts:234:489)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       23 failed, 15 passed, 38 total\nSnapshots:   0 total\nTime:        2.398 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":115},"start":{"column":50,"line":115}}},{"id":"90","mutatorName":"PrecomputedMutator","replacement":"' життя'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (4 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (4 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✕ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/\\\\.foo$\"\n    Received:\n      \"^\\\\/ життяfoo$\"\n\n    Message:\n      path spec '/.foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/\\.foo$\n    + ^\\/ життяfoo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/.foo' to match '/.foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.372 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":115},"start":{"column":50,"line":115}}},{"id":"91","mutatorName":"PrecomputedMutator","replacement":"props.length","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly (1 ms)\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: props.length is not a function\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\n  ● matcher › matches capture segments correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    TypeError: props.length is not a function\n\n      239 |   return {\n      240 |     regex: finalise(),\n    > 241 |     props: stryMutAct_9fa48(\"91\") ? props.length() : (stryCov_9fa48(\"91\"), props.reverse())\n          |                                           ^\n      242 |   };\n      243 | }\n\n      at compile (src/matcher.ts:241:43)\n      at new Matcher (src/matcher.ts:79:9)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:154:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        2.367 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":25,"line":121},"start":{"column":12,"line":121}}}],"source":"\n/** Extended regex for matching paths. */\nexport class Matcher extends RegExp {\n  /** Original path specification that produced this matcher. */\n  readonly spec: string\n  /** Context properties referenced by path specification. */\n  readonly props: string[]\n\n  /** @param spec Path specification.\n    * @param version Specification language version. */\n  constructor (spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    if (spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null) {\n      throw new Error('Path contains invalid characters')\n    }\n    if (spec.match(/^\\//) === null) {\n      throw new Error('Path must begin with a slash')\n    }\n    if (spec.match(/\\/\\//) !== null) {\n      throw new Error('Path contains empty segments')\n    }\n    if (spec.match(version === '1' || version === '1.0'\n      ? /[*+][^/]|[^/][*+]/\n      : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null) {\n      throw new Error('Path contains malformed wildcards')\n    }\n    if (spec.match(/[^/]:|:\\/|:$/) !== null) {\n      throw new Error('Path contains malformed captures')\n    }\n    if (spec.match(/^.+\\/$/) !== null) {\n      throw new Error('Path must not end with a slash')\n    }\n    const { regex, props } = compile(spec)\n    super(regex)\n    this.spec = spec\n    this.props = props\n  }\n\n  [Symbol.match] (string: string): RegExpMatchArray | null {\n    if (string.length > 1 && string.endsWith('/')) {\n      return null\n    }\n    return super[Symbol.match](string)\n  }\n\n  /** Static constructor function; returns a new Matcher.\n    * @param spec Path specification.\n    * @param version Specification language version. */\n  static for (spec: string, version: '1' | '1.0' | '1.1' = '1.1'): Matcher {\n    return new Matcher(spec, version)\n  }\n}\n\nfunction compile (spec: string): {\n  regex: string\n  props: string[]\n} {\n  const parts: string[] = []\n  const props: string[] = []\n  let min = 0\n  let max = 0\n  let any = false\n  let opt = true\n  function flatten (final: boolean = false): void {\n    if (max > 0 || any) {\n      if (final && opt && min < 1) {\n        min = 1\n      } else if (min > 0) {\n        opt = false\n      }\n      parts.push(any\n        ? min < 2\n          ? min < 1\n            ? '(?:/[^/]+)*'\n            : '(?:/[^/]+)+'\n          : `(?:/[^/]+){${min},}`\n        : max === 1\n          ? min === 1\n            ? '/[^/]+'\n            : '(?:/[^/]+)?'\n          : min === max\n            ? `(?:/[^/]+){${min}}`\n            : `(?:/[^/]+){${min},${max}}`)\n    }\n    min = 0\n    max = 0\n    any = false\n  }\n  function finalise (): string {\n    flatten(true)\n    return (opt ? '^/$|^' : '^') + parts.reduce((acc, seg) => seg + acc, '$')\n  }\n  for (const part of spec.split('/').slice(1).reverse()) {\n    switch (part) {\n      case '+':\n        min++\n        max++\n        break\n      case '++':\n        max++\n        break\n      case '*':\n        min++\n        any = true\n        break\n      case '**':\n        any = true\n        break\n      default:\n        flatten()\n        opt = false\n        if (part.match(/:.+/) !== null) {\n          props.push(part.slice(1))\n          parts.push('/([^/]+)')\n        } else {\n          parts.push(`/${part.replace(/([.$])/g, '\\\\$1')}`)\n        }\n    }\n  }\n  return {\n    regex: finalise(),\n    props: props.reverse()\n  }\n}\n"},"src/policy.ts":{"language":"typescript","mutants":[{"id":"92","mutatorName":"PrecomputedMutator","replacement":"this.rules = rules","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › clones itself correctly\n\n    TypeError: this.rules is not a function\n\n      62 |   /** Add rules to a policy. */\n      63 |   push(...rules: Rule[]): Policy {\n    > 64 |     stryMutAct_9fa48(\"92\") ? (this.rules = rules)(...rules) : (stryCov_9fa48(\"92\"), this.rules.push(...rules));\n         |                                                  ^\n      65 |     return this;\n      66 |   }\n      67 |\n\n      at Policy.push (src/policy.ts:64:50)\n      at Object.<anonymous> (test/policy.ts:124:14)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.833 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":20,"line":18},"start":{"column":5,"line":18}}},{"id":"93","mutatorName":"PrecomputedMutator","replacement":"this.rules.slice()","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":32},"start":{"column":24,"line":32}}},{"id":"94","mutatorName":"PrecomputedMutator","replacement":"rule.query(path, verb, ctx.func(path, verb, ctx))","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: ctx.func is not a function\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                                                                                                                                                                                                                                       ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:263)\n      at PolicyMap.query (src/policymap.ts:91:292)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'func')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                                                                                                                                                                                                                                       ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:263)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: ctx.func is not a function\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                                                                                                                                                                                                                                       ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:263)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'func')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                                                                                                                                                                                                                                       ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:263)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'func')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                                                                                                                                                                                                                                       ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:263)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.424 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":46,"line":33},"start":{"column":19,"line":33}}},{"id":"95","mutatorName":"PrecomputedMutator","replacement":"rule.query(path, verb, ctx.prop)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (2 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (6 ms)\n    ✕ answers queries correctly (4 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (2 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'prop')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                                                                                                                                                                           ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:203)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'prop')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                                                                                                                                                                           ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:203)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'prop')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                                                                                                                                                                           ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:203)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.29 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":46,"line":33},"start":{"column":19,"line":33}}},{"id":"96","mutatorName":"PrecomputedMutator","replacement":"rule.query(path, verb, ctx.method(path, verb))","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (10 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: ctx.method is not a function\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                                                                                                 ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:129)\n      at PolicyMap.query (src/policymap.ts:91:292)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'method')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                                                                                                 ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:129)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: ctx.method is not a function\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                                                                                                 ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:129)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'method')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                                                                                                 ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:129)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'method')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                                                                                                 ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:129)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.341 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":46,"line":33},"start":{"column":19,"line":33}}},{"id":"97","mutatorName":"PrecomputedMutator","replacement":"!rule.query","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (3 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (4 ms)\n\n    ✕ prioritises deny over allow (4 ms)\n\n    ✕ clones itself correctly (2 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    TypeError: (!rule.query) is not a function\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                         ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:57)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: (!rule.query) is not a function\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                         ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:57)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: (!rule.query) is not a function\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                         ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:57)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: (!rule.query) is not a function\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                         ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:57)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: (!rule.query) is not a function\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n         |                                                         ^\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:57)\n      at PolicyMap.query (src/policymap.ts:91:292)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.332 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":29,"line":33},"start":{"column":19,"line":33}}},{"id":"98","mutatorName":"PrecomputedMutator","replacement":"!path","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (2 ms)\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Rule.query (src/rule.ts:104:507)\n      at Policy.query (src/policy.ts:79:333)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Rule.query (src/rule.ts:104:507)\n      at Policy.query (src/policy.ts:79:333)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Rule.query (src/rule.ts:104:507)\n      at Policy.query (src/policy.ts:79:333)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Rule.query (src/rule.ts:104:507)\n      at Policy.query (src/policy.ts:79:333)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Rule.query (src/rule.ts:104:507)\n      at Policy.query (src/policy.ts:79:333)\n      at PolicyMap.query (src/policymap.ts:91:292)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.397 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":33},"start":{"column":30,"line":33}}},{"id":"99","mutatorName":"PrecomputedMutator","replacement":"path.toLowerCase()","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":33},"start":{"column":30,"line":33}}},{"id":"100","mutatorName":"PrecomputedMutator","replacement":"path + 'foo'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (2 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.429 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":33},"start":{"column":30,"line":33}}},{"id":"101","mutatorName":"PrecomputedMutator","replacement":"verb.toLowerCase()","status":"Survived","testsCompleted":1,"location":{"end":{"column":40,"line":33},"start":{"column":36,"line":33}}},{"id":"102","mutatorName":"PrecomputedMutator","replacement":"verb.slice(1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (5 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (3 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.449 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":33},"start":{"column":36,"line":33}}},{"id":"103","mutatorName":"PrecomputedMutator","replacement":"verb.length","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (6 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (2 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.514 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":33},"start":{"column":36,"line":33}}},{"id":"104","mutatorName":"PrecomputedMutator","replacement":"ctx + 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (2 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly (2 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (4 ms)\n    ✕ answers context-dependent queries correctly (4 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.402 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":33},"start":{"column":42,"line":33}}},{"id":"105","mutatorName":"PrecomputedMutator","replacement":"ctx ? true : false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (3 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (4 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.538 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":33},"start":{"column":42,"line":33}}},{"id":"106","mutatorName":"PrecomputedMutator","replacement":"ctx = 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (2 ms)\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.386 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":33},"start":{"column":42,"line":33}}},{"id":"107","mutatorName":"PrecomputedMutator","replacement":"res !== true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (4 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.365 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":24,"line":34},"start":{"column":11,"line":34}}},{"id":"108","mutatorName":"PrecomputedMutator","replacement":"!res","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (4 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (4 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.345 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":24,"line":34},"start":{"column":11,"line":34}}},{"id":"109","mutatorName":"PrecomputedMutator","replacement":"res === null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (4 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (3 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (5 ms)\n    ✓ matches context-dependent paths correctly (2 ms)\n    ✕ answers queries correctly (5 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.338 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":24,"line":34},"start":{"column":11,"line":34}}},{"id":"110","mutatorName":"PrecomputedMutator","replacement":"res > true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (4 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (12 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (3 ms)\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.352 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":37},"start":{"column":11,"line":37}}},{"id":"111","mutatorName":"PrecomputedMutator","replacement":"res <= true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'shallow'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:138:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.37 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":37},"start":{"column":11,"line":37}}},{"id":"112","mutatorName":"PrecomputedMutator","replacement":"res !== true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (22 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (2 ms)\n    ✕ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'shallow'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:138:5)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (2 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (4 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly (2 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.784 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":37},"start":{"column":11,"line":37}}},{"id":"113","mutatorName":"PrecomputedMutator","replacement":"this.rules.slice()","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":48},"start":{"column":24,"line":48}}},{"id":"114","mutatorName":"PrecomputedMutator","replacement":"this.rules.reverse()","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":48},"start":{"column":24,"line":48}}},{"id":"115","mutatorName":"PrecomputedMutator","replacement":"this.rules.filter(() => true)","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":48},"start":{"column":24,"line":48}}},{"id":"116","mutatorName":"PrecomputedMutator","replacement":"!rule.matches(path, ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (4 ms)\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (6 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.368 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":49},"start":{"column":11,"line":49}}},{"id":"117","mutatorName":"PrecomputedMutator","replacement":"rule.notMatches(path, ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: rule.notMatches is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                        ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:344)\n      at PolicyMap.matches (src/policymap.ts:100:442)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    TypeError: rule.notMatches is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                        ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:344)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: rule.notMatches is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                        ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:344)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: rule.notMatches is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                        ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:344)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: rule.notMatches is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                        ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:344)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: rule.notMatches is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0)\n : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                        ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:344)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: rule.notMatches is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                        ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:344)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.335 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":49},"start":{"column":11,"line":49}}},{"id":"118","mutatorName":"PrecomputedMutator","replacement":"rule.doesNotMatch(path, ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (6 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: rule.doesNotMatch is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                               ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:287)\n      at PolicyMap.matches (src/policymap.ts:100:442)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    TypeError: rule.doesNotMatch is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                               ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:287)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: rule.doesNotMatch is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                               ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:287)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: rule.doesNotMatch is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                               ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:287)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: rule.doesNotMatch is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                               ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:287)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: rule.doesNotMatch is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                              \n                                                                                                                                                                                                                                                 ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:287)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: rule.doesNotMatch is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                               ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:287)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.319 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":49},"start":{"column":11,"line":49}}},{"id":"119","mutatorName":"PrecomputedMutator","replacement":"rule.matches(path.slice(1), ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (10 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.34 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":49},"start":{"column":11,"line":49}}},{"id":"120","mutatorName":"PrecomputedMutator","replacement":"rule.matches(path.splice(0, 0, \"foo\"), ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    TypeError: path.splice is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                       ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:167)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: path.splice is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                       ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:167)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: path.splice is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                       ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:167)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: path.splice is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                       ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:167)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: path.splice is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                       ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:167)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: path.splice is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (con\nst rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                       ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:167)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: path.splice is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                       ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:167)\n      at PolicyMap.matches (src/policymap.ts:100:442)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.698 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":49},"start":{"column":11,"line":49}}},{"id":"121","mutatorName":"PrecomputedMutator","replacement":"rule.matches(path, ctx.unshift())","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: ctx.unshift is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                              ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:110)\n      at PolicyMap.matches (src/policymap.ts:100:442)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (2 ms)\n\n  ● policy › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'unshift')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                              ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:110)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'unshift')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                              ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:110)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'unshift')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                              ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:110)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: ctx.unshift is not a function\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                              ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:110)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'unshift')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                              ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:110)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read pr\noperties of undefined (reading 'unshift')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                              ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:110)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        3.024 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":49},"start":{"column":11,"line":49}}},{"id":"122","mutatorName":"PrecomputedMutator","replacement":"rule.allow","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (3 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.488 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":49},"start":{"column":11,"line":49}}},{"id":"123","mutatorName":"PrecomputedMutator","replacement":"path.substring(0)","status":"Survived","testsCompleted":1,"location":{"end":{"column":28,"line":49},"start":{"column":24,"line":49}}},{"id":"124","mutatorName":"PrecomputedMutator","replacement":"path.split(\"/\").length - 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (4 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Policy.matches (src/policy.ts:95:491)\n      at PolicyMap.matches (src/policymap.ts:100:442)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Policy.matches (src/policy.ts:95:491)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Policy.matches (src/policy.ts:95:491)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Policy.matches (src/policy.ts:95:491)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Policy.matches (src/policy.ts:95:491)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Policy.matches (src/policy.ts:95:491)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Policy.matches (src/policy.ts:95:491)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.423 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":49},"start":{"column":24,"line":49}}},{"id":"125","mutatorName":"PrecomputedMutator","replacement":"path.substr(1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.369 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":49},"start":{"column":24,"line":49}}},{"id":"126","mutatorName":"PrecomputedMutator","replacement":"n, ctx","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    ReferenceError: n is not defined\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:752)\n      at PolicyMap.matches (src/policymap.ts:100:442)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    ReferenceError: n is not defined\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:752)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    ReferenceError: n is not defined\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:752)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    ReferenceError: n is not defined\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:752)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    ReferenceError: n is not defined\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                               \n                                                                                                                                                                                                                                                                                                                                 ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:752)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    ReferenceError: n is not defined\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:752)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    ReferenceError: n is not defined\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:752)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.428 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":49},"start":{"column":30,"line":49}}},{"id":"127","mutatorName":"PrecomputedMutator","replacement":"undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (6 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (8 ms)\n    ✓ answers queries correctly (5 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        2.44 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":49},"start":{"column":30,"line":49}}},{"id":"128","mutatorName":"PrecomputedMutator","replacement":"this.rules.slice","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (2 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (6 ms)\n    ✓ answers queries correctly (2 ms)\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (2 ms)\n\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'deep'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:147:5)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.392 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":43,"line":61},"start":{"column":29,"line":61}}},{"id":"129","mutatorName":"PrecomputedMutator","replacement":"this.rules.filter","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (4 ms)\n\n\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'deep'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:147:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.334 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":43,"line":61},"start":{"column":29,"line":61}}},{"id":"130","mutatorName":"PrecomputedMutator","replacement":"this.rules.reduce","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (2 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (2 ms)\n\n\n  ● policy › clones itself correctly\n\n    TypeError: Spread syntax requires ...iterable[Symbol.iterator] to be a function\n\n      104 |     * @param deep Deep copy; clone underlying rules as well. */\n      105 |   clone(name: string = this.name, deep: boolean = true): Policy {\n    > 106 |     return deep ? new Policy(name, ...(stryMutAct_9fa48(\"130\") ? this.rules.reduce(rule => rule.clone()) : stryMutAct_9fa48(\"129\") ? this.rules.filter(rule => rule.clone()) : stryMutAct_9fa48(\"128\") ? this.rules.slice(rule => rule.clone()) : (stryCov_9fa48(\"128\", \"129\", \"130\"), this.rules.map(stryMutAct_9fa48(\"133\") ? rule => rule.clone(rule.x * 2) : stryMutAct_9fa48(\"132\") ? rule => rule.clone(rule.name + ' clone') : stryMutAct_9fa48(\"131\") ? rule => rule.clone(false) : (stryCov_9fa48(\"131\", \"132\", \"133\"), rule => stryMutAct_9fa48(\"134\") ? (!rule.clone)() : (stryCov_9fa48(\"134\"), rule.clone())))))) : new Policy(name, ...this.rules);\n          |                   ^\n      107 |   }\n      108 |\n      109 |   /** Static constructor function; returns a new Policy. */\n\n      at Policy.clone (src/policy.ts:106:19)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.279 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":43,"line":61},"start":{"column":29,"line":61}}},{"id":"131","mutatorName":"PrecomputedMutator","replacement":"rule => rule.clone(false)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › clones itself correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n         |                                                                                                                                                                                                                                                               ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n\n      at new Matcher (src/matcher.ts:58:255)\n      at new Rule (src/rule.ts:64:51)\n      at Rule.clone (src/rule.ts:136:18)\n      at src/policy.ts:106:462\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:291)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.258 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":66,"line":61},"start":{"column":44,"line":61}}},{"id":"132","mutatorName":"PrecomputedMutator","replacement":"rule => rule.clone(rule.name + ' clone')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (4 ms)\n    ✓ answers queries correctly (7 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● policy › clones itself correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Rule.clone (src/rule.ts:136:18)\n      at src/policy.ts:106:393\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:291)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.338 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":66,"line":61},"start":{"column":44,"line":61}}},{"id":"133","mutatorName":"PrecomputedMutator","replacement":"rule => rule.clone(rule.x * 2)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (7 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › clones itself correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"2\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) == null : stryMutAct_9fa48(\"1\") ? !spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\", \"2\"), spec.match(stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-.]*[^a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"4\") ? /^[a-zA-Z0-9_/:~.$+*-]*[a-zA-Z0-9_/:~.$+*-.]$/ : stryMutAct_9fa48(\"3\") ? /^[a-zA-Z0-9_/:~.$+*-.]*$/ : (stryCov_9fa48(\"3\", \"4\", \"5\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)) === null)) {\n         |                                                                                                                                                                                                                                                               ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if (stryMutAct_9fa48(\"7\") ? spec.charAt(0) !== '/' : stryMutAct_9fa48(\"6\") ? /^\\\\/.test(spec) !== null : (stryCov_9fa48(\"6\", \"7\"), (stryMutAct_9fa48(\"10\") ? spec.find(/^\\//) : stryMutAct_9fa48(\"9\") ? spec.includes(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : (stryCov_9fa48(\"8\", \"9\", \"10\"), spec.match(/^\\//))) === null)) {\n\n      at new Matcher (src/matcher.ts:58:255)\n      at new Rule (src/rule.ts:64:51)\n      at Rule.clone (src/rule.ts:136:18)\n      at src/policy.ts:106:334\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:291)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.331 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":66,"line":61},"start":{"column":44,"line":61}}},{"id":"134","mutatorName":"PrecomputedMutator","replacement":"!rule.clone","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › clones itself correctly\n\n    TypeError: (!rule.clone) is not a function\n\n      104 |     * @param deep Deep copy; clone underlying rules as well. */\n      105 |   clone(name: string = this.name, deep: boolean = true): Policy {\n    > 106 |     return deep ? new Policy(name, ...(stryMutAct_9fa48(\"130\") ? this.rules.reduce(rule => rule.clone()) : stryMutAct_9fa48(\"129\") ? this.rules.filter(rule => rule.clone()) : stryMutAct_9fa48(\"128\") ? this.rules.slice(rule => rule.clone()) : (stryCov_9fa48(\"128\", \"129\", \"130\"), this.rules.map(stryMutAct_9fa48(\"133\") ? rule => rule.clone(rule.x * 2) : stryMutAct_9fa48(\"132\") ? rule => rule.clone(rule.name + ' clone') : stryMutAct_9fa48(\"131\") ? rule => rule.clone(false) : (stryCov_9fa48(\"131\", \"132\", \"133\"), rule => stryMutAct_9fa48(\"134\") ? (!rule.clone)() : (stryCov_9fa48(\"134\"), rule.clone())))))) : new Policy(name, ...this.rules);\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^\n      107 |   }\n      108 |\n      109 |   /** Static constructor function; returns a new Policy. */\n\n      at src/policy.ts:106:561\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:291)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.294 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":64,"line":61},"start":{"column":54,"line":61}}}],"source":"import { Rule } from './rule'\nimport { Queryable, QueryContext } from './queryable'\n\n/** Access-control policy. */\nexport class Policy implements Queryable {\n  /** Policy name. */\n  readonly name: string\n  /** Rules comprising policy. */\n  readonly rules: Rule[]\n\n  constructor (name: string, ...rules: Rule[]) {\n    this.name = name\n    this.rules = rules\n  }\n\n  /** Add rules to a policy. */\n  push (...rules: Rule[]): Policy {\n    this.rules.push(...rules)\n    return this\n  }\n\n  /** Check whether an action is allowed on a path.\n    * @param path Path to be acted on.\n    * @param verb Action to be performed.\n    * @param ctx Query context for resolving context-dependent paths.\n    * @returns Returns `true` if the action is explicitly allowed,\n    *          `false` if the action is explicitly denied, or\n    *          `null` if the combination of path and action\n    *          is not governed by this policy. */\n  query (path: string, verb: string, ctx?: QueryContext): boolean | null {\n    let allow = null\n    for (const rule of this.rules) {\n      const res = rule.query(path, verb, ctx)\n      if (res === false) {\n        return false\n      }\n      if (res === true) {\n        allow = true\n      }\n    }\n    return allow\n  }\n\n  /** Check whether a path is governed by this policy.\n    * @param path Path to be checked.\n    * @param ctx Query context for resolving context-dependent paths. */\n  matches (path: string, ctx?: QueryContext): boolean {\n    for (const rule of this.rules) {\n      if (rule.matches(path, ctx)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /** Create clone of a policy.\n    * @param name Replacement name for new policy.\n    * @param deep Deep copy; clone underlying rules as well. */\n  clone (name: string = this.name, deep: boolean = true): Policy {\n    return deep\n      ? new Policy(name, ...this.rules.map((rule) => rule.clone()))\n      : new Policy(name, ...this.rules)\n  }\n\n  /** Static constructor function; returns a new Policy. */\n  static for (name: string, ...rules: Rule[]): Policy {\n    return new Policy(name, ...rules)\n  }\n}\n"},"src/policymap.ts":{"language":"typescript","mutants":[{"id":"135","mutatorName":"PrecomputedMutator","replacement":"policy => [policy.name.toLowerCase(), policy]","status":"Survived","testsCompleted":1,"location":{"end":{"column":57,"line":7},"start":{"column":24,"line":7}}},{"id":"136","mutatorName":"PrecomputedMutator","replacement":"policy => [policy.name.split(' ').join(''), policy]","status":"Survived","testsCompleted":1,"location":{"end":{"column":57,"line":7},"start":{"column":24,"line":7}}},{"id":"137","mutatorName":"PrecomputedMutator","replacement":"policy => [policy.name.slice(1), policy]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (6 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (4 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.533 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":57,"line":7},"start":{"column":24,"line":7}}},{"id":"138","mutatorName":"PrecomputedMutator","replacement":"for (const policy of policies.entries()) {\n  this.set(policy.name, policy);\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (6 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (7 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.98 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":14},"start":{"column":5,"line":12}}},{"id":"139","mutatorName":"PrecomputedMutator","replacement":"for (const policy of policies.reverse()) {\n  this.set(policy.name, policy);\n}","status":"Survived","testsCompleted":1,"location":{"end":{"column":6,"line":14},"start":{"column":5,"line":12}}},{"id":"140","mutatorName":"PrecomputedMutator","replacement":"for (const policy of policies.slice(1)) {\n  this.set(policy.name, policy);\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths (12 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (6 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        3.952 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":14},"start":{"column":5,"line":12}}},{"id":"141","mutatorName":"PrecomputedMutator","replacement":"this.set(policy.name, null)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of null (reading 'matches')\n\n       98 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n       99 |     const policy = stryMutAct_9fa48(\"165\") ? this.has(name) : (stryCov_9fa48(\"165\"), this.get(stryMutAct_9fa48(\"167\") ? name.split(' ').join() : stryMutAct_9fa48(\"166\") ? name.toUpperCase() : (stryCov_9fa48(\"166\", \"167\"), name)));\n    > 100 |     return policy !== undefined ? stryMutAct_9fa48(\"172\") ? (policy.matches && otherPolicy.matches)(path, ctx) : stryMutAct_9fa48(\"171\") ? (!policy.matches)(path, ctx) : stryMutAct_9fa48(\"170\") ? policy.matches(path.split(\"\").reverse().join(\"\"), ctx) : stryMutAct_9fa48(\"169\") ? policy.matches(path + \"foo\", ctx) : stryMutAct_9fa48(\"168\") ? policy.matches(path.toUpperCase(), ctx) : (stryCov_9fa48(\"168\", \"169\", \"170\", \"171\", \"172\"), policy.matches(stryMutAct_9fa48(\"175\") ? path.indexOf(\"/\") : stryMutAct_9fa48(\"174\") ? path.length + 1 : stryMutAct_9fa48(\"173\") ? path.substring(1) : (stryCov_9fa48(\"173\", \"174\", \"175\"), path), stryMutAct_9fa48(\"178\") ? ctx ? \"foo\" : \"bar\" : stryMutAct_9fa48(\"177\") ? ctx && \"foo\" : stryMutAct_9fa48(\"176\") ? !ctx : (stryCov_9fa48(\"176\", \"177\", \"178\"), ctx))) : false;\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^\n      101 |   }\n      102 |\n      103 |   /** Static constructor function; returns a new PolicyMap. */\n\n      at PolicyMap.matches (src/policymap.ts:100:442)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of null (reading 'query')\n\n      89 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      90 |     const policy = this.get(stryMutAct_9fa48(\"152\") ? 'unknown' : stryMutAct_9fa48(\"151\") ? '' : stryMutAct_9fa48(\"150\") ? null : (stryCov_9fa48(\"150\", \"151\", \"152\"), name));\n    > 91 |     return policy !== undefined ? stryMutAct_9fa48(\"155\") ? policy.query(path.substring(0, 1), verb, ctx) : stryMutAct_9fa48(\"154\") ? policy.query(path.toUpperCase(), verb, ctx) : stryMutAct_9fa48(\"153\") ? policy.query(path.slice(1), verb, ctx) : (stryCov_9fa48(\"153\", \"154\", \"155\"), policy.query(stryMutAct_9fa48(\"158\") ? path.toLowerCase() : stryMutAct_9fa48(\"157\") ? path.length : stryMutAct_9fa48(\"156\") ? path[0] : (stryCov_9fa48(\"156\", \"157\", \"158\"), path), stryMutAct_9fa48(\"161\") ? verb - 1 : stryMutAct_9fa48(\"160\") ? verb + 1 : stryMutAct_9fa48(\"159\") ? not(verb) : (stryCov_9fa48(\"159\", \"160\", \"161\"), verb), stryMutAct_9fa48(\"164\") ? ctx.slice(1) : stryMutAct_9fa48(\"163\") ? ctx.filter(x => x > 0) : stryMutAct_9fa48(\"162\") ? ctx.map(x => x + 1) : (stryCov_9fa48(\"162\", \"163\", \"164\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                                    ^\n      92 |   }\n      93 |\n      94 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:91:292)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.817 s, estimated 4 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":36,"line":13},"start":{"column":7,"line":13}}},{"id":"142","mutatorName":"PrecomputedMutator","replacement":"this.set(policy.name, undefined)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.539 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":36,"line":13},"start":{"column":7,"line":13}}},{"id":"143","mutatorName":"PrecomputedMutator","replacement":"this.set(policy.name, Policy.prototype)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (3 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (2 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator))\n\n      92 |     * @param ctx Query context for resolving context-dependent paths. */\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 94 |     for (const rule of stryMutAct_9fa48(\"115\") ? this.rules.filter(() => true) : stryMutAct_9fa48(\"114\") ? this.rules.reverse() : stryMutAct_9fa48(\"113\") ? this.rules.slice() : (stryCov_9fa48(\"113\", \"114\", \"115\"), this.rules)) {\n         |                                                                                                                                                                                                                            ^\n      95 |       if (stryMutAct_9fa48(\"122\") ? rule.allow(path, ctx) : stryMutAct_9fa48(\"121\") ? rule.matches(path, ctx.unshift()) : stryMutAct_9fa48(\"120\") ? rule.matches(path.splice(0, 0, \"foo\"), ctx) : stryMutAct_9fa48(\"119\") ? rule.matches(path.slice(1), ctx) : stryMutAct_9fa48(\"118\") ? rule.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"117\") ? rule.notMatches(path, ctx) : stryMutAct_9fa48(\"116\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\"), rule.matches(stryMutAct_9fa48(\"125\") ? path.substr(1) : stryMutAct_9fa48(\"124\") ? path.split(\"/\").length - 1 : stryMutAct_9fa48(\"123\") ? path.substring(0) : (stryCov_9fa48(\"123\", \"124\", \"125\"), path), stryMutAct_9fa48(\"127\") ? undefined : stryMutAct_9fa48(\"126\") ? (n, ctx) : (stryCov_9fa48(\"126\", \"127\"), ctx)))) {\n      96 |         return true;\n      97 |       }\n\n      at Object.matches (src/policy.ts:94:220)\n      at PolicyMap.matches (src/policymap.ts:100:442)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator))\n\n      76 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n      77 |     let allow = null;\n    > 78 |     for (const rule of stryMutAct_9fa48(\"93\") ? this.rules.slice() : (stryCov_9fa48(\"93\"), this.rules)) {\n         |                                                                                                 ^\n      79 |       const res = stryMutAct_9fa48(\"97\") ? (!rule.query)(path, verb, ctx) : stryMutAct_9fa48(\"96\") ? rule.query(path, verb, ctx.method(path, verb)) : stryMutAct_9fa48(\"95\") ? rule.query(path, verb, ctx.prop) : stryMutAct_9fa48(\"94\") ? rule.query(path, verb, ctx.func(path, verb, ctx)) : (stryCov_9fa48(\"94\", \"95\", \"96\", \"97\"), rule.query(stryMutAct_9fa48(\"100\") ? path + 'foo' : stryMutAct_9fa48(\"99\") ? path.toLowerCase() : stryMutAct_9fa48(\"98\") ? !path : (stryCov_9fa48(\"98\", \"99\", \"100\"), path), stryMutAct_9fa48(\"103\") ? verb.length : stryMutAct_9fa48(\"102\") ? verb.slice(1) : stryMutAct_9fa48(\"101\") ? verb.toLowerCase() : (stryCov_9fa48(\"101\", \"102\", \"103\"), verb), stryMutAct_9fa48(\"106\") ? ctx = 1 : stryMutAct_9fa48(\"105\") ? ctx ? true : false : stryMutAct_9fa48(\"104\") ? ctx + 1 : (stryCov_9fa48(\"104\", \"105\", \"106\"), ctx)));\n      80 |       if (stryMutAct_9fa48(\"109\") ? res === null : stryMutAct_9fa48(\"108\") ? !res : stryMutAct_9fa48(\"107\") ? res !== true : (stryCov_9fa48(\"107\", \"108\", \"109\"), res === false)) {\n      81 |         return false;\n\n      at Object.query (src/policy.ts:78:97)\n      at PolicyMap.query (src/policymap.ts:91:292)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.45 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":36,"line":13},"start":{"column":7,"line":13}}},{"id":"144","mutatorName":"PrecomputedMutator","replacement":"policy.name.length","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (5 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.475 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":27,"line":13},"start":{"column":16,"line":13}}},{"id":"145","mutatorName":"PrecomputedMutator","replacement":"policy.name.toUpperCase()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (6 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (3 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (2 ms)\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (9 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.846 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":27,"line":13},"start":{"column":16,"line":13}}},{"id":"146","mutatorName":"PrecomputedMutator","replacement":"policy.name + 'extra-text'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (5 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.722 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":27,"line":13},"start":{"column":16,"line":13}}},{"id":"147","mutatorName":"PrecomputedMutator","replacement":"null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of null (reading 'matches')\n\n       98 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n       99 |     const policy = stryMutAct_9fa48(\"165\") ? this.has(name) : (stryCov_9fa48(\"165\"), this.get(stryMutAct_9fa48(\"167\") ? name.split(' ').join() : stryMutAct_9fa48(\"166\") ? name.toUpperCase() : (stryCov_9fa48(\"166\", \"167\"), name)));\n    > 100 |     return policy !== undefined ? stryMutAct_9fa48(\"172\") ? (policy.matches && otherPolicy.matches)(path, ctx) : stryMutAct_9fa48(\"171\") ? (!policy.matches)(path, ctx) : stryMutAct_9fa48(\"170\") ? policy.matches(path.split(\"\").reverse().join(\"\"), ctx) : stryMutAct_9fa48(\"169\") ? policy.matches(path + \"foo\", ctx) : stryMutAct_9fa48(\"168\") ? policy.matches(path.toUpperCase(), ctx) : (stryCov_9fa48(\"168\", \"169\", \"170\", \"171\", \"172\"), policy.matches(stryMutAct_9fa48(\"175\") ? path.indexOf(\"/\") : stryMutAct_9fa48(\"174\") ? path.length + 1 : stryMutAct_9fa48(\"173\") ? path.substring(1) : (stryCov_9fa48(\"173\", \"174\", \"175\"), path), stryMutAct_9fa48(\"178\") ? ctx ? \"foo\" : \"bar\" : stryMutAct_9fa48(\"177\") ? ctx && \"foo\" : stryMutAct_9fa48(\"176\") ? !ctx : (stryCov_9fa48(\"176\", \"177\", \"178\"), ctx))) : false;\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^\n      101 |   }\n      102 |\n      103 |   /** Static constructor function; returns a new PolicyMap. */\n\n      at PolicyMap.matches (src/policymap.ts:100:442)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of null (reading 'query')\n\n      89 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      90 |     const policy = this.get(stryMutAct_9fa48(\"152\") ? 'unknown' : stryMutAct_9fa48(\"151\") ? '' : stryMutAct_9fa48(\"150\") ? null : (stryCov_9fa48(\"150\", \"151\", \"152\"), name));\n    > 91 |     return policy !== undefined ? stryMutAct_9fa48(\"155\") ? policy.query(path.substring(0, 1), verb, ctx) : stryMutAct_9fa48(\"154\") ? policy.query(path.toUpperCase(), verb, ctx) : stryMutAct_9fa48(\"153\") ? policy.query(path.slice(1), verb, ctx) : (stryCov_9fa48(\"153\", \"154\", \"155\"), policy.query(stryMutAct_9fa48(\"158\") ? path.toLowerCase() : stryMutAct_9fa48(\"157\") ? path.length : stryMutAct_9fa48(\"156\") ? path[0] : (stryCov_9fa48(\"156\", \"157\", \"158\"), path), stryMutAct_9fa48(\"161\") ? verb - 1 : stryMutAct_9fa48(\"160\") ? verb + 1 : stryMutAct_9fa48(\"159\") ? not(verb) : (stryCov_9fa48(\"159\", \"160\", \"161\"), verb), stryMutAct_9fa48(\"164\") ? ctx.slice(1) : stryMutAct_9fa48(\"163\") ? ctx.filter(x => x > 0) : stryMutAct_9fa48(\"162\") ? ctx.map(x => x + 1) : (stryCov_9fa48(\"162\", \"163\", \"164\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                                    ^\n      92 |   }\n      93 |\n      94 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:91:292)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.527 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":13},"start":{"column":29,"line":13}}},{"id":"148","mutatorName":"PrecomputedMutator","replacement":"undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (2 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.699 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":13},"start":{"column":29,"line":13}}},{"id":"149","mutatorName":"PrecomputedMutator","replacement":"new Policy()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (4 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.389 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":13},"start":{"column":29,"line":13}}},{"id":"150","mutatorName":"PrecomputedMutator","replacement":"null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (3 ms)\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (4 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.367 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":28},"start":{"column":29,"line":28}}},{"id":"151","mutatorName":"PrecomputedMutator","replacement":"''","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (9 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (4 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (3 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (4 ms)\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.458 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":28},"start":{"column":29,"line":28}}},{"id":"152","mutatorName":"PrecomputedMutator","replacement":"'unknown'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (5 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (4 ms)\n    ✕ answers queries correctly (3 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (9 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        3.05 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":28},"start":{"column":29,"line":28}}},{"id":"153","mutatorName":"PrecomputedMutator","replacement":"policy.query(path.slice(1), verb, ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (6 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (5 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.663 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":30},"start":{"column":9,"line":30}}},{"id":"154","mutatorName":"PrecomputedMutator","replacement":"policy.query(path.toUpperCase(), verb, ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.418 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":30},"start":{"column":9,"line":30}}},{"id":"155","mutatorName":"PrecomputedMutator","replacement":"policy.query(path.substring(0, 1), verb, ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (16 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.598 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":30},"start":{"column":9,"line":30}}},{"id":"156","mutatorName":"PrecomputedMutator","replacement":"path[0]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (7 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.686 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":26,"line":30},"start":{"column":22,"line":30}}},{"id":"157","mutatorName":"PrecomputedMutator","replacement":"path.length","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (2 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (17 ms)\n\n\n  ● policymap › answers queries correctly\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Rule.query (src/rule.ts:104:507)\n      at Policy.query (src/policy.ts:79:333)\n      at PolicyMap.query (src/policymap.ts:91:292)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        3.281 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":26,"line":30},"start":{"column":22,"line":30}}},{"id":"158","mutatorName":"PrecomputedMutator","replacement":"path.toLowerCase()","status":"Survived","testsCompleted":1,"location":{"end":{"column":26,"line":30},"start":{"column":22,"line":30}}},{"id":"159","mutatorName":"PrecomputedMutator","replacement":"not(verb)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    ReferenceError: not is not defined\n\n      89 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      90 |     const policy = this.get(stryMutAct_9fa48(\"152\") ? 'unknown' : stryMutAct_9fa48(\"151\") ? '' : stryMutAct_9fa48(\"150\") ? null : (stryCov_9fa48(\"150\", \"151\", \"152\"), name));\n    > 91 |     return policy !== undefined ? stryMutAct_9fa48(\"155\") ? policy.query(path.substring(0, 1), verb, ctx) : stryMutAct_9fa48(\"154\") ? policy.query(path.toUpperCase(), verb, ctx) : stryMutAct_9fa48(\"153\") ? policy.query(path.slice(1), verb, ctx) : (stryCov_9fa48(\"153\", \"154\", \"155\"), policy.query(stryMutAct_9fa48(\"158\") ? path.toLowerCase() : stryMutAct_9fa48(\"157\") ? path.length : stryMutAct_9fa48(\"156\") ? path[0] : (stryCov_9fa48(\"156\", \"157\", \"158\"), path), stryMutAct_9fa48(\"161\") ? verb - 1 : stryMutAct_9fa48(\"160\") ? verb + 1 : stryMutAct_9fa48(\"159\") ? not(verb) : (stryCov_9fa48(\"159\", \"160\", \"161\"), verb), stryMutAct_9fa48(\"164\") ? ctx.slice(1) : stryMutAct_9fa48(\"163\") ? ctx.filter(x => x > 0) : stryMutAct_9fa48(\"162\") ? ctx.map(x => x + 1) : (stryCov_9fa48(\"162\", \"163\", \"164\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      92 |   }\n      93 |\n      94 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:91:539)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.632 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":30},"start":{"column":28,"line":30}}},{"id":"160","mutatorName":"PrecomputedMutator","replacement":"verb + 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (5 ms)\n\n    ✕ answers queries correctly (4 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.391 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":30},"start":{"column":28,"line":30}}},{"id":"161","mutatorName":"PrecomputedMutator","replacement":"verb - 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (5 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (3 ms)\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.714 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":30},"start":{"column":28,"line":30}}},{"id":"162","mutatorName":"PrecomputedMutator","replacement":"ctx.map(x => x + 1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (5 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: ctx.map is not a function\n\n      89 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      90 |     const policy = this.get(stryMutAct_9fa48(\"152\") ? 'unknown' : stryMutAct_9fa48(\"151\") ? '' : stryMutAct_9fa48(\"150\") ? null : (stryCov_9fa48(\"150\", \"151\", \"152\"), name));\n    > 91 |     return policy !== undefined ? stryMutAct_9fa48(\"155\") ? policy.query(path.substring(0, 1), verb, ctx) : stryMutAct_9fa48(\"154\") ? policy.query(path.toUpperCase(), verb, ctx) : stryMutAct_9fa48(\"153\") ? policy.query(path.slice(1), verb, ctx) : (stryCov_9fa48(\"153\", \"154\", \"155\"), policy.query(stryMutAct_9fa48(\"158\") ? path.toLowerCase() : stryMutAct_9fa48(\"157\") ? path.length : stryMutAct_9fa48(\"156\") ? path[0] : (stryCov_9fa48(\"156\", \"157\", \"158\"), path), stryMutAct_9fa48(\"161\") ? verb - 1 : stryMutAct_9fa48(\"160\") ? verb + 1 : stryMutAct_9fa48(\"159\") ? not(verb) : (stryCov_9fa48(\"159\", \"160\", \"161\"), verb), stryMutAct_9fa48(\"164\") ? ctx.slice(1) : stryMutAct_9fa48(\"163\") ? ctx.filter(x => x > 0) : stryMutAct_9fa48(\"162\") ? ctx.map(x => x + 1) : (stryCov_9fa48(\"162\", \"163\", \"164\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^\n      92 |   }\n      93 |\n      94 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:91:743)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.514 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":37,"line":30},"start":{"column":34,"line":30}}},{"id":"163","mutatorName":"PrecomputedMutator","replacement":"ctx.filter(x => x > 0)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (7 ms)\n    ✓ matches context-dependent paths correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    TypeError: ctx.filter is not a function\n\n      89 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      90 |     const policy = this.get(stryMutAct_9fa48(\"152\") ? 'unknown' : stryMutAct_9fa48(\"151\") ? '' : stryMutAct_9fa48(\"150\") ? null : (stryCov_9fa48(\"150\", \"151\", \"152\"), name));\n    > 91 |     return policy !== undefined ? stryMutAct_9fa48(\"155\") ? policy.query(path.substring(0, 1), verb, ctx) : stryMutAct_9fa48(\"154\") ? policy.query(path.toUpperCase(), verb, ctx) : stryMutAct_9fa48(\"153\") ? policy.query(path.slice(1), verb, ctx) : (stryCov_9fa48(\"153\", \"154\", \"155\"), policy.query(stryMutAct_9fa48(\"158\") ? path.toLowerCase() : stryMutAct_9fa48(\"157\") ? path.length : stryMutAct_9fa48(\"156\") ? path[0] : (stryCov_9fa48(\"156\", \"157\", \"158\"), path), stryMutAct_9fa48(\"161\") ? verb - 1 : stryMutAct_9fa48(\"160\") ? verb + 1 : stryMutAct_9fa48(\"159\") ? not(verb) : (stryCov_9fa48(\"159\", \"160\", \"161\"), verb), stryMutAct_9fa48(\"164\") ? ctx.slice(1) : stryMutAct_9fa48(\"163\") ? ctx.filter(x => x > 0) : stryMutAct_9fa48(\"162\") ? ctx.map(x => x + 1) : (stryCov_9fa48(\"162\", \"163\", \"164\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^\n      92 |   }\n      93 |\n      94 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:91:692)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.873 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":37,"line":30},"start":{"column":34,"line":30}}},{"id":"164","mutatorName":"PrecomputedMutator","replacement":"ctx.slice(1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (6 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: ctx.slice is not a function\n\n      89 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      90 |     const policy = this.get(stryMutAct_9fa48(\"152\") ? 'unknown' : stryMutAct_9fa48(\"151\") ? '' : stryMutAct_9fa48(\"150\") ? null : (stryCov_9fa48(\"150\", \"151\", \"152\"), name));\n    > 91 |     return policy !== undefined ? stryMutAct_9fa48(\"155\") ? policy.query(path.substring(0, 1), verb, ctx) : stryMutAct_9fa48(\"154\") ? policy.query(path.toUpperCase(), verb, ctx) : stryMutAct_9fa48(\"153\") ? policy.query(path.slice(1), verb, ctx) : (stryCov_9fa48(\"153\", \"154\", \"155\"), policy.query(stryMutAct_9fa48(\"158\") ? path.toLowerCase() : stryMutAct_9fa48(\"157\") ? path.length : stryMutAct_9fa48(\"156\") ? path[0] : (stryCov_9fa48(\"156\", \"157\", \"158\"), path), stryMutAct_9fa48(\"161\") ? verb - 1 : stryMutAct_9fa48(\"160\") ? verb + 1 : stryMutAct_9fa48(\"159\") ? not(verb) : (stryCov_9fa48(\"159\", \"160\", \"161\"), verb), stryMutAct_9fa48(\"164\") ? ctx.slice(1) : stryMutAct_9fa48(\"163\") ? ctx.filter(x => x > 0) : stryMutAct_9fa48(\"162\") ? ctx.map(x => x + 1) : (stryCov_9fa48(\"162\", \"163\", \"164\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      92 |   }\n      93 |\n      94 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:91:651)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.539 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":37,"line":30},"start":{"column":34,"line":30}}},{"id":"165","mutatorName":"PrecomputedMutator","replacement":"this.has","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (11 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: policy.matches is not a function\n\n       98 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n       99 |     const policy = stryMutAct_9fa48(\"165\") ? this.has(name) : (stryCov_9fa48(\"165\"), this.get(stryMutAct_9fa48(\"167\") ? name.split(' ').join() : stryMutAct_9fa48(\"166\") ? name.toUpperCase() : (stryCov_9fa48(\"166\", \"167\"), name)));\n    > 100 |     return policy !== undefined ? stryMutAct_9fa48(\"172\") ? (policy.matches && otherPolicy.matches)(path, ctx) : stryMutAct_9fa48(\"171\") ? (!policy.matches)(path, ctx) : stryMutAct_9fa48(\"170\") ? policy.matches(path.split(\"\").reverse().join(\"\"), ctx) : stryMutAct_9fa48(\"169\") ? policy.matches(path + \"foo\", ctx) : stryMutAct_9fa48(\"168\") ? policy.matches(path.toUpperCase(), ctx) : (stryCov_9fa48(\"168\", \"169\", \"170\", \"171\", \"172\"), policy.matches(stryMutAct_9fa48(\"175\") ? path.indexOf(\"/\") : stryMutAct_9fa48(\"174\") ? path.length + 1 : stryMutAct_9fa48(\"173\") ? path.substring(1) : (stryCov_9fa48(\"173\", \"174\", \"175\"), path), stryMutAct_9fa48(\"178\") ? ctx ? \"foo\" : \"bar\" : stryMutAct_9fa48(\"177\") ? ctx && \"foo\" : stryMutAct_9fa48(\"176\") ? !ctx : (stryCov_9fa48(\"176\", \"177\", \"178\"), ctx))) : false;\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^\n      101 |   }\n      102 |\n      103 |   /** Static constructor function; returns a new PolicyMap. */\n\n      at PolicyMap.matches (src/policymap.ts:100:442)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.482 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":39},"start":{"column":20,"line":39}}},{"id":"166","mutatorName":"PrecomputedMutator","replacement":"name.toUpperCase()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (5 ms)\n    ✓ answers queries correctly (3 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.417 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":39},"start":{"column":29,"line":39}}},{"id":"167","mutatorName":"PrecomputedMutator","replacement":"name.split(' ').join()","status":"Survived","testsCompleted":1,"location":{"end":{"column":33,"line":39},"start":{"column":29,"line":39}}},{"id":"168","mutatorName":"PrecomputedMutator","replacement":"policy.matches(path.toUpperCase(), ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.78 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":41},"start":{"column":9,"line":41}}},{"id":"169","mutatorName":"PrecomputedMutator","replacement":"policy.matches(path + \"foo\", ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (8 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.337 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":41},"start":{"column":9,"line":41}}},{"id":"170","mutatorName":"PrecomputedMutator","replacement":"policy.matches(path.split(\"\").reverse().join(\"\"), ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✓ answers queries correctly (3 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (5 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.416 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":41},"start":{"column":9,"line":41}}},{"id":"171","mutatorName":"PrecomputedMutator","replacement":"!policy.matches","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: (!policy.matches) is not a function\n\n       98 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n       99 |     const policy = stryMutAct_9fa48(\"165\") ? this.has(name) : (stryCov_9fa48(\"165\"), this.get(stryMutAct_9fa48(\"167\") ? name.split(' ').join() : stryMutAct_9fa48(\"166\") ? name.toUpperCase() : (stryCov_9fa48(\"166\", \"167\"), name)));\n    > 100 |     return policy !== undefined ? stryMutAct_9fa48(\"172\") ? (policy.matches && otherPolicy.matches)(path, ctx) : stryMutAct_9fa48(\"171\") ? (!policy.matches)(path, ctx) : stryMutAct_9fa48(\"170\") ? policy.matches(path.split(\"\").reverse().join(\"\"), ctx) : stryMutAct_9fa48(\"169\") ? policy.matches(path + \"foo\", ctx) : stryMutAct_9fa48(\"168\") ? policy.matches(path.toUpperCase(), ctx) : (stryCov_9fa48(\"168\", \"169\", \"170\", \"171\", \"172\"), policy.matches(stryMutAct_9fa48(\"175\") ? path.indexOf(\"/\") : stryMutAct_9fa48(\"174\") ? path.length + 1 : stryMutAct_9fa48(\"173\") ? path.substring(1) : (stryCov_9fa48(\"173\", \"174\", \"175\"), path), stryMutAct_9fa48(\"178\") ? ctx ? \"foo\" : \"bar\" : stryMutAct_9fa48(\"177\") ? ctx && \"foo\" : stryMutAct_9fa48(\"176\") ? !ctx : (stryCov_9fa48(\"176\", \"177\", \"178\"), ctx))) : false;\n          |                                                                                                                                                             ^\n      101 |   }\n      102 |\n      103 |   /** Static constructor function; returns a new PolicyMap. */\n\n      at PolicyMap.matches (src/policymap.ts:100:157)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (3 ms)\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.538 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":41},"start":{"column":9,"line":41}}},{"id":"172","mutatorName":"PrecomputedMutator","replacement":"policy.matches && otherPolicy.matches","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✓ answers queries correctly (7 ms)\n\n  ● policymap › matches queries correctly\n\n    ReferenceError: otherPolicy is not defined\n\n       98 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n       99 |     const policy = stryMutAct_9fa48(\"165\") ? this.has(name) : (stryCov_9fa48(\"165\"), this.get(stryMutAct_9fa48(\"167\") ? name.split(' ').join() : stryMutAct_9fa48(\"166\") ? name.toUpperCase() : (stryCov_9fa48(\"166\", \"167\"), name)));\n    > 100 |     return policy !== undefined ? stryMutAct_9fa48(\"172\") ? (policy.matches && otherPolicy.matches)(path, ctx) : stryMutAct_9fa48(\"171\") ? (!policy.matches)(path, ctx) : stryMutAct_9fa48(\"170\") ? policy.matches(path.split(\"\").reverse().join(\"\"), ctx) : stryMutAct_9fa48(\"169\") ? policy.matches(path + \"foo\", ctx) : stryMutAct_9fa48(\"168\") ? policy.matches(path.toUpperCase(), ctx) : (stryCov_9fa48(\"168\", \"169\", \"170\", \"171\", \"172\"), policy.matches(stryMutAct_9fa48(\"175\") ? path.indexOf(\"/\") : stryMutAct_9fa48(\"174\") ? path.length + 1 : stryMutAct_9fa48(\"173\") ? path.substring(1) : (stryCov_9fa48(\"173\", \"174\", \"175\"), path), stryMutAct_9fa48(\"178\") ? ctx ? \"foo\" : \"bar\" : stryMutAct_9fa48(\"177\") ? ctx && \"foo\" : stryMutAct_9fa48(\"176\") ? !ctx : (stryCov_9fa48(\"176\", \"177\", \"178\"), ctx))) : false;\n          |                                                                                ^\n      101 |   }\n      102 |\n      103 |   /** Static constructor function; returns a new PolicyMap. */\n\n      at PolicyMap.matches (src/policymap.ts:100:80)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (2 ms)\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.905 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":41},"start":{"column":9,"line":41}}},{"id":"173","mutatorName":"PrecomputedMutator","replacement":"path.substring(1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (6 ms)\n\n    ✓ answers queries correctly (9 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.389 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":41},"start":{"column":24,"line":41}}},{"id":"174","mutatorName":"PrecomputedMutator","replacement":"path.length + 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Policy.matches (src/policy.ts:95:491)\n      at PolicyMap.matches (src/policymap.ts:100:442)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.295 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":41},"start":{"column":24,"line":41}}},{"id":"175","mutatorName":"PrecomputedMutator","replacement":"path.indexOf(\"/\")","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (14 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments (4 ms)\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (5 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (3 ms)\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: path.match is not a function\n\n      112 |     * @param ctx Query context for resolving context-dependent paths. */\n      113 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 114 |     const match = stryMutAct_9fa48(\"196\") ? path.search(this.regex) : (stryCov_9fa48(\"196\"), path.match(stryMutAct_9fa48(\"199\") ? this.regex.test : stryMutAct_9fa48(\"198\") ? this.regex.exec : stryMutAct_9fa48(\"197\") ? this.regex.source : (stryCov_9fa48(\"197\", \"198\", \"199\"), this.regex)));\n          |                                                                                                   ^\n      115 |     if (stryMutAct_9fa48(\"200\") ? match instanceof Matcher : (stryCov_9fa48(\"200\"), match === null)) {\n      116 |       return false;\n      117 |     }\n\n      at Rule.matches (src/rule.ts:114:99)\n      at Policy.matches (src/policy.ts:95:491)\n      at PolicyMap.matches (src/policymap.ts:100:442)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.413 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":41},"start":{"column":24,"line":41}}},{"id":"176","mutatorName":"PrecomputedMutator","replacement":"!ctx","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (10 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.308 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":41},"start":{"column":30,"line":41}}},{"id":"177","mutatorName":"PrecomputedMutator","replacement":"ctx && \"foo\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (6 ms)\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.332 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":41},"start":{"column":30,"line":41}}},{"id":"178","mutatorName":"PrecomputedMutator","replacement":"ctx ? \"foo\" : \"bar\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.32 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":41},"start":{"column":30,"line":41}}}],"source":"import { Policy } from './policy'\nimport { QueryableMap, QueryContext } from './queryable'\n\n/** Queryable collection of policy documents. */\nexport class PolicyMap extends Map<string, Policy> implements QueryableMap {\n  constructor (...policies: Policy[]) {\n    super(policies.map((policy) => [policy.name, policy]))\n  }\n\n  /** Add policies to colllection. */\n  push (...policies: Policy[]): this {\n    for (const policy of policies) {\n      this.set(policy.name, policy)\n    }\n    return this\n  }\n\n  /** Check whether an action is allowed on a path.\n    * @param name Policy to be queried.\n    * @param path Path to be acted on.\n    * @param verb Action to be performed.\n    * @param ctx Query context for resolving context-dependent paths.\n    * @returns Returns `true` if the action is explicitly allowed,\n    *          `false` if the action is explicitly denied, or\n    *          `null` if the combination of policy, path and\n    *          action is not governed by this collection. */\n  query (name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n    const policy = this.get(name)\n    return policy !== undefined\n      ? policy.query(path, verb, ctx)\n      : null\n  }\n\n  /** Check whether a path is governed by a policy in this collection.\n    * @param name Policy to be queried.\n    * @param path Path to be checked.\n    * @param ctx Query context for resolving context-dependent paths. */\n  matches (name: string, path: string, ctx?: QueryContext): boolean {\n    const policy = this.get(name)\n    return policy !== undefined\n      ? policy.matches(path, ctx)\n      : false\n  }\n\n  /** Static constructor function; returns a new PolicyMap. */\n  static for (...policies: Policy[]): PolicyMap {\n    return new PolicyMap(...policies)\n  }\n}\n"},"src/rule.ts":{"language":"typescript","mutants":[{"id":"179","mutatorName":"PrecomputedMutator","replacement":"verb in this.verbs","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (9 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (4 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'bar') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (5 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (4 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        2.319 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":26},"start":{"column":11,"line":26}}},{"id":"180","mutatorName":"PrecomputedMutator","replacement":"verb in this.verbs && this.verbs[verb]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (5 ms)\n    ✕ answers queries correctly (4 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (4 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'bar') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.4 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":26},"start":{"column":11,"line":26}}},{"id":"181","mutatorName":"PrecomputedMutator","replacement":"!this.verbs[verb]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (2 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (4 ms)\n    ✓ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (5 ms)\n    ✓ clones itself correctly\n\n\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.936 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":26},"start":{"column":11,"line":26}}},{"id":"182","mutatorName":"PrecomputedMutator","replacement":"for (const verb in verbs) {\n  this.verbs[verb] = false;\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (9 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (2 ms)\n    ✓ matches literal path segments correctly (14 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (6 ms)\n    ✓ answers context-dependent queries correctly (2 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'boo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        2.456 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":37},"start":{"column":5,"line":35}}},{"id":"183","mutatorName":"PrecomputedMutator","replacement":"verbs.slice(1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (3 ms)\n    ✓ answers context-dependent queries correctly (3 ms)\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'boo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        2.48 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":29,"line":35},"start":{"column":24,"line":35}}},{"id":"184","mutatorName":"PrecomputedMutator","replacement":"verbs.map(v => !v)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (6 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (4 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'boo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        2.441 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":29,"line":35},"start":{"column":24,"line":35}}},{"id":"185","mutatorName":"PrecomputedMutator","replacement":"verbs.filter(v => v)","status":"Survived","testsCompleted":1,"location":{"end":{"column":29,"line":35},"start":{"column":24,"line":35}}},{"id":"186","mutatorName":"PrecomputedMutator","replacement":"!this.matches(path, ctx) || !(verb in this.verbs)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n  rule\n\n    ✓ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/nah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.514 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":54,"line":50},"start":{"column":9,"line":50}}},{"id":"187","mutatorName":"PrecomputedMutator","replacement":"this.matches(path, ctx) && !(verb in this.verbs)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (5 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (9 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.405 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":54,"line":50},"start":{"column":9,"line":50}}},{"id":"188","mutatorName":"PrecomputedMutator","replacement":"this.matches(path, ctx) || verb in this.verbs","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (5 ms)\n\n    ✕ answers queries correctly (4 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (2 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters (2 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (4 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/nah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.488 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":54,"line":50},"start":{"column":9,"line":50}}},{"id":"189","mutatorName":"PrecomputedMutator","replacement":"this.matches(path.replace(this.regex, ''), ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly (2 ms)\n\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (2 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (3 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (4 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.481 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":50},"start":{"column":9,"line":50}}},{"id":"190","mutatorName":"PrecomputedMutator","replacement":"this.matches(path, null)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (8 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (4 ms)\n\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of null (reading 'foo')\n\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n    > 124 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      125 |         if (stryMutAct_9fa48(\"213\") ? prop === undefined || match[index + 1] === prop : (stryCov_9fa48(\"213\"), prop === undefined || match[index + 1] !== prop)) {\n      126 |           return false;\n      127 |         }\n\n      at Rule.matches (src/rule.ts:124:25)\n      at Rule.query (src/rule.ts:104:367)\n      at Policy.query (src/policy.ts:79:333)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of null (reading 'maybe')\n\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n    > 124 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      125 |         if (stryMutAct_9fa48(\"213\") ? prop === undefined || match[index + 1] === prop : (stryCov_9fa48(\"213\"), prop === undefined || match[index + 1] !== prop)) {\n      126 |           return false;\n      127 |         }\n\n      at Rule.matches (src/rule.ts:124:25)\n      at Rule.query (src/rule.ts:104:367)\n      at Policy.query (src/policy.ts:79:333)\n      at PolicyMap.query (src/policymap.ts:91:292)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of null (reading 'maybe')\n\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n    > 124 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      125 |         if (stryMutAct_9fa48(\"213\") ? prop === undefined || match[index + 1] === prop : (stryCov_9fa48(\"213\"), prop === undefined || match[index + 1] !== prop)) {\n      126 |           return false;\n      127 |         }\n\n      at Rule.matches (src/rule.ts:124:25)\n      at Rule.query (src/rule.ts:104:367)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        2.514 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":50},"start":{"column":9,"line":50}}},{"id":"191","mutatorName":"PrecomputedMutator","replacement":"this.matches(path, ctx.slice())","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (5 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (5 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'slice')\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:325)\n      at Policy.query (src/policy.ts:79:333)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: ctx.slice is not a function\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:325)\n      at Policy.query (src/policy.ts:79:333)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'slice')\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:325)\n      at Policy.query (src/policy.ts:79:333)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'slice')\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:325)\n      at Policy.query (src/policy.ts:79:333)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'slice')\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:325)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'slice')\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:325)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'slice')\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:325)\n      at Object.<anonymous> (test/rule.ts:108:10)\n\n  ● rule › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'slice')\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:325)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: ctx.slice is not a function\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:325)\n      at Policy.query (src/policy.ts:79:333)\n      at PolicyMap.query (src/policymap.ts:91:292)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.452 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":50},"start":{"column":9,"line":50}}},{"id":"192","mutatorName":"PrecomputedMutator","replacement":"regex.test(path)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (8 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (2 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › answers queries correctly\n\n    ReferenceError: regex is not defined\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:581)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    ReferenceError: regex is not defined\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:581)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    ReferenceError: regex is not defined\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:581)\n      at Object.<anonymous> (test/rule.ts:108:10)\n\n  ● rule › clones itself correctly\n\n    ReferenceError: regex is not defined\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:581)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (2 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › answers queries correctly\n\n    ReferenceError: regex is not defined\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:581)\n      at Policy.query (src/policy.ts:79:333)\n      at PolicyMap.query (src/policymap.ts:91:292)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (2 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    ReferenceError: regex is not defined\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:581)\n      at Policy.query (src/policy.ts:79:333)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    ReferenceError: regex is not defined\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:581)\n      at Policy.query (src/policy.ts:79:333)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    ReferenceError: regex is not defined\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:581)\n      at Policy.query (src/policy.ts:79:333)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    ReferenceError: regex is not defined\n\n      102 |     *          is not governed by this rule. */\n      103 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 104 |     if (stryMutAct_9fa48(\"188\") ? this.matches(path, ctx) || verb in this.verbs : stryMutAct_9fa48(\"187\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"186\") ? !this.matches(path, ctx) || !(verb in this.verbs) : (stryCov_9fa48(\"186\", \"187\", \"188\"), (stryMutAct_9fa48(\"191\") ? this.matches(path, ctx.slice()) : stryMutAct_9fa48(\"190\") ? this.matches(path, null) : stryMutAct_9fa48(\"189\") ? this.matches(path.replace(this.regex, ''), ctx) : (stryCov_9fa48(\"189\", \"190\", \"191\"), this.matches(stryMutAct_9fa48(\"193\") ? typeof path : stryMutAct_9fa48(\"192\") ? regex.test(path) : (stryCov_9fa48(\"192\", \"193\"), path), stryMutAct_9fa48(\"195\") ? undefined : stryMutAct_9fa48(\"194\") ? null : (stryCov_9fa48(\"194\", \"195\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^\n      105 |       return this.verbs[verb];\n      106 |     }\n      107 |     return null;\n\n      at Rule.query (src/rule.ts:104:581)\n      at Policy.query (src/policy.ts:79:333)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.936 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":26,"line":50},"start":{"column":22,"line":50}}},{"id":"193","mutatorName":"PrecomputedMutator","replacement":"typeof path","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (9 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (4 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.467 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":26,"line":50},"start":{"column":22,"line":50}}},{"id":"194","mutatorName":"PrecomputedMutator","replacement":"null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of null (reading 'maybe')\n\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n    > 124 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      125 |         if (stryMutAct_9fa48(\"213\") ? prop === undefined || match[index + 1] === prop : (stryCov_9fa48(\"213\"), prop === undefined || match[index + 1] !== prop)) {\n      126 |           return false;\n      127 |         }\n\n      at Rule.matches (src/rule.ts:124:25)\n      at Rule.query (src/rule.ts:104:507)\n      at Policy.query (src/policy.ts:79:333)\n      at PolicyMap.query (src/policymap.ts:91:292)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of null (reading 'maybe')\n\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n    > 124 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      125 |         if (stryMutAct_9fa48(\"213\") ? prop === undefined || match[index + 1] === prop : (stryCov_9fa48(\"213\"), prop === undefined || match[index + 1] !== prop)) {\n      126 |           return false;\n      127 |         }\n\n      at Rule.matches (src/rule.ts:124:25)\n      at Rule.query (src/rule.ts:104:507)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of null (reading 'foo')\n\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n    > 124 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      125 |         if (stryMutAct_9fa48(\"213\") ? prop === undefined || match[index + 1] === prop : (stryCov_9fa48(\"213\"), prop === undefined || match[index + 1] !== prop)) {\n      126 |           return false;\n      127 |         }\n\n      at Rule.matches (src/rule.ts:124:25)\n      at Rule.query (src/rule.ts:104:507)\n      at Policy.query (src/policy.ts:79:333)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        2.533 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":31,"line":50},"start":{"column":28,"line":50}}},{"id":"195","mutatorName":"PrecomputedMutator","replacement":"undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (3 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (5 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (3 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (5 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        2.439 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":31,"line":50},"start":{"column":28,"line":50}}},{"id":"196","mutatorName":"PrecomputedMutator","replacement":"path.search","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (7 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (14 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (24 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       11 failed, 27 passed, 38 total\nSnapshots:   0 total\nTime:        2.872 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":29,"line":60},"start":{"column":19,"line":60}}},{"id":"197","mutatorName":"PrecomputedMutator","replacement":"this.regex.source","status":"Survived","testsCompleted":1,"location":{"end":{"column":40,"line":60},"start":{"column":30,"line":60}}},{"id":"198","mutatorName":"PrecomputedMutator","replacement":"this.regex.exec","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (5 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (11 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       14 failed, 24 passed, 38 total\nSnapshots:   0 total\nTime:        2.737 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":60},"start":{"column":30,"line":60}}},{"id":"199","mutatorName":"PrecomputedMutator","replacement":"this.regex.test","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (3 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (5 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (4 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       14 failed, 24 passed, 38 total\nSnapshots:   0 total\nTime:        2.925 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":60},"start":{"column":30,"line":60}}},{"id":"200","mutatorName":"PrecomputedMutator","replacement":"match instanceof Matcher","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n  rule\n    ✕ matches paths correctly (6 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of null (reading '1')\n\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n      124 |         const prop = ctx[this.regex.props[index]];\n    > 125 |         if (stryMutAct_9fa48(\"213\") ? prop === undefined || match[index + 1] === prop : (stryCov_9fa48(\"213\"), prop === undefined || match[index + 1] !== prop)) {\n          |                                                                                                                                           ^\n      126 |           return false;\n      127 |         }\n      128 |       }\n\n      at Rule.matches (src/rule.ts:125:139)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (6 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of null (reading '1')\n\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n      124 |         const prop = ctx[this.regex.props[index]];\n    > 125 |         if (stryMutAct_9fa48(\"213\") ? prop === undefined || match[index + 1] === prop : (stryCov_9fa48(\"213\"), prop === undefined || match[index + 1] !== prop)) {\n          |                                                                                                                                           ^\n      126 |           return false;\n      127 |         }\n      128 |       }\n\n      at Rule.matches (src/rule.ts:125:139)\n      at Policy.matches (src/policy.ts:95:491)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.595 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":61},"start":{"column":9,"line":61}}},{"id":"201","mutatorName":"PrecomputedMutator","replacement":"count < 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (5 ms)\n\n    ✕ matches context-dependent paths correctly (5 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (8 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✓ answers queries correctly (4 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.899 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":18,"line":65},"start":{"column":9,"line":65}}},{"id":"202","mutatorName":"PrecomputedMutator","replacement":"count === 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters (4 ms)\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (7 ms)\n    ✓ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (8 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       13 failed, 25 passed, 38 total\nSnapshots:   0 total\nTime:        2.911 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":18,"line":65},"start":{"column":9,"line":65}}},{"id":"203","mutatorName":"PrecomputedMutator","replacement":"count + 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (3 ms)\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (7 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (3 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (5 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        2.588 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":18,"line":65},"start":{"column":9,"line":65}}},{"id":"204","mutatorName":"PrecomputedMutator","replacement":"ctx !== undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n    > 124 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      125 |         if (stryMutAct_9fa48(\"213\") ? prop === undefined || match[index + 1] === prop : (stryCov_9fa48(\"213\"), prop === undefined || match[index + 1] !== prop)) {\n      126 |           return false;\n      127 |         }\n\n      at Rule.matches (src/rule.ts:124:25)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n    > 124 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      125 |         if (stryMutAct_9fa48(\"213\") ? prop === undefined || match[index + 1] === prop : (stryCov_9fa48(\"213\"), prop === undefined || match[index + 1] !== prop)) {\n      126 |           return false;\n      127 |         }\n\n      at Rule.matches (src/rule.ts:124:25)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (3 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n    > 124 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      125 |         if (stryMutAct_9fa48(\"213\") ? prop === undefined || match[index + 1] === prop : (stryCov_9fa48(\"213\"), prop === undefined || match[index + 1] !== prop)) {\n      126 |           return false;\n      127 |         }\n\n      at Rule.matches (src/rule.ts:124:25)\n      at Policy.matches (src/policy.ts:95:491)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.604 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":66},"start":{"column":11,"line":66}}},{"id":"205","mutatorName":"PrecomputedMutator","replacement":"spec instanceof Matcher","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    ReferenceError: spec is not defined\n\n      118 |     const count = this.regex.props.length;\n      119 |     if (stryMutAct_9fa48(\"203\") ? count + 1 : stryMutAct_9fa48(\"202\") ? count === 0 : stryMutAct_9fa48(\"201\") ? count < 0 : (stryCov_9fa48(\"201\", \"202\", \"203\"), count > 0)) {\n    > 120 |       if (stryMutAct_9fa48(\"206\") ? match[index + 1] !== prop : stryMutAct_9fa48(\"205\") ? spec instanceof Matcher : stryMutAct_9fa48(\"204\") ? ctx !== undefined : (stryCov_9fa48(\"204\", \"205\", \"206\"), ctx === undefined)) {\n          |                                                                                           ^\n      121 |         return false;\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n\n      at Rule.matches (src/rule.ts:120:91)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    ReferenceError: spec is not defined\n\n      118 |     const count = this.regex.props.length;\n      119 |     if (stryMutAct_9fa48(\"203\") ? count + 1 : stryMutAct_9fa48(\"202\") ? count === 0 : stryMutAct_9fa48(\"201\") ? count < 0 : (stryCov_9fa48(\"201\", \"202\", \"203\"), count > 0)) {\n    > 120 |       if (stryMutAct_9fa48(\"206\") ? match[index + 1] !== prop : stryMutAct_9fa48(\"205\") ? spec instanceof Matcher : stryMutAct_9fa48(\"204\") ? ctx !== undefined : (stryCov_9fa48(\"204\", \"205\", \"206\"), ctx === undefined)) {\n          |                                                                                           ^\n      121 |         return false;\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n\n      at Rule.matches (src/rule.ts:120:91)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● policy › matches context-dependent paths correctly\n\n    ReferenceError: spec is not defined\n\n      118 |     const count = this.regex.props.length;\n      119 |     if (stryMutAct_9fa48(\"203\") ? count + 1 : stryMutAct_9fa48(\"202\") ? count === 0 : stryMutAct_9fa48(\"201\") ? count < 0 : (stryCov_9fa48(\"201\", \"202\", \"203\"), count > 0)) {\n    > 120 |       if (stryMutAct_9fa48(\"206\") ? match[index + 1] !== prop : stryMutAct_9fa48(\"205\") ? spec instanceof Matcher : stryMutAct_9fa48(\"204\") ? ctx !== undefined : (stryCov_9fa48(\"204\", \"205\", \"206\"), ctx === undefined)) {\n          |                                                                                           ^\n      121 |         return false;\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n\n      at Rule.matches (src/rule.ts:120:91)\n      at Policy.matches (src/policy.ts:95:491)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    ReferenceError: spec is not defined\n\n      118 |     const count = this.regex.props.length;\n      119 |     if (stryMutAct_9fa48(\"203\") ? count + 1 : stryMutAct_9fa48(\"202\") ? count === 0 : stryMutAct_9fa48(\"201\") ? count < 0 : (stryCov_9fa48(\"201\", \"202\", \"203\"), count > 0)) {\n    > 120 |       if (stryMutAct_9fa48(\"206\") ? match[index + 1] !== prop : stryMutAct_9fa48(\"205\") ? spec instanceof Matcher : stryMutAct_9fa48(\"204\") ? ctx !== undefined : (stryCov_9fa48(\"204\", \"205\", \"206\"), ctx === undefined)) {\n          |                                                                                           ^\n      121 |         return false;\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n\n      at Rule.matches (src/rule.ts:120:91)\n      at Policy.matches (src/policy.ts:95:491)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    ReferenceError: spec is not defined\n\n      118 |     const count = this.regex.props.length;\n      119 |     if (stryMutAct_9fa48(\"203\") ? count + 1 : stryMutAct_9fa48(\"202\") ? count === 0 : stryMutAct_9fa48(\"201\") ? count < 0 : (stryCov_9fa48(\"201\", \"202\", \"203\"), count > 0)) {\n    > 120 |       if (stryMutAct_9fa48(\"206\") ? match[index + 1] !== prop : stryMutAct_9fa48(\"205\") ? spec instanceof Matcher : stryMutAct_9fa48(\"204\") ? ctx !== undefined : (stryCov_9fa48(\"204\", \"205\", \"206\"), ctx === undefined)) {\n          |                                                                                           ^\n      121 |         return false;\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n\n      at Rule.matches (src/rule.ts:120:91)\n      at Policy.matches (src/policy.ts:95:491)\n      at PolicyMap.matches (src/policymap.ts:100:442)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    ReferenceError: spec is not defined\n\n      118 |     const count = this.regex.props.length;\n      119 |     if (stryMutAct_9fa48(\"203\") ? count + 1 : stryMutAct_9fa48(\"202\") ? count === 0 : stryMutAct_9fa48(\"201\") ? count < 0 : (stryCov_9fa48(\"201\", \"202\", \"203\"), count > 0)) {\n    > 120 |       if (stryMutAct_9fa48(\"206\") ? match[index + 1] !== prop : stryMutAct_9fa48(\"205\") ? spec instanceof Matcher : stryMutAct_9fa48(\"204\") ? ctx !== undefined : (stryCov_9fa48(\"204\", \"205\", \"206\"), ctx === undefined)) {\n          |                                                                                           ^\n      121 |         return false;\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n\n      at Rule.matches (src/rule.ts:120:91)\n      at Rule.query (src/rule.ts:104:507)\n      at Policy.query (src/policy.ts:79:333)\n      at PolicyMap.query (src/policymap.ts:91:292)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.652 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":66},"start":{"column":11,"line":66}}},{"id":"206","mutatorName":"PrecomputedMutator","replacement":"match[index + 1] !== prop","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (4 ms)\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    ReferenceError: index is not defined\n\n      118 |     const count = this.regex.props.length;\n      119 |     if (stryMutAct_9fa48(\"203\") ? count + 1 : stryMutAct_9fa48(\"202\") ? count === 0 : stryMutAct_9fa48(\"201\") ? count < 0 : (stryCov_9fa48(\"201\", \"202\", \"203\"), count > 0)) {\n    > 120 |       if (stryMutAct_9fa48(\"206\") ? match[index + 1] !== prop : stryMutAct_9fa48(\"205\") ? spec instanceof Matcher : stryMutAct_9fa48(\"204\") ? ctx !== undefined : (stryCov_9fa48(\"204\", \"205\", \"206\"), ctx === undefined)) {\n          |                                           ^\n      121 |         return false;\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n\n      at Rule.matches (src/rule.ts:120:43)\n      at Policy.matches (src/policy.ts:95:491)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    ReferenceError: index is not defined\n\n      118 |     const count = this.regex.props.length;\n      119 |     if (stryMutAct_9fa48(\"203\") ? count + 1 : stryMutAct_9fa48(\"202\") ? count === 0 : stryMutAct_9fa48(\"201\") ? count < 0 : (stryCov_9fa48(\"201\", \"202\", \"203\"), count > 0)) {\n    > 120 |       if (stryMutAct_9fa48(\"206\") ? match[index + 1] !== prop : stryMutAct_9fa48(\"205\") ? spec instanceof Matcher : stryMutAct_9fa48(\"204\") ? ctx !== undefined : (stryCov_9fa48(\"204\", \"205\", \"206\"), ctx === undefined)) {\n          |                                           ^\n      121 |         return false;\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n\n      at Rule.matches (src/rule.ts:120:43)\n      at Policy.matches (src/policy.ts:95:491)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    ReferenceError: index is not defined\n\n      118 |     const count = this.regex.props.length;\n      119 |     if (stryMutAct_9fa48(\"203\") ? count + 1 : stryMutAct_9fa48(\"202\") ? count === 0 : stryMutAct_9fa48(\"201\") ? count < 0 : (stryCov_9fa48(\"201\", \"202\", \"203\"), count > 0)) {\n    > 120 |       if (stryMutAct_9fa48(\"206\") ? match[index + 1] !== prop : stryMutAct_9fa48(\"205\") ? spec instanceof Matcher : stryMutAct_9fa48(\"204\") ? ctx !== undefined : (stryCov_9fa48(\"204\", \"205\", \"206\"), ctx === undefined)) {\n          |                                           ^\n      121 |         return false;\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n\n      at Rule.matches (src/rule.ts:120:43)\n      at Policy.matches (src/policy.ts:95:491)\n      at PolicyMap.matches (src/policymap.ts:100:442)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    ReferenceError: index is not defined\n\n      118 |     const count = this.regex.props.length;\n      119 |     if (stryMutAct_9fa48(\"203\") ? count + 1 : stryMutAct_9fa48(\"202\") ? count === 0 : stryMutAct_9fa48(\"201\") ? count < 0 : (stryCov_9fa48(\"201\", \"202\", \"203\"), count > 0)) {\n    > 120 |       if (stryMutAct_9fa48(\"206\") ? match[index + 1] !== prop : stryMutAct_9fa48(\"205\") ? spec instanceof Matcher : stryMutAct_9fa48(\"204\") ? ctx !== undefined : (stryCov_9fa48(\"204\", \"205\", \"206\"), ctx === undefined)) {\n          |                                           ^\n      121 |         return false;\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n\n      at Rule.matches (src/rule.ts:120:43)\n      at Rule.query (src/rule.ts:104:507)\n      at Policy.query (src/policy.ts:79:333)\n      at PolicyMap.query (src/policymap.ts:91:292)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    ReferenceError: index is not defined\n\n      118 |     const count = this.regex.props.length;\n      119 |     if (stryMutAct_9fa48(\"203\") ? count + 1 : stryMutAct_9fa48(\"202\") ? count === 0 : stryMutAct_9fa48(\"201\") ? count < 0 : (stryCov_9fa48(\"201\", \"202\", \"203\"), count > 0)) {\n    > 120 |       if (stryMutAct_9fa48(\"206\") ? match[index + 1] !== prop : stryMutAct_9fa48(\"205\") ? spec instanceof Matcher : stryMutAct_9fa48(\"204\") ? ctx !== undefined : (stryCov_9fa48(\"204\", \"205\", \"206\"), ctx === undefined)) {\n          |                                           ^\n      121 |         return false;\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n\n      at Rule.matches (src/rule.ts:120:43)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    ReferenceError: index is not defined\n\n      118 |     const count = this.regex.props.length;\n      119 |     if (stryMutAct_9fa48(\"203\") ? count + 1 : stryMutAct_9fa48(\"202\") ? count === 0 : stryMutAct_9fa48(\"201\") ? count < 0 : (stryCov_9fa48(\"201\", \"202\", \"203\"), count > 0)) {\n    > 120 |       if (stryMutAct_9fa48(\"206\") ? match[index + 1] !== prop : stryMutAct_9fa48(\"205\") ? spec instanceof Matcher : stryMutAct_9fa48(\"204\") ? ctx !== undefined : (stryCov_9fa48(\"204\", \"205\", \"206\"), ctx === undefined)) {\n          |                                           ^\n      121 |         return false;\n      122 |       }\n      123 |       for (let index = 0; stryMutAct_9fa48(\"209\") ? index > count : stryMutAct_9fa48(\"208\") ? index < 0 : stryMutAct_9fa48(\"207\") ? index >= count : (stryCov_9fa48(\"207\", \"208\", \"209\"), index < count); stryMutAct_9fa48(\"212\") ? index = index + 10 : stryMutAct_9fa48(\"211\") ? index -= 10 : stryMutAct_9fa48(\"210\") ? index += 10 : (stryCov_9fa48(\"210\", \"211\", \"212\"), index++)) {\n\n      at Rule.matches (src/rule.ts:120:43)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        3.106 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":66},"start":{"column":11,"line":66}}},{"id":"207","mutatorName":"PrecomputedMutator","replacement":"index >= count","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (11 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.6 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":69},"start":{"column":27,"line":69}}},{"id":"208","mutatorName":"PrecomputedMutator","replacement":"index < 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (10 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (4 ms)\n\n    ✕ matches context-dependent paths correctly (4 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.543 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":69},"start":{"column":27,"line":69}}},{"id":"209","mutatorName":"PrecomputedMutator","replacement":"index > count","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✓ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.552 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":69},"start":{"column":27,"line":69}}},{"id":"210","mutatorName":"PrecomputedMutator","replacement":"index += 10","status":"Survived","testsCompleted":1,"location":{"end":{"column":49,"line":69},"start":{"column":42,"line":69}}},{"id":"211","mutatorName":"PrecomputedMutator","replacement":"index -= 10","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (3 ms)\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (3 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly (2 ms)\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (5 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.583 s, estimated 4 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":49,"line":69},"start":{"column":42,"line":69}}},{"id":"212","mutatorName":"PrecomputedMutator","replacement":"index = index + 10","status":"Survived","testsCompleted":1,"location":{"end":{"column":49,"line":69},"start":{"column":42,"line":69}}},{"id":"213","mutatorName":"PrecomputedMutator","replacement":"prop === undefined || match[index + 1] === prop","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (2 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (2 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (7 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n\n    ✓ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (9 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.609 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":60,"line":71},"start":{"column":13,"line":71}}},{"id":"214","mutatorName":"PrecomputedMutator","replacement":"for (const verb in this.verbs && this.verbs[verb]) {\n  rule.verbs[verb] = this.verbs[verb];\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards (3 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (5 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › clones itself correctly\n\n    ReferenceError: Cannot access 'verb' before initialization\n\n      136 |     const rule = new Rule(spec);\n      137 |     if (stryMutAct_9fa48(\"214\")) {\n    > 138 |       for (const verb in this.verbs && this.verbs[verb]) {\n          |                                                   ^\n      139 |         rule.verbs[verb] = this.verbs[verb];\n      140 |       }\n      141 |     } else {\n\n      at Rule.clone (src/rule.ts:138:51)\n      at Object.<anonymous> (test/rule.ts:124:10)\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › clones itself correctly\n\n    ReferenceError: Cannot access 'verb' before initialization\n\n      136 |     const rule = new Rule(spec);\n      137 |     if (stryMutAct_9fa48(\"214\")) {\n    > 138 |       for (const verb in this.verbs && this.verbs[verb]) {\n          |                                                   ^\n      139 |         rule.verbs[verb] = this.verbs[verb];\n      140 |       }\n      141 |     } else {\n\n      at Rule.clone (src/rule.ts:138:51)\n      at src/policy.ts:106:594\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:291)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.591 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":85},"start":{"column":5,"line":83}}},{"id":"215","mutatorName":"PrecomputedMutator","replacement":"newVerbs","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (11 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n  ● policy › clones itself correctly\n\n    ReferenceError: newVerbs is not defined\n\n      141 |     } else {\n      142 |       stryCov_9fa48(\"214\");\n    > 143 |       for (const verb in stryMutAct_9fa48(\"217\") ? JSON.parse(JSON.stringify(this.verbs)) : stryMutAct_9fa48(\"216\") ? Object.assign({}, this.verbs) : stryMutAct_9fa48(\"215\") ? newVerbs : (stryCov_9fa48(\"215\", \"216\", \"217\"), this.verbs)) {\n          |                                                                                                                                                                                 ^\n      144 |         rule.verbs[verb] = this.verbs[verb];\n      145 |       }\n      146 |     }\n\n      at Rule.clone (src/rule.ts:143:177)\n      at src/policy.ts:106:594\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:291)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● rule › clones itself correctly\n\n    ReferenceError: newVerbs is not defined\n\n      141 |     } else {\n      142 |       stryCov_9fa48(\"214\");\n    > 143 |       for (const verb in stryMutAct_9fa48(\"217\") ? JSON.parse(JSON.stringify(this.verbs)) : stryMutAct_9fa48(\"216\") ? Object.assign({}, this.verbs) : stryMutAct_9fa48(\"215\") ? newVerbs : (stryCov_9fa48(\"215\", \"216\", \"217\"), this.verbs)) {\n          |                                                                                                                                                                                 ^\n      144 |         rule.verbs[verb] = this.verbs[verb];\n      145 |       }\n      146 |     }\n\n      at Rule.clone (src/rule.ts:143:177)\n      at Object.<anonymous> (test/rule.ts:124:10)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.643 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":83},"start":{"column":24,"line":83}}},{"id":"216","mutatorName":"PrecomputedMutator","replacement":"Object.assign({}, this.verbs)","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":83},"start":{"column":24,"line":83}}},{"id":"217","mutatorName":"PrecomputedMutator","replacement":"JSON.parse(JSON.stringify(this.verbs))","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":83},"start":{"column":24,"line":83}}}],"source":"import { Matcher } from './matcher'\nimport { Queryable, QueryContext } from './queryable'\n\n/** Access-control rule for a single path. */\nexport class Rule implements Queryable {\n  /** Pattern for determining which paths are governed by this rule. */\n  readonly regex: Matcher\n  /** Set of verbs governed by this rule; allowed verbs\n    * are marked as `true`, denied verbs as `false`. */\n  readonly verbs: { [index: string]: boolean } = {}\n\n  /** @param spec Path specification or pre-compiled matcher for\n    *             determining which paths this rule will apply to. */\n  constructor (spec: string | Matcher) {\n    this.regex = spec instanceof Matcher\n      ? spec\n      : new Matcher(spec)\n  }\n\n  /** Mark one or more verbs as allowed.\n    * @note Deny overrides allow within SPACL policies;\n    *       this method will have no effect on verbs\n    *       previously marked as denied. */\n  allow (...verbs: string[]): Rule {\n    for (const verb of verbs) {\n      if (!(verb in this.verbs)) {\n        this.verbs[verb] = true\n      }\n    }\n    return this\n  }\n\n  /** Mark one or more verbs as denied. */\n  deny (...verbs: string[]): Rule {\n    for (const verb of verbs) {\n      this.verbs[verb] = false\n    }\n    return this\n  }\n\n  /** Check whether an action is allowed on a path.\n    * @param path Path to be acted on.\n    * @param verb Action to be performed.\n    * @param ctx Query context for resolving context-dependent paths.\n    * @returns Returns `true` if the action is explicitly allowed,\n    *          `false` if the action is explicitly denied, or\n    *          `null` if the combination of path and action\n    *          is not governed by this rule. */\n  query (path: string, verb: string, ctx?: QueryContext): boolean | null {\n    if (this.matches(path, ctx) && verb in this.verbs) {\n      return this.verbs[verb]\n    }\n    return null\n  }\n\n  /** Check whether a path is governed by this rule.\n    * @param path Path to be checked.\n    * @param ctx Query context for resolving context-dependent paths. */\n  matches (path: string, ctx?: QueryContext): boolean {\n    const match = path.match(this.regex)\n    if (match === null) {\n      return false\n    }\n    const count = this.regex.props.length\n    if (count > 0) {\n      if (ctx === undefined) {\n        return false\n      }\n      for (let index = 0; index < count; index++) {\n        const prop = ctx[this.regex.props[index]]\n        if (prop === undefined || match[index + 1] !== prop) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  /** Create clone of a rule.\n    * @param spec Replacement path specification for the new rule. */\n  clone (spec: string | Matcher = this.regex): Rule {\n    const rule = new Rule(spec)\n    for (const verb in this.verbs) {\n      rule.verbs[verb] = this.verbs[verb]\n    }\n    return rule\n  }\n\n  /** Static constructor function; returns a new Rule.\n    * @param spec Path specification or pre-compiled matcher for\n    *             determining which paths this rule will apply to. */\n  static for (spec: string | Matcher): Rule {\n    return new Rule(spec)\n  }\n}\n"}},"schemaVersion":"1.0","thresholds":{"high":80,"low":60,"break":null},"testFiles":{"":{"tests":[{"id":"0","name":"All tests"}]}},"projectRoot":"/Users/jon/Documents/NEU/Projects/llm-mutation-testing/projects/spacl-core","config":{"concurrency":1,"usePrecomputed":true,"mutate":["src/index.ts","src/matcher.ts","src/policy.ts","src/policymap.ts","src/queryable.ts","src/rule.ts"],"reporters":["json","html","progress"],"allowConsoleColors":true,"checkers":[],"checkerNodeArgs":[],"commandRunner":{"command":"npm test"},"coverageAnalysis":"perTest","clearTextReporter":{"allowColor":true,"allowEmojis":false,"logTests":true,"maxTestsToLog":3,"reportTests":true,"reportMutants":true,"reportScoreTable":true},"dashboard":{"baseUrl":"https://dashboard.stryker-mutator.io/api/reports","reportType":"full"},"dryRunOnly":false,"eventReporter":{"baseDir":"reports/mutation/events"},"ignorePatterns":[],"ignoreStatic":false,"incremental":false,"incrementalFile":"reports/stryker-incremental.json","force":false,"fileLogLevel":"off","inPlace":false,"logLevel":"info","maxConcurrentTestRunners":9007199254740991,"maxTestRunnerReuse":0,"mutator":{"plugins":null,"excludedMutations":[]},"plugins":["@stryker-mutator/*"],"appendPlugins":[],"htmlReporter":{"fileName":"reports/mutation/mutation.html"},"jsonReporter":{"fileName":"reports/mutation/mutation.json"},"disableTypeChecks":true,"symlinkNodeModules":true,"tempDirName":".stryker-tmp","cleanTempDir":true,"testRunner":"command","testRunnerNodeArgs":[],"thresholds":{"high":80,"low":60,"break":null},"timeoutFactor":1.5,"timeoutMS":5000,"dryRunTimeoutMinutes":5,"tsconfigFile":"tsconfig.json","warnings":true,"disableBail":false,"allowEmpty":false,"ignorers":[],"cucumber":{},"jest":{"projectType":"custom","enableFindRelatedTests":true},"mochaOptions":{},"tap":{"testFiles":["{**/@(test|tests|__test__|__tests__)/**,**/*.@(test|tests|spec)}.@(cjs|mjs|js|jsx|ts|tsx|mts|cts)"],"nodeArgs":["-r","{{hookFile}}","{{testFile}}"],"forceBail":true},"vitest":{}},"framework":{"name":"StrykerJS","version":"8.2.5","branding":{"homepageUrl":"https://stryker-mutator.io","imageUrl":"data:image/svg+xml;utf8,%3Csvg viewBox='0 0 1458 1458' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' clip-rule='evenodd' stroke-linejoin='round' stroke-miterlimit='2'%3E%3Cpath fill='none' d='M0 0h1458v1458H0z'/%3E%3CclipPath id='a'%3E%3Cpath d='M0 0h1458v1458H0z'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23a)'%3E%3Cpath d='M1458 729c0 402.655-326.345 729-729 729S0 1131.655 0 729C0 326.445 326.345 0 729 0s729 326.345 729 729' fill='%23e74c3c' fill-rule='nonzero'/%3E%3Cpath d='M778.349 1456.15L576.6 1254.401l233-105 85-78.668v-64.332l-257-257-44-187-50-208 251.806-82.793L1076.6 389.401l380.14 379.15c-19.681 367.728-311.914 663.049-678.391 687.599z' fill-opacity='.3'/%3E%3Cpath d='M753.4 329.503c41.79 0 74.579 7.83 97.925 25.444 23.571 18.015 41.69 43.956 55.167 77.097l11.662 28.679 165.733-58.183-14.137-32.13c-26.688-60.655-64.896-108.61-114.191-144.011-49.329-35.423-117.458-54.302-204.859-54.302-50.78 0-95.646 7.376-134.767 21.542-40.093 14.671-74.09 34.79-102.239 60.259-28.84 26.207-50.646 57.06-65.496 92.701-14.718 35.052-22.101 72.538-22.101 112.401 0 72.536 20.667 133.294 61.165 182.704 38.624 47.255 98.346 88.037 179.861 121.291 42.257 17.475 78.715 33.125 109.227 46.994 27.193 12.361 49.294 26.124 66.157 41.751 15.309 14.186 26.497 30.584 33.63 49.258 7.721 20.214 11.16 45.69 11.16 76.402 0 28.021-4.251 51.787-13.591 71.219-8.832 18.374-20.171 33.178-34.523 44.219-14.787 11.374-31.193 19.591-49.393 24.466-19.68 5.359-39.14 7.993-58.69 7.993-29.359 0-54.387-3.407-75.182-10.747-20.112-7.013-37.144-16.144-51.259-27.486-13.618-11.009-24.971-23.766-33.744-38.279-9.64-15.8-17.272-31.924-23.032-48.408l-10.965-31.376-161.669 60.585 10.734 30.124c10.191 28.601 24.197 56.228 42.059 82.748 18.208 27.144 41.322 51.369 69.525 72.745 27.695 21.075 60.904 38.218 99.481 51.041 37.777 12.664 82.004 19.159 132.552 19.159 49.998 0 95.818-8.321 137.611-24.622 42.228-16.471 78.436-38.992 108.835-67.291 30.719-28.597 54.631-62.103 71.834-100.642 17.263-38.56 25.923-79.392 25.923-122.248 0-54.339-8.368-100.37-24.208-138.32-16.29-38.759-38.252-71.661-65.948-98.797-26.965-26.418-58.269-48.835-93.858-67.175-33.655-17.241-69.196-33.11-106.593-47.533-35.934-13.429-65.822-26.601-89.948-39.525-22.153-11.868-40.009-24.21-53.547-37.309-11.429-11.13-19.83-23.678-24.718-37.664-5.413-15.49-7.98-33.423-7.98-53.577 0-40.883 11.293-71.522 37.086-90.539 28.443-20.825 64.985-30.658 109.311-30.658z' fill='%23f1c40f' fill-rule='nonzero'/%3E%3Cpath d='M720 0h18v113h-18zM1458 738v-18h-113v18h113zM720 1345h18v113h-18zM113 738v-18H0v18h113z'/%3E%3C/g%3E%3C/svg%3E"},"dependencies":{"@stryker-mutator/mocha-runner":"8.2.5","@stryker-mutator/karma-runner":"8.2.5","@stryker-mutator/jasmine-runner":"8.2.5","@stryker-mutator/jest-runner":"8.2.5","mocha":"10.4.0","jasmine-core":"5.1.2","jest":"27.5.1","typescript":"4.9.5","ts-jest":"27.1.5"}}}