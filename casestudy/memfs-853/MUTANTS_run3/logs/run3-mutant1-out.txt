
> memfs@3.4.4 test
> jest --maxWorkers 2

FAIL src/__tests__/volume/appendFile.test.ts (6.846 s)
  ● appendFile(file, data[, options], callback) › Append to existing file

    expect(received).toEqual(expected) // deep equality

    Expected: "bc"
    Received: "b"

      13 |     vol.appendFile('/a', 'c', (err, res) => {
      14 |       expect(vol.readFileSync('/a', 'utf8')).toEqual('bc');
    > 15 |       done();
         |              ^
      16 |     });
      17 |   });
      18 | });

      at src/__tests__/volume/appendFile.test.ts:15:52
      at Immediate.<anonymous> (src/volume.ts:698:17)

  ● appendFile(file, data[, options], callback) › Append to existing file

    thrown: "Exceeded timeout of 5000 ms for a test.
    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test."

      10 |   });
      11 |   it('Append to existing file', done => {
    > 12 |     const vol = create({ '/a': 'b' });
         |     ^
      13 |     vol.appendFile('/a', 'c', (err, res) => {
      14 |       expect(vol.readFileSync('/a', 'utf8')).toEqual('bc');
      15 |       done();

      at src/__tests__/volume/appendFile.test.ts:12:5
      at Object.<anonymous> (src/__tests__/volume/appendFile.test.ts:4:1)

FAIL src/__tests__/promises.test.ts
  ● Promises API › FileHandle › appendFile(data[, options]) › Append data to an existing file

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › appendFile(data[, options]) › Reject when the file handle was closed

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › chmod(mode) › Change mode of existing file

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › chmod(mode) › Reject when the file handle was closed

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › chown(uid, gid) › Change uid and gid of existing file

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › chown(uid, gid) › Reject when the file handle was closed

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › write(buffer[, offset[, length[, position]]]) › Write data to an existing file

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › write(buffer[, offset[, length[, position]]]) › Reject when the file handle was closed

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › writeFile(data[, options]) › Write data to an existing file

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › writeFile(data[, options]) › Reject when the file handle was closed

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › appendFile(path, data[, options]) › Append data to existing file

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.writeFileBase (src/volume.ts:1089:23)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › appendFile(path, data[, options]) › Append data to existing file using FileHandle

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › writeFile(id, data[, options]) › Write data to an existing file

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.writeFileBase (src/volume.ts:1089:23)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › writeFile(id, data[, options]) › Write data to existing file using FileHandle

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

PASS src/__tests__/node.test.ts
PASS src/__tests__/volume/writeSync.test.ts
PASS src/__tests__/volume/writeFileSync.test.ts
PASS src/__tests__/index.test.ts
PASS src/__tests__/volume/write.test.ts
FAIL src/__tests__/volume/closeSync.test.ts
  ● .closeSync(fd) › Closing same file descriptor twice throws EBADF

    EEXIST: file already exists, open '/test.txt'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.openSync (src/volume.ts:869:21)
      at Object.<anonymous> (src/__tests__/volume/closeSync.test.ts:32:22)

  ● .closeSync(fd) › Closing a file decreases the number of open files

    EEXIST: file already exists, open '/test.txt'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.openSync (src/volume.ts:869:21)
      at Object.<anonymous> (src/__tests__/volume/closeSync.test.ts:43:22)

  ● .closeSync(fd) › When closing a file, its descriptor is added to the pool of descriptors to be reused

    EEXIST: file already exists, open '/test.txt'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.openSync (src/volume.ts:869:21)
      at Object.<anonymous> (src/__tests__/volume/closeSync.test.ts:49:22)

PASS src/__tests__/volume/openSync.test.ts
PASS src/__tests__/volume/rmPromise.test.ts
PASS src/__tests__/volume/copyFileSync.test.ts
PASS src/__tests__/volume/renameSync.test.ts
PASS src/__tests__/volume/rmSync.test.ts
PASS src/__tests__/volume/readdirSync.test.ts
PASS src/__tests__/volume/realpathSync.test.ts
PASS src/__tests__/volume/mkdirSync.test.ts
PASS src/__tests__/volume/existsSync.test.ts
PASS src/__tests__/volume/exists.test.ts
PASS src/__tests__/volume/copyFile.test.ts
FAIL src/__tests__/volume/WriteStream.test.ts (5.046 s)
  ● WriteStream › Can write basic file

    Unhandled error. (Error: EEXIST: file already exists, open '/a'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate._onImmediate (src/volume.ts:695:33)
      at processImmediate (node:internal/timers:483:21) {
        code: 'EEXIST'
      })
      at class_2.<anonymous> (src/volume.ts:2114:18)
      at Immediate.<anonymous> (src/volume.ts:698:17)

  ● WriteStream › Can write basic file

    thrown: "Exceeded timeout of 5000 ms for a test.
    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test."

      12 |   });
      13 |   it('Can write basic file', done => {
    > 14 |     const fs = createFs({ '/a': 'b' });
         |     ^
      15 |     const ws = new fs.WriteStream('/a', 'utf8');
      16 |     ws.end('d');
      17 |     ws.on('finish', () => {

      at src/__tests__/volume/WriteStream.test.ts:14:5
      at Object.<anonymous> (src/__tests__/volume/WriteStream.test.ts:4:1)

PASS src/__tests__/volume/ReadStream.test.ts
PASS src/__tests__/volume/readSync.test.ts
FAIL src/__tests__/volume/appendFileSync.test.ts
  ● appendFileSync(file, data, options) › Append to existing file

    EEXIST: file already exists, open '/a'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.writeFileBase (src/volume.ts:1089:23)
      at Volume.Object.<anonymous>.Volume.writeFileSync (src/volume.ts:1114:14)
      at Volume.Object.<anonymous>.Volume.appendFileSync (src/volume.ts:1402:14)
      at Object.<anonymous> (src/__tests__/volume/appendFileSync.test.ts:12:13)

PASS src/__tests__/volume/toString.test.ts
PASS src/__tests__/volume/statSync.test.ts
PASS src/__tests__/volume/rename.test.ts
PASS src/__tests__/process.test.ts
PASS src/__tests__/setTimeoutUnref.test.ts
PASS src/__tests__/setImmediate.test.ts
FAIL src/__tests__/volume/callback-error.test.ts
  ● Test suite failed to run

    TypeError: Cannot assign to read only property 'performance' of object '[object global]'

    > 1 | jest.useFakeTimers('modern');
        |                          ^
      2 |
      3 | // Fixes https://github.com/streamich/memfs/issues/542
      4 | it('should throw error instead of callback', () => {

      at hijackMethod (node_modules/@sinonjs/fake-timers/src/fake-timers-src.js:946:32)
      at Object.install (node_modules/@sinonjs/fake-timers/src/fake-timers-src.js:1733:17)
      at FakeTimers.useFakeTimers (node_modules/@jest/fake-timers/build/modernFakeTimers.js:110:36)
      at Object.<anonymous> (src/__tests__/volume/callback-error.test.ts:1:26)

FAIL src/__tests__/volume.test.ts (17.028 s)
  ● volume › Volume › .fromJSON(json[, cwd]) › Invalid JSON throws error

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      219 |           '/dir/dir/dir2/hello.sh': 'world',
      220 |           '/hello.js': 'console.log(123)',
    > 221 |           '/dir/dir/test.txt': 'Windows',
          |                                          ^
      222 |         };
      223 |         vol.fromJSON(json);
      224 |         expect(vol.toJSON()).toEqual(json);

      at Object.<anonymous> (src/__tests__/volume.test.ts:221:81)

  ● volume › Volume › .statSync(path) › Modification new write

    EEXIST: file already exists, open '/mtime.txt'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.writeFileBase (src/volume.ts:1089:23)
      at Volume.Object.<anonymous>.Volume.writeFileSync (src/volume.ts:1114:14)
      at Timeout._onTimeout (src/__tests__/volume.test.ts:790:25)

  ● volume › Volume › .statSync(path) › Modification new write

    thrown: "Exceeded timeout of 5000 ms for a test.
    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test."

      784 |       it('Returns basic file stats', () => {
      785 |         const stats = vol.statSync('/dojo.js');
    > 786 |         expect(stats).toBeInstanceOf(Stats);
          |             ^
      787 |         expect(stats.size).toBe(data.length);
      788 |         expect(stats.isFile()).toBe(true);
      789 |         expect(stats.isDirectory()).toBe(false);

      at src/__tests__/volume.test.ts:786:13
      at src/__tests__/volume.test.ts:758:9
      at src/__tests__/volume.test.ts:31:5
      at Object.<anonymous> (src/__tests__/volume.test.ts:10:1)

  ● volume › Volume › .watchFile(path[, options], listener) › Calls listener on .writeFile

    EEXIST: file already exists, open '/lol.txt'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.writeFileBase (src/volume.ts:1089:23)
      at Volume.Object.<anonymous>.Volume.writeFileSync (src/volume.ts:1114:14)
      at Timeout._onTimeout (src/__tests__/volume.test.ts:1058:25)

  ● volume › Volume › .watchFile(path[, options], listener) › Calls listener on .writeFile

    thrown: "Exceeded timeout of 5000 ms for a test.
    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test."

      1046 |         expect(!!vol.root.getChild('dir')).toBe(false);
      1047 |       });
    > 1048 |       it('Remove dir /dir1/dir2/dir3 recursively', () => {
           |             ^
      1049 |         const vol = new Volume();
      1050 |         vol.mkdirSync('/dir1/dir2/dir3', { recursive: true });
      1051 |         vol.rmdirSync('/dir1', { recursive: true });

      at src/__tests__/volume.test.ts:1048:13
      at src/__tests__/volume.test.ts:1047:9
      at src/__tests__/volume.test.ts:31:5
      at Object.<anonymous> (src/__tests__/volume.test.ts:10:1)

  ● volume › Volume › .unwatchFile(path[, listener]) › Stops watching before .writeFile

    EEXIST: file already exists, open '/lol.txt'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.writeFileBase (src/volume.ts:1089:23)
      at Volume.Object.<anonymous>.Volume.writeFileSync (src/volume.ts:1114:14)
      at Timeout._onTimeout (src/__tests__/volume.test.ts:1073:25)

  ● volume › Volume › .unwatchFile(path[, listener]) › Stops watching before .writeFile

    thrown: "Exceeded timeout of 5000 ms for a test.
    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test."

      1062 |           done();
      1063 |         });
    > 1064 |       });
           |          ^
      1065 |     });
      1066 |     describe('.watchFile(path[, options], listener)', () => {
      1067 |       it('Calls listener on .writeFile', done => {

      at src/__tests__/volume.test.ts:1064:13
      at src/__tests__/volume.test.ts:1063:9
      at src/__tests__/volume.test.ts:31:5
      at Object.<anonymous> (src/__tests__/volume.test.ts:10:1)

A worker process has failed to exit gracefully and has been force exited. This is likely caused by tests leaking due to improper teardown. Try running with --detectOpenHandles to find leaks. Active timers can also cause this, ensure that .unref() was called on them.
Summary of all failing tests
FAIL src/__tests__/volume/appendFile.test.ts (6.846 s)
  ● appendFile(file, data[, options], callback) › Append to existing file

    expect(received).toEqual(expected) // deep equality

    Expected: "bc"
    Received: "b"

      13 |     vol.appendFile('/a', 'c', (err, res) => {
      14 |       expect(vol.readFileSync('/a', 'utf8')).toEqual('bc');
    > 15 |       done();
         |              ^
      16 |     });
      17 |   });
      18 | });

      at src/__tests__/volume/appendFile.test.ts:15:52
      at Immediate.<anonymous> (src/volume.ts:698:17)

  ● appendFile(file, data[, options], callback) › Append to existing file

    thrown: "Exceeded timeout of 5000 ms for a test.
    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test."

      10 |   });
      11 |   it('Append to existing file', done => {
    > 12 |     const vol = create({ '/a': 'b' });
         |     ^
      13 |     vol.appendFile('/a', 'c', (err, res) => {
      14 |       expect(vol.readFileSync('/a', 'utf8')).toEqual('bc');
      15 |       done();

      at src/__tests__/volume/appendFile.test.ts:12:5
      at Object.<anonymous> (src/__tests__/volume/appendFile.test.ts:4:1)

FAIL src/__tests__/promises.test.ts
  ● Promises API › FileHandle › appendFile(data[, options]) › Append data to an existing file

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › appendFile(data[, options]) › Reject when the file handle was closed

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › chmod(mode) › Change mode of existing file

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › chmod(mode) › Reject when the file handle was closed

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › chown(uid, gid) › Change uid and gid of existing file

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › chown(uid, gid) › Reject when the file handle was closed

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › write(buffer[, offset[, length[, position]]]) › Write data to an existing file

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › write(buffer[, offset[, length[, position]]]) › Reject when the file handle was closed

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › writeFile(data[, options]) › Write data to an existing file

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › FileHandle › writeFile(data[, options]) › Reject when the file handle was closed

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › appendFile(path, data[, options]) › Append data to existing file

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.writeFileBase (src/volume.ts:1089:23)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › appendFile(path, data[, options]) › Append data to existing file using FileHandle

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › writeFile(id, data[, options]) › Write data to an existing file

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.writeFileBase (src/volume.ts:1089:23)
      at Immediate.<anonymous> (src/volume.ts:695:33)

  ● Promises API › writeFile(id, data[, options]) › Write data to existing file using FileHandle

    EEXIST: file already exists, open '/foo'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate.<anonymous> (src/volume.ts:695:33)

FAIL src/__tests__/volume/closeSync.test.ts
  ● .closeSync(fd) › Closing same file descriptor twice throws EBADF

    EEXIST: file already exists, open '/test.txt'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.openSync (src/volume.ts:869:21)
      at Object.<anonymous> (src/__tests__/volume/closeSync.test.ts:32:22)

  ● .closeSync(fd) › Closing a file decreases the number of open files

    EEXIST: file already exists, open '/test.txt'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.openSync (src/volume.ts:869:21)
      at Object.<anonymous> (src/__tests__/volume/closeSync.test.ts:43:22)

  ● .closeSync(fd) › When closing a file, its descriptor is added to the pool of descriptors to be reused

    EEXIST: file already exists, open '/test.txt'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.openSync (src/volume.ts:869:21)
      at Object.<anonymous> (src/__tests__/volume/closeSync.test.ts:49:22)

FAIL src/__tests__/volume/WriteStream.test.ts (5.046 s)
  ● WriteStream › Can write basic file

    Unhandled error. (Error: EEXIST: file already exists, open '/a'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Immediate._onImmediate (src/volume.ts:695:33)
      at processImmediate (node:internal/timers:483:21) {
        code: 'EEXIST'
      })
      at class_2.<anonymous> (src/volume.ts:2114:18)
      at Immediate.<anonymous> (src/volume.ts:698:17)

  ● WriteStream › Can write basic file

    thrown: "Exceeded timeout of 5000 ms for a test.
    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test."

      12 |   });
      13 |   it('Can write basic file', done => {
    > 14 |     const fs = createFs({ '/a': 'b' });
         |     ^
      15 |     const ws = new fs.WriteStream('/a', 'utf8');
      16 |     ws.end('d');
      17 |     ws.on('finish', () => {

      at src/__tests__/volume/WriteStream.test.ts:14:5
      at Object.<anonymous> (src/__tests__/volume/WriteStream.test.ts:4:1)

FAIL src/__tests__/volume/appendFileSync.test.ts
  ● appendFileSync(file, data, options) › Append to existing file

    EEXIST: file already exists, open '/a'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.writeFileBase (src/volume.ts:1089:23)
      at Volume.Object.<anonymous>.Volume.writeFileSync (src/volume.ts:1114:14)
      at Volume.Object.<anonymous>.Volume.appendFileSync (src/volume.ts:1402:14)
      at Object.<anonymous> (src/__tests__/volume/appendFileSync.test.ts:12:13)

FAIL src/__tests__/volume/callback-error.test.ts
  ● Test suite failed to run

    TypeError: Cannot assign to read only property 'performance' of object '[object global]'

    > 1 | jest.useFakeTimers('modern');
        |                          ^
      2 |
      3 | // Fixes https://github.com/streamich/memfs/issues/542
      4 | it('should throw error instead of callback', () => {

      at hijackMethod (node_modules/@sinonjs/fake-timers/src/fake-timers-src.js:946:32)
      at Object.install (node_modules/@sinonjs/fake-timers/src/fake-timers-src.js:1733:17)
      at FakeTimers.useFakeTimers (node_modules/@jest/fake-timers/build/modernFakeTimers.js:110:36)
      at Object.<anonymous> (src/__tests__/volume/callback-error.test.ts:1:26)

FAIL src/__tests__/volume.test.ts (17.028 s)
  ● volume › Volume › .fromJSON(json[, cwd]) › Invalid JSON throws error

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      219 |           '/dir/dir/dir2/hello.sh': 'world',
      220 |           '/hello.js': 'console.log(123)',
    > 221 |           '/dir/dir/test.txt': 'Windows',
          |                                          ^
      222 |         };
      223 |         vol.fromJSON(json);
      224 |         expect(vol.toJSON()).toEqual(json);

      at Object.<anonymous> (src/__tests__/volume.test.ts:221:81)

  ● volume › Volume › .statSync(path) › Modification new write

    EEXIST: file already exists, open '/mtime.txt'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.writeFileBase (src/volume.ts:1089:23)
      at Volume.Object.<anonymous>.Volume.writeFileSync (src/volume.ts:1114:14)
      at Timeout._onTimeout (src/__tests__/volume.test.ts:790:25)

  ● volume › Volume › .statSync(path) › Modification new write

    thrown: "Exceeded timeout of 5000 ms for a test.
    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test."

      784 |       it('Returns basic file stats', () => {
      785 |         const stats = vol.statSync('/dojo.js');
    > 786 |         expect(stats).toBeInstanceOf(Stats);
          |             ^
      787 |         expect(stats.size).toBe(data.length);
      788 |         expect(stats.isFile()).toBe(true);
      789 |         expect(stats.isDirectory()).toBe(false);

      at src/__tests__/volume.test.ts:786:13
      at src/__tests__/volume.test.ts:758:9
      at src/__tests__/volume.test.ts:31:5
      at Object.<anonymous> (src/__tests__/volume.test.ts:10:1)

  ● volume › Volume › .watchFile(path[, options], listener) › Calls listener on .writeFile

    EEXIST: file already exists, open '/lol.txt'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.writeFileBase (src/volume.ts:1089:23)
      at Volume.Object.<anonymous>.Volume.writeFileSync (src/volume.ts:1114:14)
      at Timeout._onTimeout (src/__tests__/volume.test.ts:1058:25)

  ● volume › Volume › .watchFile(path[, options], listener) › Calls listener on .writeFile

    thrown: "Exceeded timeout of 5000 ms for a test.
    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test."

      1046 |         expect(!!vol.root.getChild('dir')).toBe(false);
      1047 |       });
    > 1048 |       it('Remove dir /dir1/dir2/dir3 recursively', () => {
           |             ^
      1049 |         const vol = new Volume();
      1050 |         vol.mkdirSync('/dir1/dir2/dir3', { recursive: true });
      1051 |         vol.rmdirSync('/dir1', { recursive: true });

      at src/__tests__/volume.test.ts:1048:13
      at src/__tests__/volume.test.ts:1047:9
      at src/__tests__/volume.test.ts:31:5
      at Object.<anonymous> (src/__tests__/volume.test.ts:10:1)

  ● volume › Volume › .unwatchFile(path[, listener]) › Stops watching before .writeFile

    EEXIST: file already exists, open '/lol.txt'

      126 |     case EACCES:
      127 |       return `EACCES: permission denied, ${func}${pathFormatted}`;
    > 128 |     case ENOTEMPTY:
          |                 ^
      129 |       return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
      130 |     case EMFILE:
      131 |       return `EMFILE: too many open files, ${func}${pathFormatted}`;

      at createError (src/volume.ts:128:17)
      at Volume.Object.<anonymous>.Volume.openFile (src/volume.ts:840:19)
      at Volume.Object.<anonymous>.Volume.openBase (src/volume.ts:858:25)
      at Volume.Object.<anonymous>.Volume.writeFileBase (src/volume.ts:1089:23)
      at Volume.Object.<anonymous>.Volume.writeFileSync (src/volume.ts:1114:14)
      at Timeout._onTimeout (src/__tests__/volume.test.ts:1073:25)

  ● volume › Volume › .unwatchFile(path[, listener]) › Stops watching before .writeFile

    thrown: "Exceeded timeout of 5000 ms for a test.
    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test."

      1062 |           done();
      1063 |         });
    > 1064 |       });
           |          ^
      1065 |     });
      1066 |     describe('.watchFile(path[, options], listener)', () => {
      1067 |       it('Calls listener on .writeFile', done => {

      at src/__tests__/volume.test.ts:1064:13
      at src/__tests__/volume.test.ts:1063:9
      at src/__tests__/volume.test.ts:31:5
      at Object.<anonymous> (src/__tests__/volume.test.ts:10:1)


Test Suites: 7 failed, 24 passed, 31 total
Tests:       24 failed, 19 skipped, 276 passed, 319 total
Snapshots:   6 passed, 6 total
Time:        17.927 s
Ran all test suites.
