{"files":{"src/matcher.ts":{"language":"typescript","mutants":[{"id":"0","mutatorName":"PrecomputedMutator","replacement":"spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● rule › matches paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new\n Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (t\nest/policy.ts:120:26)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (1 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✕ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly (1 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains invalid characters\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with invalid characters\n\n    expected path spec '/ ' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher \n› compiles combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:6\n54:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       30 failed, 8 passed, 38 total\nSnapshots:   0 total\nTime:        1.883 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":55,"line":12},"start":{"column":9,"line":12}}},{"id":"1","mutatorName":"PrecomputedMutator","replacement":"spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0","status":"Survived","testsCompleted":1,"location":{"end":{"column":55,"line":12},"start":{"column":9,"line":12}}},{"id":"2","mutatorName":"PrecomputedMutator","replacement":"spec.search","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✕ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with invalid characters\n\n    expected path spec '/ ' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.802 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":12},"start":{"column":9,"line":12}}},{"id":"3","mutatorName":"PrecomputedMutator","replacement":"spec.replace","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (2 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✕ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › rejects paths with invalid characters\n\n    expected path spec '/ ' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.53 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":12},"start":{"column":9,"line":12}}},{"id":"4","mutatorName":"PrecomputedMutator","replacement":"spec.split","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (5 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (1 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✕ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects paths with invalid characters\n\n    expected path spec '/ ' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.55 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":12},"start":{"column":9,"line":12}}},{"id":"5","mutatorName":"PrecomputedMutator","replacement":"/^[a-zA-Z0-9_/:~.$+*-]+$/","status":"Survived","testsCompleted":1,"location":{"end":{"column":45,"line":12},"start":{"column":20,"line":12}}},{"id":"6","mutatorName":"PrecomputedMutator","replacement":"/^[a-zA-Z0-9_/:~.$+*-]{0}$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (1 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains invalid characters\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$\n+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.\nreplace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains invalid characters\n\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n      58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n    > 59 |       throw new Error('Path contains invalid characters');\n         |             ^\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n      62 |       throw new Error('Path must begin with a slash');\n\n      at new Matcher (src/matcher.ts:59:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.612 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":12},"start":{"column":20,"line":12}}},{"id":"7","mutatorName":"PrecomputedMutator","replacement":"spec.split","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✕ rejects empty paths (1 ms)\n    ✕ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects empty paths\n\n    expected path spec '' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths without leading slashes\n\n    expected path spec '+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.574 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":15},"start":{"column":9,"line":15}}},{"id":"8","mutatorName":"PrecomputedMutator","replacement":"spec.search","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✕ rejects empty paths\n    ✕ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › rejects empty paths\n\n    expected path spec '' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths without leading slashes\n\n    expected path spec '+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.583 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":15},"start":{"column":9,"line":15}}},{"id":"9","mutatorName":"PrecomputedMutator","replacement":"spec.replace","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✕ rejects empty paths (1 ms)\n    ✕ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › rejects empty paths\n\n    expected path spec '' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths without leading slashes\n\n    expected path spec '+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.587 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":15},"start":{"column":9,"line":15}}},{"id":"10","mutatorName":"PrecomputedMutator","replacement":"spec.search","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains empty segments\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\\n//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n   \n   64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.526 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":18},"start":{"column":9,"line":18}}},{"id":"11","mutatorName":"PrecomputedMutator","replacement":"spec.replace","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains empty segments\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\\n//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n   \n   64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.727 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":18},"start":{"column":9,"line":18}}},{"id":"12","mutatorName":"PrecomputedMutator","replacement":"spec.split","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains empty segments\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\\n//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains empty segments\n\n      63 |     }\n   \n   64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains empty segments\n\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n    > 65 |       throw new Error('Path contains empty segments');\n         |             ^\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n      68 |       throw new Error('Path contains malformed wildcards');\n\n      at new Matcher (src/matcher.ts:65:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.618 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":18},"start":{"column":9,"line":18}}},{"id":"13","mutatorName":"PrecomputedMutator","replacement":"spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : \nstryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\\n+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (2 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✕ rejects paths with malformed wildcards (1 ms)\n    ✕ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n      ✕ rejects specs with match-one-or-none wildcards\n\n      ✕ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains malformed wildcards\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with malformed wildcards\n\n    expected path spec '/foo+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:foo+' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-non\ne wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(vers\nion === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › when using version 1 › rejects specs with match-one-or-none wildcards\n\n    expected path spec '/++' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher\n.ts:619:11)\n\n  ● matcher › when using version 1 › rejects specs with match-many-or-none wildcards\n\n    expected path spec '/**' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 4 failed, 4 total\nTests:       33 failed, 5 passed, 38 total\nSnapshots:   0 total\nTime:        1.714 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":66,"line":23},"start":{"column":9,"line":21}}},{"id":"14","mutatorName":"PrecomputedMutator","replacement":"spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\\n+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : \nstryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly\n\n    ✕ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (1 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (2 ms)\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains malformed wildcards\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\n\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|\n:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed wildcards\n\n      66 |     }\n      67 |     if (stryMutAct_9fa48(\"14\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== undefined : stryMutAct_9fa48(\"13\") ? spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) === null : (stryCov_9fa48(\"13\", \"14\"), spec.match(version === '1' || version === '1.0' ? /[*+][^/]|[^/][*+]/ : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null)) {\n    > 68 |       throw new Error('Path contains malformed wildcards');\n         |             ^\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n      71 |       throw new Error('Path contains malformed captures');\n\n      at new Matcher (src/matcher.ts:68:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.852 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":66,"line":23},"start":{"column":9,"line":21}}},{"id":"15","mutatorName":"PrecomputedMutator","replacement":"spec.match(/[^/]:|:\\/|:$/) === null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✕ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains malformed captures\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stry\nMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]\n:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/\n]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nTest Suites: 4 failed, 4 total\nTests:       30 failed, 8 passed, 38 total\nSnapshots:   0 total\nTime:        1.68 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":44,"line":26},"start":{"column":9,"line":26}}},{"id":"16","mutatorName":"PrecomputedMutator","replacement":"spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === ''","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✕ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (3 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n  ● matcher › rejects paths with malformed captures\n\n    expected path spec '/:' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        1.644 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":44,"line":26},"start":{"column":9,"line":26}}},{"id":"17","mutatorName":"PrecomputedMutator","replacement":"spec.search","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"2\n0\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]\n:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (1 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains malformed captures\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.t\ns:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/\n) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.721 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":26},"start":{"column":9,"line":26}}},{"id":"18","mutatorName":"PrecomputedMutator","replacement":"spec.replace","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/rule.ts\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/\n|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly (3 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains malformed captures\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.t\ns:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/\n) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|\n:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        2.107 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":26},"start":{"column":9,"line":26}}},{"id":"19","mutatorName":"PrecomputedMutator","replacement":"spec.split","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path contains malformed captures\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.t\ns:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/\n) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"2\n0\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/rule.ts\n  rule\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\n\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path contains malformed captures\n\n      69 |     }\n      70 |     if (stryMutAct_9fa48(\"16\") ? spec.match(/[^/]:|:\\/|:$/) !== null && spec.match(/[^/]:|:\\/|:$/)[0] === '' : stryMutAct_9fa48(\"15\") ? spec.match(/[^/]:|:\\/|:$/) === null : (stryCov_9fa48(\"15\", \"16\"), (stryMutAct_9fa48(\"19\") ? spec.split(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"18\") ? spec.replace(/[^/]:|:\\/|:$/) : stryMutAct_9fa48(\"17\") ? spec.search(/[^/]:|:\\/|:$/) : (stryCov_9fa48(\"17\", \"18\", \"19\"), spec.match(stryMutAct_9fa48(\"22\") ? /[^/]:|:\\/|:$/m : stryMutAct_9fa48(\"21\") ? /[^/]:|:\\/|:$/i : stryMutAct_9fa48(\"20\") ? /[^/]:|:\\/|:$/g : (stryCov_9fa48(\"20\", \"21\", \"22\"), /[^/]:|:\\/|:$/)))) !== null)) {\n    > 71 |       throw new Error('Path contains malformed captures');\n         |             ^\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n      74 |       throw new Error('Path must not end with a slash');\n\n      at new Matcher (src/matcher.ts:71:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.843 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":26},"start":{"column":9,"line":26}}},{"id":"20","mutatorName":"PrecomputedMutator","replacement":"/[^/]:|:\\/|:$/g","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":26},"start":{"column":20,"line":26}}},{"id":"21","mutatorName":"PrecomputedMutator","replacement":"/[^/]:|:\\/|:$/i","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":26},"start":{"column":20,"line":26}}},{"id":"22","mutatorName":"PrecomputedMutator","replacement":"/[^/]:|:\\/|:$/m","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":26},"start":{"column":20,"line":26}}},{"id":"23","mutatorName":"PrecomputedMutator","replacement":"spec.match(/^.+\\/$/) === null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✕ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path must not end with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with trailing slashes\n\n    expected path spec '/+/' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (\nsrc/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nTest Suites: 4 failed, 4 total\nTests:       30 failed, 8 passed, 38 total\nSnapshots:   0 total\nTime:        1.814 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":29},"start":{"column":9,"line":29}}},{"id":"24","mutatorName":"PrecomputedMutator","replacement":"spec.match(/^.+$/) !== null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path must not end with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\"\n) ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.827 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":29},"start":{"column":9,"line":29}}},{"id":"25","mutatorName":"PrecomputedMutator","replacement":"spec.search","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (8 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (1 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (2 ms)\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Path must not end with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path must not end w\nith a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.837 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":19,"line":29},"start":{"column":9,"line":29}}},{"id":"26","mutatorName":"PrecomputedMutator","replacement":"/^.+[a-z]$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✕ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly (2 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (2 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/+/foo' to be accepted: Path must not end with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with trailing slashes\n\n    expected path spec '/+/' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at\n Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:103:17)\n\n  ● policy › clones itself correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.875 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":29},"start":{"column":20,"line":29}}},{"id":"27","mutatorName":"PrecomputedMutator","replacement":"/^.+[0-9]$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (2 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✕ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/0123456789' to be accepted: Path must not end with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with trailing slashes\n\n    expected path spec '/+/' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.855 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":29},"start":{"column":20,"line":29}}},{"id":"28","mutatorName":"PrecomputedMutator","replacement":"/^.+[a-z0-9]$/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✕ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/+/foo' to be accepted: Path must not end with a slash\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › rejects paths with trailing slashes\n\n    expected path spec '/+/' to be rejected\n\n      619 |     specs.forEach((spec) => {\n      620 |       if (!itThrows(() => Matcher.for(spec, version))) {\n    > 621 |         throw Error(`expected path spec '${spec}' to be rejected`)\n          |               ^\n      622 |       }\n      623 |     })\n      624 |   })\n\n      at test/matcher.ts:621:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:619:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at\n Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:103:17)\n\n  ● policy › clones itself correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    Path must not end with a slash\n\n      72 |     }\n      73 |     if (stryMutAct_9fa48(\"24\") ? spec.match(/^.+$/) !== null : stryMutAct_9fa48(\"23\") ? spec.match(/^.+\\/$/) === null : (stryCov_9fa48(\"23\", \"24\"), (stryMutAct_9fa48(\"25\") ? spec.search(/^.+\\/$/) : (stryCov_9fa48(\"25\"), spec.match(stryMutAct_9fa48(\"28\") ? /^.+[a-z0-9]$/ : stryMutAct_9fa48(\"27\") ? /^.+[0-9]$/ : stryMutAct_9fa48(\"26\") ? /^.+[a-z]$/ : (stryCov_9fa48(\"26\", \"27\", \"28\"), /^.+\\/$/)))) !== null)) {\n    > 74 |       throw new Error('Path must not end with a slash');\n         |             ^\n      75 |     }\n      76 |     const {\n      77 |       regex,\n\n      at new Matcher (src/matcher.ts:74:13)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.837 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":29},"start":{"column":20,"line":29}}},{"id":"29","mutatorName":"PrecomputedMutator","replacement":"'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (5 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (4 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (1 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (3 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), \nexpected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.836 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":42,"line":32},"start":{"column":38,"line":32}}},{"id":"30","mutatorName":"PrecomputedMutator","replacement":"'spec'.replace(/^/, '')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (5 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters (7 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (4 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         con\nst [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.85 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":42,"line":32},"start":{"column":38,"line":32}}},{"id":"31","mutatorName":"PrecomputedMutator","replacement":"string.length > 0 && string.endsWith('/')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (3 ms)\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        1.783 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":50,"line":39},"start":{"column":9,"line":39}}},{"id":"32","mutatorName":"PrecomputedMutator","replacement":"string.length > 1 && string.endsWith('/') && string.charAt(0) === '/'","status":"Survived","testsCompleted":1,"location":{"end":{"column":50,"line":39},"start":{"column":9,"line":39}}},{"id":"33","mutatorName":"PrecomputedMutator","replacement":"string.startsWith","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly (1 ms)\n    ✕ matches literal path segments correctly (9 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (5 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        1.839 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":39},"start":{"column":30,"line":39}}},{"id":"34","mutatorName":"PrecomputedMutator","replacement":"string.indexOf","status":"Survived","testsCompleted":1,"location":{"end":{"column":45,"line":39},"start":{"column":30,"line":39}}},{"id":"35","mutatorName":"PrecomputedMutator","replacement":"string.lastIndexOf","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for rule '/*/*'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:27:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✕ matches literal path segments correctly (7 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/bar' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++/++' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a/:b' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       12 failed, 26 passed, 38 total\nSnapshots:   0 total\nTime:        1.904 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":39},"start":{"column":30,"line":39}}},{"id":"36","mutatorName":"PrecomputedMutator","replacement":"'\\\\'","status":"Survived","testsCompleted":1,"location":{"end":{"column":49,"line":39},"start":{"column":46,"line":39}}},{"id":"37","mutatorName":"PrecomputedMutator","replacement":"'*'","status":"Survived","testsCompleted":1,"location":{"end":{"column":49,"line":39},"start":{"column":46,"line":39}}},{"id":"38","mutatorName":"PrecomputedMutator","replacement":"'\\\\/'","status":"Survived","testsCompleted":1,"location":{"end":{"column":49,"line":39},"start":{"column":46,"line":39}}},{"id":"39","mutatorName":"PrecomputedMutator","replacement":"string.substring(0, 1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (9 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (4 ms)\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**/**' to not match '//foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        1.811 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":42},"start":{"column":32,"line":42}}},{"id":"40","mutatorName":"PrecomputedMutator","replacement":"string.split('/').reverse()[0]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (6 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (2 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✕ matches literal path segments correctly (2 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        1.862 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":42},"start":{"column":32,"line":42}}},{"id":"41","mutatorName":"PrecomputedMutator","replacement":"max > 1 || any","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✕ compiles match-one wildcard segments correctly (3 ms)\n    ✓ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (7 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       11 failed, 27 passed, 38 total\nSnapshots:   0 total\nTime:        1.831 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":64},"start":{"column":9,"line":64}}},{"id":"42","mutatorName":"PrecomputedMutator","replacement":"any && max > 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (6 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (3 ms)\n\n    ✕ compiles match-many wildcard segments correctly (2 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/([^/]+)\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== nu\nll), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       18 failed, 20 passed, 38 total\nSnapshots:   0 total\nTime:        2.424 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":64},"start":{"column":9,"line":64}}},{"id":"43","mutatorName":"PrecomputedMutator","replacement":"max > 0 && any","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('dynamic', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (4 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (3 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/([^/]+)\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n \n     659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/:a/*/:b' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       18 failed, 20 passed, 38 total\nSnapshots:   0 total\nTime:        1.821 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":64},"start":{"column":9,"line":64}}},{"id":"44","mutatorName":"PrecomputedMutator","replacement":"final && !opt && min < 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (3 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (7 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.855 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":65},"start":{"column":11,"line":65}}},{"id":"45","mutatorName":"PrecomputedMutator","replacement":"final && opt && min < 2","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (3 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✕ compiles match-one wildcard segments correctly (6 ms)\n    ✕ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.857 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":65},"start":{"column":11,"line":65}}},{"id":"46","mutatorName":"PrecomputedMutator","replacement":"final && opt && min > 1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (4 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2,}$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/+/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2,}$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/*/*'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:27:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        1.848 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":65},"start":{"column":11,"line":65}}},{"id":"47","mutatorName":"PrecomputedMutator","replacement":"min < 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✕ compiles match-one wildcard segments correctly (2 ms)\n\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (6 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.927 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":25,"line":67},"start":{"column":18,"line":67}}},{"id":"48","mutatorName":"PrecomputedMutator","replacement":"max < 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (6 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✕ compiles match-one wildcard segments correctly (5 ms)\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (3 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        1.968 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":25,"line":67},"start":{"column":18,"line":67}}},{"id":"49","mutatorName":"PrecomputedMutator","replacement":"min === max","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n  rule\n\n    ✕ matches paths correctly (6 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/*/*'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:27:5)\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (3 ms)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (4 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2,}$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+){2,}$\"\n\n    Message:\n      path spec '/+/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2,}$\n    + ^\\/$|^(?:\\/[^/]+){2,}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.902 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":25,"line":67},"start":{"column":18,"line":67}}},{"id":"50","mutatorName":"PrecomputedMutator","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (4 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.865 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":17,"line":89},"start":{"column":13,"line":89}}},{"id":"51","mutatorName":"PrecomputedMutator","replacement":"0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (8 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (4 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (5 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.851 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":17,"line":89},"start":{"column":13,"line":89}}},{"id":"52","mutatorName":"PrecomputedMutator","replacement":"null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (4 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        1.895 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":17,"line":89},"start":{"column":13,"line":89}}},{"id":"53","mutatorName":"PrecomputedMutator","replacement":"parts.reduce((acc, seg) => seg + acc, '')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (5 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/yeah/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (8 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly (2 ms)\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match '/food'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match \n'${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*/bar' to not match '/foo/bar/boo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**/boo' to not match '/boo/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+/+' to not match '/foo/bar/boo/baz'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       19 failed, 19 passed, 38 total\nSnapshots:   0 total\nTime:        1.844 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":78,"line":90},"start":{"column":36,"line":90}}},{"id":"54","mutatorName":"PrecomputedMutator","replacement":"parts.reduce((acc, seg) => acc + seg, '\\\\')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    SyntaxError: Invalid regular expression: /^\\(?:/[^/]+)+/: Unmatched ')'\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:60:17)\n\n  ● policy › prioritises deny over allow\n\n    SyntaxError: Invalid regular expression: /^\\(?:/[^/]+)+/: Unmatched ')'\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (2 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (2 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/+/+' to be accepted: Invalid regular expression: /^\\(?:/[^/]+){2}/: Unmatched ')'\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^\\(?:/[^/]+)+/: Unmatched ')'\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^\\(?:/[^/]+)+/: Unmatched ')'\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match '/food'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^\\(?:/[^/]+)+/: Unmatched ')'\n       \n at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^\\(?:/[^/]+)+/: Unmatched ')'\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^\\(?:/[^/]+){2,}/: Unmatched ')'\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       22 failed, 16 passed, 38 total\nSnapshots:   0 total\nTime:        2.012 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":78,"line":90},"start":{"column":36,"line":90}}},{"id":"55","mutatorName":"PrecomputedMutator","replacement":"(acc, seg) => seg - acc","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (2 ms)\n    ✕ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (5 ms)\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^NaN\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^NaN\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^NaN\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^NaN\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^NaN\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^NaN\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^NaN\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^NaN\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |      \n              ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.791 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":72,"line":90},"start":{"column":49,"line":90}}},{"id":"56","mutatorName":"PrecomputedMutator","replacement":"(acc, seg) => seg + '(' + acc + ')'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (4 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (4 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/($)\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/($)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+($)\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+($)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+($)\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+($)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+($)\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+($)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+($)\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+($)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+($)\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+($)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)($)\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)($)\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"\"]\n\n    Message:\n      path spec '/foo' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"\"]\n\n    Message:\n      path spec '/+' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    R\neceived:\n      [\"\"]\n\n    Message:\n      path spec '/*' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [undefined]\n\n    Message:\n      path spec '/++' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   undefined,\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [undefined]\n\n    Message:\n      path spec '/**' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   undefined,\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"\"]\n\n    Message:\n      path spec '/+/*' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\"]\n    Received:\n      [\"foo\", \"\"]\n\n    Message:\n      path spec '/:a' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n        \"foo\",\n    +   \"\",\n      ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       17 failed, 21 passed, 38 total\nSnapshots:   0 total\nTime:        2.017 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":72,"line":90},"start":{"column":49,"line":90}}},{"id":"57","mutatorName":"PrecomputedMutator","replacement":"(acc, seg) => seg + '|' + acc","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (23 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (2 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly (1 ms)\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/|$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/|$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+|$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+|$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+|$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+|$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+|$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+|$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+|$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+|$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+|$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+|$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)|$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)|$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const\n match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       22 failed, 16 passed, 38 total\nSnapshots:   0 total\nTime:        1.802 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":72,"line":90},"start":{"column":49,"line":90}}},{"id":"58","mutatorName":"PrecomputedMutator","replacement":"'#'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (4 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (4 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/#\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/#\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+#\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+#\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+#\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+#\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^\\\\/[^/]+#\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^\\/[^/]+#\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+#\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^(?:\\/[^/]+)+#\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+#\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/[^/]+#\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)#\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)#\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value\n.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.819 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":77,"line":90},"start":{"column":74,"line":90}}},{"id":"59","mutatorName":"PrecomputedMutator","replacement":"'*'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● rule › matches paths correctly\n\n    SyntaxError: Invalid regular expression: /^/[^/]+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:20:21)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    SyntaxError: Invalid regular expression: /^/nah/[^/]+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:18:17)\n\n  ● policymap › answers queries correctly\n\n    SyntaxError: Invalid regular expression: /^/nah/[^/]+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:59:17)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✕ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    SyntaxError: Invalid regular expression: /^/nah/[^/]+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:22:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    SyntaxError: Invalid regular expression: /^(?:/[^/]+)+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:60:17)\n\n  ● policy › prioritises deny over allow\n\n    SyntaxError: Invalid regular expression: /^(?:/[^/]+)+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (2 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/+' to be accepted: Invalid regular expression: /^/[^/]+*/: Nothing to repeat\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/*\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/*\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/[^/]+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^(?:/[^/]+)+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^/[^/]+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^(?:/[^/]+)+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/[^/]+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)*\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)*\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match '/fo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/[^/]+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^(?:/[^/]+)+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n\n    SyntaxError: Invalid regular expression: /^/$|^/[^/]+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^(?:/[^/]+)+*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^(?:/[^/]+){2,}*/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       22 failed, 16 passed, 38 total\nSnapshots:   0 total\nTime:        1.806 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":77,"line":90},"start":{"column":74,"line":90}}},{"id":"60","mutatorName":"PrecomputedMutator","replacement":"'\\\\'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    SyntaxError: Invalid regular expression: /^/yeah\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:21:17)\n\n  ● policy › matches context-dependent paths correctly\n\n    SyntaxError: Invalid regular expression: /^/([^/]+)\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:34:17)\n\n  ● policy › answers queries correctly\n\n    SyntaxError: Invalid regular expression: /^/foo\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:58:17)\n\n  ● policy › answers context-dependent queries correctly\n\n    SyntaxError: Invalid regular expression: /^/([^/]+)\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:80:17)\n\n  ● policy › prioritises deny over allow\n\n    SyntaxError: Invalid regular expression: /^(?:/[^/]+)+\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:102:17)\n\n  ● policy › clones itself correctly\n\n    SyntaxError: Invalid regular expression: /^/test\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policy.ts:120:26)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (1 ms)\n\n    ✕ answers queries correctly\n\n\n\n  ● policymap › matches queries correctly\n\n    SyntaxError: Invalid regular expression: /^/yeah\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:14:17)\n\n  ● policymap › answers queries correctly\n\n    SyntaxError: Invalid regular expression: /^/nah\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/policymap.ts:53:17)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (1 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    SyntaxError: Invalid regular expression: /^/yeah\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:12:21)\n\n  ● rule › matches context-dependent paths correctly\n\n    SyntaxError: Invalid regular expression: /^/([^/]+)\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:38:21)\n\n  ● rule › answers queries correctly\n\n    SyntaxError: Invalid regular expression: /^/test\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:59:13)\n\n  ● rule › answers context-dependent queries correctly\n\n    SyntaxError: Invalid regular expression: /^/([^/]+)\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:75:13)\n\n  ● rule › prioritises deny over allow\n\n    SyntaxError: Invalid regular expression: /^/test\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:105:13)\n\n  ● rule › clones itself correctly\n\n    SyntaxError: Invalid regular expression: /^/nah\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at new Rule (src/rule.ts:64:51)\n      at Function.for (src/rule.ts:191:12)\n      at Object.<anonymous> (test/rule.ts:121:13)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✕ accepts valid paths (1 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (1 ms)\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/' to be accepted: Invalid regular expression: /^/\\/: \\ at end of pattern\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles literal path segments correctly\n\n    SyntaxError: Invalid regular expression: /^/\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/[^/]+\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^(?:/[^/]+)+\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^/[^/]+\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^(?:/[^/]+)+\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/[^/]+\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    SyntaxError: Invalid regular expression: /^/([^/]+)\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    SyntaxError: Invalid regular expression: /^/foo\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/[^/]+\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^(?:/[^/]+)+\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^/[^/]+\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 \n|     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/$|^(?:/[^/]+)+\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^(?:/[^/]+){2,}\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches capture segments correctly\n\n    SyntaxError: Invalid regular expression: /^/([^/]+)\\/: \\ at end of pattern\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n\nTest Suites: 4 failed, 4 total\nTests:       29 failed, 9 passed, 38 total\nSnapshots:   0 total\nTime:        1.829 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":77,"line":90},"start":{"column":74,"line":90}}},{"id":"61","mutatorName":"PrecomputedMutator","replacement":"for (const part of spec.split('/').slice(2).reverse()) {\n  switch (part) {\n    case '+':\n      min++;\n      max++;\n      break;\n    case '++':\n      max++;\n      break;\n    case '*':\n      min++;\n      any = true;\n      break;\n    case '**':\n      any = true;\n      break;\n    default:\n      flatten();\n      opt = false;\n      if (part.match(/:.+/) !== null) {\n        props.push(part.slice(1));\n        parts.push('/([^/]+)');\n      } else {\n        parts.push(`/${part.replace(/([.$])/g, '\\\\$1')}`);\n      }\n  }\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (6 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (10 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (1 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (4 ms)\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), \nexpected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.809 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":118},"start":{"column":3,"line":92}}},{"id":"62","mutatorName":"PrecomputedMutator","replacement":"for (const part of spec.split('/').slice(1).reverse().join('')) {\n  switch (part) {\n    case '+':\n      min++;\n      max++;\n      break;\n    case '++':\n      max++;\n      break;\n    case '*':\n      min++;\n      any = true;\n      break;\n    case '**':\n      any = true;\n      break;\n    default:\n      flatten();\n      opt = false;\n      if (part.match(/:.+/) !== null) {\n        props.push(part.slice(1));\n        parts.push('/([^/]+)');\n      } else {\n        parts.push(`/${part.replace(/([.$])/g, '\\\\$1')}`);\n      }\n  }\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (3 ms)\n\n    ✕ clones itself correctly (2 ms)\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/matcher.ts\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (4 ms)\n    ✕ compiles match-one wildcard segments correctly (6 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/o\\\\/o\\\\/f$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+\\/o\\/o\\/f$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/o\\\\/o\\\\/f$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+\\/o\\/o\\/f$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+){2}$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^(?:\\/[^/]+){2}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+){2,}$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+){2,}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/o\\\\/o\\\\/f\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^\\/[^/]+\\/o\\/o\\/f\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/o\\\\/o\\\\/f\\\\/:$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/o\\/o\\/f\\/:$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n\n    Message:\n      expected path spec '/foo/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       27 failed, 11 passed, 38 total\nSnapshots:   0 total\nTime:        1.897 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":4,"line":118},"start":{"column":3,"line":92}}},{"id":"63","mutatorName":"PrecomputedMutator","replacement":"for (const part of spec.split('/').slice(1).reverse().map(p => p.toLowerCase())) {\n  switch (part) {\n    case '+':\n      min++;\n      max++;\n      break;\n    case '++':\n      max++;\n      break;\n    case '*':\n      min++;\n      any = true;\n      break;\n    case '**':\n      any = true;\n      break;\n    default:\n      flatten();\n      opt = false;\n      if (part.match(/:.+/) !== null) {\n        props.push(part.slice(1));\n        parts.push('/([^/]+)');\n      } else {\n        parts.push(`/${part.replace(/([.$])/g, '\\\\$1')}`);\n      }\n  }\n}","status":"Survived","testsCompleted":1,"location":{"end":{"column":4,"line":118},"start":{"column":3,"line":92}}},{"id":"64","mutatorName":"PrecomputedMutator","replacement":"spec.split('/').slice(2).reverse()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (21 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (3 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (2 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly (2 ms)\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), \nexpected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.835 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":92},"start":{"column":22,"line":92}}},{"id":"65","mutatorName":"PrecomputedMutator","replacement":"spec.split('/').slice(1).reverse().join('')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (3 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (1 ms)\n\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ matches match-many-or-none wildcard segments correctly (2 ms)\n\n    ✕ matches combinations of wildcard segments correctly (3 ms)\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/o\\\\/o\\\\/f$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+\\/o\\/o\\/f$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/o\\\\/o\\\\/f$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+\\/o\\/o\\/f$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^(?:\\\\/[^/]+){2}$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^(?:\\/[^/]+){2}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+){2,}$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+){2,}$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/o\\\\/o\\\\/f\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^\\/[^/]+\\/o\\/o\\/f\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/o\\\\/o\\\\/f\\\\/:$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/o\\/o\\/f\\/:$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n\n    Message:\n      expected path spec '/foo/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       27 failed, 11 passed, 38 total\nSnapshots:   0 total\nTime:        1.819 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":92},"start":{"column":22,"line":92}}},{"id":"66","mutatorName":"PrecomputedMutator","replacement":"spec.split('/').slice(1).reverse().map(part => part.replace(/[a-zA-Z0-9_]/g, ''))","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (3 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly (5 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo$\"\n    Received:\n      \"^\\\\/$\"\n\n    Message:\n      path spec '/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo$\n    + ^\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?\\\\/$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^(?:\\/[^/]+)?\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)*\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^\\/[^/]+\\/\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/:$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/:$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/*'\n to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/++' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/**' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       26 failed, 12 passed, 38 total\nSnapshots:   0 total\nTime:        1.815 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":92},"start":{"column":22,"line":92}}},{"id":"67","mutatorName":"PrecomputedMutator","replacement":"'\\\\'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (7 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (4 ms)\n    ✕ compiles match-one wildcard segments correctly\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), \nexpected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.807 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":36,"line":92},"start":{"column":33,"line":92}}},{"id":"68","mutatorName":"PrecomputedMutator","replacement":"'/' + '\\\\'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (6 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly (2 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), \nexpected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.828 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":36,"line":92},"start":{"column":33,"line":92}}},{"id":"69","mutatorName":"PrecomputedMutator","replacement":"'/' + '\\\\' + '\\\\'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (1 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (3 ms)\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n    ✕ matches match-many wildcard segments correctly\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/$|^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/$|^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), \nexpected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/++' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/**' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.806 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":36,"line":92},"start":{"column":33,"line":92}}},{"id":"70","mutatorName":"PrecomputedMutator","replacement":"-1","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (3 ms)\n\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (1 ms)\n\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo\\\\/bar$\"\n    Received:\n      \"^\\\\/bar$\"\n\n    Message:\n      path spec '/foo/bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo\\/bar$\n    + ^\\/bar$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/foo$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^\\\\/foo$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^\\\\/foo$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^\\\\/foo$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+){2,}$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/+/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+){2,}$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/:foo/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)\\/([^/]+)$\n    + ^\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/bar' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/+' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*/*' to not match '/foo'\n\n      65\n6 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++/++' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo/**' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/:a/:b' to not match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/*/*'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:27:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       19 failed, 19 passed, 38 total\nSnapshots:   0 total\nTime:        1.799 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":92},"start":{"column":44,"line":92}}},{"id":"71","mutatorName":"PrecomputedMutator","replacement":"NaN","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (16 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (4 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (2 ms)\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/\\\\/$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^\\/(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/*' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |     \n    const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       28 failed, 10 passed, 38 total\nSnapshots:   0 total\nTime:        1.814 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":92},"start":{"column":44,"line":92}}},{"id":"72","mutatorName":"PrecomputedMutator","replacement":"part.slice(0, -1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('dynamic', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (10 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✕ compiles match-one wildcard segments correctly (4 ms)\n\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/*$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/+\\\\/([^/]+)\\\\/*\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/+\\/([^/]+)\\/*\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |        \n            ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/:a/*/:b' to match '/foo/bar/boo/baz'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nFAIL test/rule.ts\n  rule\n\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       18 failed, 20 passed, 38 total\nSnapshots:   0 total\nTime:        1.796 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":17,"line":93},"start":{"column":13,"line":93}}},{"id":"73","mutatorName":"PrecomputedMutator","replacement":"part.length","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('dynamic', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('dynamic', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✕ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✕ compiles match-one wildcard segments correctly (3 ms)\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✕ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › accepts valid paths\n\n    expected path spec '/++' to be accepted: Invalid regular expression: /^/++$/: Nothing to repeat\n\n      609 |       } catch (err: any) {\n      610 |         /* eslint-disable-next-line @typescript-eslint/restrict-template-expressions */\n    > 611 |         throw new Error(`expected path spec '${spec}' to be accepted: ${err.message}`)\n          |               ^\n      612 |       }\n      613 |     })\n      614 |   })\n\n      at test/matcher.ts:611:15\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:606:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^\\\\/*$\"\n\n    Message:\n      path spec '/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+$\n    + ^\\/*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/++$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/**$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at test/matcher.ts:635:32\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/+$\"\n\n    Message:\n      path spec '/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+$\n    + ^\\/+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/+\\\\/([^/]+)\\\\/*\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/+\\/([^/]+)\\/*\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/*' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/++$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spec'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    SyntaxError: Invalid regular expression: /^/**$/: Nothing to repeat\n        at new RegExp (<anonymous>)\n\n      78 |       props\n      79 |     } = compile(stryMutAct_9fa48(\"30\") ? 'spec'.replace(/^/, '') : stryMutAct_9fa48(\"29\") ? 'spe\nc'.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/, '') : (stryCov_9fa48(\"29\", \"30\"), spec));\n    > 80 |     super(regex);\n         |     ^\n      81 |     this.spec = spec;\n      82 |     this.props = props;\n      83 |   }\n\n      at new Matcher (src/matcher.ts:80:5)\n      at Function.for (src/matcher.ts:95:12)\n      at Object.<anonymous> (test/matcher.ts:654:32)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/+/*' to not match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/+/:a/*/:b' to match '/foo/bar/boo/baz'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/+'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:19:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       19 failed, 19 passed, 38 total\nSnapshots:   0 total\nTime:        1.848 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":17,"line":93},"start":{"column":13,"line":93}}},{"id":"74","mutatorName":"PrecomputedMutator","replacement":"part.charAt(0)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (6 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly (2 ms)\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✕ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$|^\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$|^\\/[^/]+$\n    + ^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/**' to match '/'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/++/+' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        1.797 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":17,"line":93},"start":{"column":13,"line":93}}},{"id":"75","mutatorName":"PrecomputedMutator","replacement":"part.match(/:.+/) === null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (7 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (5 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (3 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (5 ms)\n\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly\n\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly\n    ✕ matches literal path segments correctly\n\n    ✕ matches match-one wildcard segments correctly (1 ms)\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^(?:\\/[^/]+)?\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)*\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/([^/]+)\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^\\/[^/]+\\/([^/]+)\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/:foo$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/:foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match '/fo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"foo\"]\n\n    Message:\n      path spec '/foo/+' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"foo\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.deep\nStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"foo\"]\n\n    Message:\n      path spec '/foo/*' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"foo\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"foo\"]\n\n    Message:\n      path spec '/foo/++' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"foo\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      []\n    Received:\n      [\"foo\"]\n\n    Message:\n      path spec '/foo/**' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array []\n    + Array [\n    +   \"foo\",\n    + ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       26 failed, 12 passed, 38 total\nSnapshots:   0 total\nTime:        2.068 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":39,"line":111},"start":{"column":13,"line":111}}},{"id":"76","mutatorName":"PrecomputedMutator","replacement":"part.includes(':')","status":"Survived","testsCompleted":1,"location":{"end":{"column":39,"line":111},"start":{"column":13,"line":111}}},{"id":"77","mutatorName":"PrecomputedMutator","replacement":"part.indexOf(':') !== -1","status":"Survived","testsCompleted":1,"location":{"end":{"column":39,"line":111},"start":{"column":13,"line":111}}},{"id":"78","mutatorName":"PrecomputedMutator","replacement":"/:.*/","status":"Survived","testsCompleted":1,"location":{"end":{"column":29,"line":111},"start":{"column":24,"line":111}}},{"id":"79","mutatorName":"PrecomputedMutator","replacement":"/:.{2,}/","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (11 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✕ matches capture segments correctly (2 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.086 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":29,"line":111},"start":{"column":24,"line":111}}},{"id":"80","mutatorName":"PrecomputedMutator","replacement":"/:.?/","status":"Survived","testsCompleted":1,"location":{"end":{"column":29,"line":111},"start":{"column":24,"line":111}}},{"id":"81","mutatorName":"PrecomputedMutator","replacement":"props.pop","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n  matcher\n    ✓ accepts valid paths (15 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly (2 ms)\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\"]\n    Received:\n      []\n\n    Message:\n      path spec '/:foo' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array [\n    -   \"foo\",\n    - ]\n    + Array []\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (4 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (4 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.315 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":112},"start":{"column":11,"line":112}}},{"id":"82","mutatorName":"PrecomputedMutator","replacement":"props.shift","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\nFAIL test/matcher.ts\n  matcher\n    ✓ accepts valid paths (10 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters (3 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (9 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✕ compiles capture segments correctly (5 ms)\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\"]\n    Received:\n      []\n\n    Message:\n      path spec '/:foo' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - Array [\n    -   \"foo\",\n    - ]\n    + Array []\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.184 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":112},"start":{"column":11,"line":112}}},{"id":"83","mutatorName":"PrecomputedMutator","replacement":"props.unshift","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly (3 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\", \"bar\"]\n    Received:\n      [\"bar\", \"foo\"]\n\n    Message:\n      path spec '/:foo/:bar' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"foo\",\n        \"bar\",\n    +   \"foo\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.032 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":112},"start":{"column":11,"line":112}}},{"id":"84","mutatorName":"PrecomputedMutator","replacement":"part.slice(2)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (2 ms)\n\n    ✕ compiles capture segments correctly (2 ms)\n\n    ✓ matches literal path segments correctly (2 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (2 ms)\n\n    ✓ matches combinations of wildcard segments correctly (3 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\"]\n    Received:\n      [\"oo\"]\n\n    Message:\n      path spec '/:foo' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"foo\",\n    +   \"oo\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.867 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":112},"start":{"column":22,"line":112}}},{"id":"85","mutatorName":"PrecomputedMutator","replacement":"part.slice(-1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (8 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (6 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\"]\n    Received:\n      [\"o\"]\n\n    Message:\n      path spec '/:foo' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"foo\",\n    +   \"o\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        1.9 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":112},"start":{"column":22,"line":112}}},{"id":"86","mutatorName":"PrecomputedMutator","replacement":"part.substr(1)","status":"Survived","testsCompleted":1,"location":{"end":{"column":35,"line":112},"start":{"column":22,"line":112}}},{"id":"87","mutatorName":"PrecomputedMutator","replacement":"0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (4 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (2 ms)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (5 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (3 ms)\n    ✓ clones itself correctly (1 ms)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (13 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly (6 ms)\n    ✓ matches literal path segments correctly (2 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\"]\n    Received:\n      [\":foo\"]\n\n    Message:\n      path spec '/:foo' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"foo\",\n    +   \":foo\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nTest Suites: 4 failed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.119 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":112},"start":{"column":33,"line":112}}},{"id":"88","mutatorName":"PrecomputedMutator","replacement":"Infinity","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (6 ms)\n    ✓ answers queries correctly (5 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (6 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✕ compiles capture segments correctly (3 ms)\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"foo\"]\n    Received:\n      [\"\"]\n\n    Message:\n      path spec '/:foo' did not compile to expected capture set\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"foo\",\n    +   \"\",\n      ]\n\n      636 |       strictEqual(regex.source, expected.source,\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n    > 638 |       deepStrictEqual(regex.props, props,\n          |                      ^\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n      640 |     })\n      641 |   })\n\n      at test/matcher.ts:638:22\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.229 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":112},"start":{"column":33,"line":112}}},{"id":"89","mutatorName":"PrecomputedMutator","replacement":"parts.pop","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (10 ms)\n    ✓ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (7 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (4 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        2.169 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":113},"start":{"column":11,"line":113}}},{"id":"90","mutatorName":"PrecomputedMutator","replacement":"parts.shift","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (3 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (13 ms)\n    ✓ answers queries correctly (5 ms)\n    ✕ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        2.126 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":113},"start":{"column":11,"line":113}}},{"id":"91","mutatorName":"PrecomputedMutator","replacement":"parts.unshift","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (4 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/matcher.ts\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (11 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✕ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/([^/]+)(?:\\\\/[^/]+)+\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/[^/]+(?:\\\\/[^/]+)+\\\\/([^/]+)\\\\/([^/]+)$\"\n\n    Message:\n      path spec '/+/:foo/*/:bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/([^/]+)(?:\\/[^/]+)+\\/([^/]+)$\n    + ^\\/[^/]+(?:\\/[^/]+)+\\/([^/]+)\\/([^/]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches capture segments correctly\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      [\"bar\", \"baz\"]\n    Received:\n      [\"boo\", \"baz\"]\n\n    Message:\n      path spec '/+/:a/*/:b' did not capture expected values\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Array [\n    -   \"bar\",\n    +   \"boo\",\n        \"baz\",\n      ]\n\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n    > 661 |           deepStrictEqual(match.slice(1), props,\n          |                          ^\n      662 |             `path spec '${test.spec}' did not capture expected values`)\n      663 |         }\n      664 |       }\n\n      at Object.<anonymous> (test/matcher.ts:661:26)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        1.954 s, estimated 2 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":113},"start":{"column":11,"line":113}}},{"id":"92","mutatorName":"PrecomputedMutator","replacement":"'/([^/]+)/'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (7 ms)\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✕ compiles capture segments correctly (3 ms)\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✕ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/]+)\\\\/$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/]+)\\/$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/:a' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nTest Suites: 4 failed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        2.008 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":113},"start":{"column":22,"line":113}}},{"id":"93","mutatorName":"PrecomputedMutator","replacement":"'/([^/:]+)'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (4 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✕ compiles capture segments correctly (3 ms)\n\n    ✓ matches literal path segments correctly (2 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles capture segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/([^/]+)$\"\n    Received:\n      \"^\\\\/([^/:]+)$\"\n\n    Message:\n      path spec '/:foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/([^/]+)$\n    + ^\\/([^/:]+)$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.033 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":113},"start":{"column":22,"line":113}}},{"id":"94","mutatorName":"PrecomputedMutator","replacement":"parts.pop","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (4 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (4 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✕ compiles literal path segments correctly (2 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n    ✕ matches match-one-or-none wildcard segments correctly\n\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/$\"\n    Received:\n      \"^$\"\n\n    Message:\n      path spec '/' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/$\n    + ^$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^(?:\\/[^/]+)?$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)*$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      expected path spec '/foo' to not match ''\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |      \n              ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 4 failed, 4 total\nTests:       21 failed, 17 passed, 38 total\nSnapshots:   0 total\nTime:        2.02 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":115},"start":{"column":11,"line":115}}},{"id":"95","mutatorName":"PrecomputedMutator","replacement":"parts.unshift","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (4 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (10 ms)\n    ✕ compiles match-one wildcard segments correctly (1 ms)\n    ✕ compiles match-many wildcard segments correctly\n    ✕ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✕ compiles match-many-or-none wildcard segments correctly\n    ✕ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly (1 ms)\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✕ matches match-one wildcard segments correctly (1 ms)\n    ✕ matches match-many wildcard segments correctly\n\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo\\\\/bar$\"\n    Received:\n      \"^\\\\/bar\\\\/foo$\"\n\n    Message:\n      path spec '/foo/bar' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo\\/bar$\n    + ^\\/bar\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/foo$\"\n\n    Message:\n      path spec '/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo\\/[^/]+$\n    + ^\\/[^/]+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo(?:\\\\/[^/]+)+$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n\n    Message:\n      path spec '/foo/*' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo(?:\\/[^/]+)+$\n    + ^(?:\\/[^/]+)+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo(?:\\\\/[^/]+)?$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n\n    Message:\n      path spec '/foo/++' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo(?:\\/[^/]+)?$\n    + ^(?:\\/[^/]+)?\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo(?:\\\\/[^/]+)*$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n\n    Message:\n      path spec '/foo/**' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo(?:\\/[^/]+)*$\n    + ^(?:\\/[^/]+)*\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/[^/]+\\\\/foo$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^\\/[^/]+\\/[^/]+\\/foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/bar' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n  \n    657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/**' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       15 failed, 23 passed, 38 total\nSnapshots:   0 total\nTime:        2.052 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":115},"start":{"column":11,"line":115}}},{"id":"96","mutatorName":"PrecomputedMutator","replacement":"`/${part.replace(/([.$])/g, '\\\\$2')}`","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (8 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly (1 ms)\n    ✕ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/\\\\.foo$\"\n    Received:\n      \"^\\\\/\\\\$2foo$\"\n\n    Message:\n      path spec '/.foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/\\.foo$\n    + ^\\/\\$2foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/.foo' to match '/.foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.089 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":59,"line":115},"start":{"column":22,"line":115}}},{"id":"97","mutatorName":"PrecomputedMutator","replacement":"`/${part.replace(/([.$])/g, '\\\\$3')}`","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (10 ms)\n\n    ✓ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (8 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (3 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/\\\\.foo$\"\n    Received:\n      \"^\\\\/\\\\$3foo$\"\n\n    Message:\n      path spec '/.foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/\\.foo$\n    + ^\\/\\$3foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/.foo' to match '/.foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.111 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":59,"line":115},"start":{"column":22,"line":115}}},{"id":"98","mutatorName":"PrecomputedMutator","replacement":"part.replace(/([.$])/g, '\\\\$0')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (3 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✕ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/\\\\.foo$\"\n    Received:\n      \"^\\\\/\\\\$0foo$\"\n\n    Message:\n      path spec '/.foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/\\.foo$\n    + ^\\/\\$0foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/.foo' to match '/.foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.126 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":57,"line":115},"start":{"column":26,"line":115}}},{"id":"99","mutatorName":"PrecomputedMutator","replacement":"/([^.$])/g","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (10 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✕ compiles literal path segments correctly (4 ms)\n    ✕ compiles match-one wildcard segments correctly\n    ✕ compiles match-many wildcard segments correctly (1 ms)\n\n    ✕ compiles match-one-or-none wildcard segments correctly\n    ✕ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✕ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✕ matches literal path segments correctly\n    ✕ matches match-one wildcard segments correctly\n\n    ✕ matches match-many wildcard segments correctly (1 ms)\n\n    ✕ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✕ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/foo$\"\n    Received:\n      \"^\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/foo$\n    + ^\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/+/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo$\n    + ^\\/[^/]+\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)+\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)+\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/*/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)+\\/foo$\n    + ^(?:\\/[^/]+)+\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)?\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)?\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/++/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)?\\/foo$\n    + ^(?:\\/[^/]+)?\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^(?:\\\\/[^/]+)*\\\\/foo$\"\n    Received:\n      \"^(?:\\\\/[^/]+)*\\\\/\\\\f\\\\o\\\\o$\"\n\n    Message:\n      path spec '/**/foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^(?:\\/[^/]+)*\\/foo$\n    + ^(?:\\/[^/]+)*\\/\\f\\o\\o$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › compiles combinations of wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/[^/]+\\\\/foo\\\\/[^/]+$\"\n    Received:\n      \"^\\\\/[^/]+\\\\/\\\\f\\\\o\\\\o\\\\/[^/]+$\"\n\n    Message:\n      path spec '/+/foo/+' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/[^/]+\\/foo\\/[^/]+$\n    + ^\\/[^/]+\\/\\f\\o\\o\\/[^/]+$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/+' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/*' to match '/foo/bar'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-one-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/++' to match '/foo'\n\n      656 |         const [expected, value, ...\nprops] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n  ● matcher › matches match-many-or-none wildcard segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/foo/**' to match '/foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 4 failed, 4 total\nTests:       19 failed, 19 passed, 38 total\nSnapshots:   0 total\nTime:        2.126 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":48,"line":115},"start":{"column":39,"line":115}}},{"id":"100","mutatorName":"PrecomputedMutator","replacement":"'\\\\$0'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✕ compiles literal path segments correctly (5 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✕ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n  ● matcher › compiles literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"^\\\\/\\\\.foo$\"\n    Received:\n      \"^\\\\/\\\\$0foo$\"\n\n    Message:\n      path spec '/.foo' did not compile to expected pattern\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - ^\\/\\.foo$\n    + ^\\/\\$0foo$\n\n      634 |       const [spec, expected, ...props] = test\n      635 |       const regex = Matcher.for(spec)\n    > 636 |       strictEqual(regex.source, expected.source,\n          |                  ^\n      637 |         `path spec '${spec}' did not compile to expected pattern`)\n      638 |       deepStrictEqual(regex.props, props,\n      639 |         `path spec '${spec}' did not compile to expected capture set`)\n\n      at test/matcher.ts:636:18\n          at Array.forEach (<anonymous>)\n      at Object.<anonymous> (test/matcher.ts:633:11)\n\n  ● matcher › matches literal path segments correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      expected path spec '/.foo' to match '/.foo'\n\n      656 |         const [expected, value, ...props] = path\n      657 |         const match = value.match(regex)\n    > 658 |         strictEqual((match !== null), expected,\n          |                    ^\n      659 |           `expected path spec '${test.spec}' to${expected ? '' : ' not'} match '${value}'`)\n      660 |         if (match !== null) {\n      661 |           deepStrictEqual(match.slice(1), props,\n\n      at Object.<anonymous> (test/matcher.ts:658:20)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.075 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":56,"line":115},"start":{"column":50,"line":115}}}],"source":"\n/** Extended regex for matching paths. */\nexport class Matcher extends RegExp {\n  /** Original path specification that produced this matcher. */\n  readonly spec: string\n  /** Context properties referenced by path specification. */\n  readonly props: string[]\n\n  /** @param spec Path specification.\n    * @param version Specification language version. */\n  constructor (spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    if (spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null) {\n      throw new Error('Path contains invalid characters')\n    }\n    if (spec.match(/^\\//) === null) {\n      throw new Error('Path must begin with a slash')\n    }\n    if (spec.match(/\\/\\//) !== null) {\n      throw new Error('Path contains empty segments')\n    }\n    if (spec.match(version === '1' || version === '1.0'\n      ? /[*+][^/]|[^/][*+]/\n      : /\\*[^*/]|\\+[^+/]|[^/*]\\*|[^/+]\\+|\\*\\*\\*|\\+\\+\\+/) !== null) {\n      throw new Error('Path contains malformed wildcards')\n    }\n    if (spec.match(/[^/]:|:\\/|:$/) !== null) {\n      throw new Error('Path contains malformed captures')\n    }\n    if (spec.match(/^.+\\/$/) !== null) {\n      throw new Error('Path must not end with a slash')\n    }\n    const { regex, props } = compile(spec)\n    super(regex)\n    this.spec = spec\n    this.props = props\n  }\n\n  [Symbol.match] (string: string): RegExpMatchArray | null {\n    if (string.length > 1 && string.endsWith('/')) {\n      return null\n    }\n    return super[Symbol.match](string)\n  }\n\n  /** Static constructor function; returns a new Matcher.\n    * @param spec Path specification.\n    * @param version Specification language version. */\n  static for (spec: string, version: '1' | '1.0' | '1.1' = '1.1'): Matcher {\n    return new Matcher(spec, version)\n  }\n}\n\nfunction compile (spec: string): {\n  regex: string\n  props: string[]\n} {\n  const parts: string[] = []\n  const props: string[] = []\n  let min = 0\n  let max = 0\n  let any = false\n  let opt = true\n  function flatten (final: boolean = false): void {\n    if (max > 0 || any) {\n      if (final && opt && min < 1) {\n        min = 1\n      } else if (min > 0) {\n        opt = false\n      }\n      parts.push(any\n        ? min < 2\n          ? min < 1\n            ? '(?:/[^/]+)*'\n            : '(?:/[^/]+)+'\n          : `(?:/[^/]+){${min},}`\n        : max === 1\n          ? min === 1\n            ? '/[^/]+'\n            : '(?:/[^/]+)?'\n          : min === max\n            ? `(?:/[^/]+){${min}}`\n            : `(?:/[^/]+){${min},${max}}`)\n    }\n    min = 0\n    max = 0\n    any = false\n  }\n  function finalise (): string {\n    flatten(true)\n    return (opt ? '^/$|^' : '^') + parts.reduce((acc, seg) => seg + acc, '$')\n  }\n  for (const part of spec.split('/').slice(1).reverse()) {\n    switch (part) {\n      case '+':\n        min++\n        max++\n        break\n      case '++':\n        max++\n        break\n      case '*':\n        min++\n        any = true\n        break\n      case '**':\n        any = true\n        break\n      default:\n        flatten()\n        opt = false\n        if (part.match(/:.+/) !== null) {\n          props.push(part.slice(1))\n          parts.push('/([^/]+)')\n        } else {\n          parts.push(`/${part.replace(/([.$])/g, '\\\\$1')}`)\n        }\n    }\n  }\n  return {\n    regex: finalise(),\n    props: props.reverse()\n  }\n}\n"},"src/policy.ts":{"language":"typescript","mutants":[{"id":"101","mutatorName":"PrecomputedMutator","replacement":"this.rules.unshift","status":"Survived","testsCompleted":1,"location":{"end":{"column":20,"line":18},"start":{"column":5,"line":18}}},{"id":"102","mutatorName":"PrecomputedMutator","replacement":"this.rules.pop","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (2 ms)\n\n\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.59 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":20,"line":18},"start":{"column":5,"line":18}}},{"id":"103","mutatorName":"PrecomputedMutator","replacement":"this.rules.shift","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (2 ms)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.252 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":20,"line":18},"start":{"column":5,"line":18}}},{"id":"104","mutatorName":"PrecomputedMutator","replacement":"this.rules.reverse()","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":32},"start":{"column":24,"line":32}}},{"id":"105","mutatorName":"PrecomputedMutator","replacement":"this.rules.slice()","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":32},"start":{"column":24,"line":32}}},{"id":"106","mutatorName":"PrecomputedMutator","replacement":"this.rules.filter(rule => rule.query(path, verb, ctx) === true)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (4 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (4 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'boo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.124 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":32},"start":{"column":24,"line":32}}},{"id":"107","mutatorName":"PrecomputedMutator","replacement":"rule.query(path, verb, ctx.path)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (2 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly (5 ms)\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (6 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'path')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"106\") ? this.rules.filter(rule => rule.query(path, verb, ctx) === true) : stryMutAct_9fa48(\"105\") ? this.rules.slice() : stryMutAct_9fa48(\"104\") ? this.rules.reverse() : (stryCov_9fa48(\"104\", \"105\", \"106\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"108\") ? rule.query(path, verb, ctx.verb) : stryMutAct_9fa48(\"107\") ? rule.query(path, verb, ctx.path) : (stryCov_9fa48(\"107\", \"108\"), rule.query(stryMutAct_9fa48(\"111\") ? path.substring(1) : stryMutAct_9fa48(\"110\") ? path.toUpperCase() : stryMutAct_9fa48(\"109\") ? path + 'foo' : (stryCov_9fa48(\"109\", \"110\", \"111\"), path), stryMutAct_9fa48(\"114\") ? verb + \"X\" : stryMutAct_9fa48(\"113\") ? verb.toLowerCase() : stryMutAct_9fa48(\"112\") ? verb.toUpperCase() : (stryCov_9fa48(\"112\", \"113\", \"114\"), verb), stryMutAct_9fa48(\"117\") ? \"\" : stryMutAct_9fa48(\"116\") ? null : stryMutAct_9fa48(\"115\") ? undefined : (stryCov_9fa48(\"115\", \"116\", \"117\"), ctx)));\n         |                                                                                                                                     ^\n      80 |       if (stryMutAct_9fa48(\"120\") ? res === null : stryMutAct_9fa48(\"119\") ? res !== true : stryMutAct_9fa48(\"118\") ? res !== false : (stryCov_9fa48(\"118\", \"119\", \"120\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:133)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'path')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"106\") ? this.rules.filter(rule => rule.query(path, verb, ctx) === true) : stryMutAct_9fa48(\"105\") ? this.rules.slice() : stryMutAct_9fa48(\"104\") ? this.rules.reverse() : (stryCov_9fa48(\"104\", \"105\", \"106\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"108\") ? rule.query(path, verb, ctx.verb) : stryMutAct_9fa48(\"107\") ? rule.query(path, verb, ctx.path) : (stryCov_9fa48(\"107\", \"108\"), rule.query(stryMutAct_9fa48(\"111\") ? path.substring(1) : stryMutAct_9fa48(\"110\") ? path.toUpperCase() : stryMutAct_9fa48(\"109\") ? path + 'foo' : (stryCov_9fa48(\"109\", \"110\", \"111\"), path), stryMutAct_9fa48(\"114\") ? verb + \"X\" : stryMutAct_9fa48(\"113\") ? verb.toLowerCase() : stryMutAct_9fa48(\"112\") ? verb.toUpperCase() : (stryCov_9fa48(\"112\", \"113\", \"114\"), verb), stryMutAct_9fa48(\"117\") ? \"\" : stryMutAct_9fa48(\"116\") ? null : stryMutAct_9fa48(\"115\") ? undefined : (stryCov_9fa48(\"115\", \"116\", \"117\"), ctx)));\n         |                                                                                                                                     ^\n      80 |       if (stryMutAct_9fa48(\"120\") ? res === null : stryMutAct_9fa48(\"119\") ? res !== true : stryMutAct_9fa48(\"118\") ? res !== false : (stryCov_9fa48(\"118\", \"119\", \"120\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:133)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'path')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"106\") ? this.rules.filter(rule => rule.query(path, verb, ctx) === true) : stryMutAct_9fa48(\"105\") ? this.rules.slice() : stryMutAct_9fa48(\"104\") ? this.rules.reverse() : (stryCov_9fa48(\"104\", \"105\", \"106\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"108\") ? rule.query(path, verb, ctx.verb) : stryMutAct_9fa48(\"107\") ? rule.query(path, verb, ctx.path) : (stryCov_9fa48(\"107\", \"108\"), rule.query(stryMutAct_9fa48(\"111\") ? path.substring(1) : stryMutAct_9fa48(\"110\") ? path.toUpperCase() : stryMutAct_9fa48(\"109\") ? path + 'foo' : (stryCov_9fa48(\"109\", \"110\", \"111\"), path), stryMutAct_9fa48(\"114\") ? verb + \"X\" : stryMutAct_9fa48(\"113\") ? verb.toLowerCase() : stryMutAct_9fa48(\"112\") ? verb.toUpperCase() : (stryCov_9fa48(\"112\", \"113\", \"114\"), verb), stryMutAct_9fa48(\"117\") ? \"\" : stryMutAct_9fa48(\"116\") ? null : stryMutAct_9fa48(\"115\") ? undefined : (stryCov_9fa48(\"115\", \"116\", \"117\"), ctx)));\n         |                                                                                                                                     ^\n      80 |       if (stryMutAct_9fa48(\"120\") ? res === null : stryMutAct_9fa48(\"119\") ? res !== true : stryMutAct_9fa48(\"118\") ? res !== false : (stryCov_9fa48(\"118\", \"119\", \"120\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:133)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.142 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":46,"line":33},"start":{"column":19,"line":33}}},{"id":"108","mutatorName":"PrecomputedMutator","replacement":"rule.query(path, verb, ctx.verb)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (7 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (3 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'verb')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"106\") ? this.rules.filter(rule => rule.query(path, verb, ctx) === true) : stryMutAct_9fa48(\"105\") ? this.rules.slice() : stryMutAct_9fa48(\"104\") ? this.rules.reverse() : (stryCov_9fa48(\"104\", \"105\", \"106\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"108\") ? rule.query(path, verb, ctx.verb) : stryMutAct_9fa48(\"107\") ? rule.query(path, verb, ctx.path) : (stryCov_9fa48(\"107\", \"108\"), rule.query(stryMutAct_9fa48(\"111\") ? path.substring(1) : stryMutAct_9fa48(\"110\") ? path.toUpperCase() : stryMutAct_9fa48(\"109\") ? path + 'foo' : (stryCov_9fa48(\"109\", \"110\", \"111\"), path), stryMutAct_9fa48(\"114\") ? verb + \"X\" : stryMutAct_9fa48(\"113\") ? verb.toLowerCase() : stryMutAct_9fa48(\"112\") ? verb.toUpperCase() : (stryCov_9fa48(\"112\", \"113\", \"114\"), verb), stryMutAct_9fa48(\"117\") ? \"\" : stryMutAct_9fa48(\"116\") ? null : stryMutAct_9fa48(\"115\") ? undefined : (stryCov_9fa48(\"115\", \"116\", \"117\"), ctx)));\n         |                                                                        ^\n      80 |       if (stryMutAct_9fa48(\"120\") ? res === null : stryMutAct_9fa48(\"119\") ? res !== true : stryMutAct_9fa48(\"118\") ? res !== false : (stryCov_9fa48(\"118\", \"119\", \"120\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:72)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'verb')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"106\") ? this.rules.filter(rule => rule.query(path, verb, ctx) === true) : stryMutAct_9fa48(\"105\") ? this.rules.slice() : stryMutAct_9fa48(\"104\") ? this.rules.reverse() : (stryCov_9fa48(\"104\", \"105\", \"106\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"108\") ? rule.query(path, verb, ctx.verb) : stryMutAct_9fa48(\"107\") ? rule.query(path, verb, ctx.path) : (stryCov_9fa48(\"107\", \"108\"), rule.query(stryMutAct_9fa48(\"111\") ? path.substring(1) : stryMutAct_9fa48(\"110\") ? path.toUpperCase() : stryMutAct_9fa48(\"109\") ? path + 'foo' : (stryCov_9fa48(\"109\", \"110\", \"111\"), path), stryMutAct_9fa48(\"114\") ? verb + \"X\" : stryMutAct_9fa48(\"113\") ? verb.toLowerCase() : stryMutAct_9fa48(\"112\") ? verb.toUpperCase() : (stryCov_9fa48(\"112\", \"113\", \"114\"), verb), stryMutAct_9fa48(\"117\") ? \"\" : stryMutAct_9fa48(\"116\") ? null : stryMutAct_9fa48(\"115\") ? undefined : (stryCov_9fa48(\"115\", \"116\", \"117\"), ctx)));\n         |                                                                        ^\n      80 |       if (stryMutAct_9fa48(\"120\") ? res === null : stryMutAct_9fa48(\"119\") ? res !== true : stryMutAct_9fa48(\"118\") ? res !== false : (stryCov_9fa48(\"118\", \"119\", \"120\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:72)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'verb')\n\n      77 |     let allow = null;\n      78 |     for (const rule of stryMutAct_9fa48(\"106\") ? this.rules.filter(rule => rule.query(path, verb, ctx) === true) : stryMutAct_9fa48(\"105\") ? this.rules.slice() : stryMutAct_9fa48(\"104\") ? this.rules.reverse() : (stryCov_9fa48(\"104\", \"105\", \"106\"), this.rules)) {\n    > 79 |       const res = stryMutAct_9fa48(\"108\") ? rule.query(path, verb, ctx.verb) : stryMutAct_9fa48(\"107\") ? rule.query(path, verb, ctx.path) : (stryCov_9fa48(\"107\", \"108\"), rule.query(stryMutAct_9fa48(\"111\") ? path.substring(1) : stryMutAct_9fa48(\"110\") ? path.toUpperCase() : stryMutAct_9fa48(\"109\") ? path + 'foo' : (stryCov_9fa48(\"109\", \"110\", \"111\"), path), stryMutAct_9fa48(\"114\") ? verb + \"X\" : stryMutAct_9fa48(\"113\") ? verb.toLowerCase() : stryMutAct_9fa48(\"112\") ? verb.toUpperCase() : (stryCov_9fa48(\"112\", \"113\", \"114\"), verb), stryMutAct_9fa48(\"117\") ? \"\" : stryMutAct_9fa48(\"116\") ? null : stryMutAct_9fa48(\"115\") ? undefined : (stryCov_9fa48(\"115\", \"116\", \"117\"), ctx)));\n         |                                                                        ^\n      80 |       if (stryMutAct_9fa48(\"120\") ? res === null : stryMutAct_9fa48(\"119\") ? res !== true : stryMutAct_9fa48(\"118\") ? res !== false : (stryCov_9fa48(\"118\", \"119\", \"120\"), res === false)) {\n      81 |         return false;\n      82 |       }\n\n      at Policy.query (src/policy.ts:79:72)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.111 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":46,"line":33},"start":{"column":19,"line":33}}},{"id":"109","mutatorName":"PrecomputedMutator","replacement":"path + 'foo'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly (3 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.153 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":33},"start":{"column":30,"line":33}}},{"id":"110","mutatorName":"PrecomputedMutator","replacement":"path.toUpperCase()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (5 ms)\n\n    ✕ answers queries correctly (4 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (3 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.094 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":33},"start":{"column":30,"line":33}}},{"id":"111","mutatorName":"PrecomputedMutator","replacement":"path.substring(1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (4 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (2 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (7 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.098 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":33},"start":{"column":30,"line":33}}},{"id":"112","mutatorName":"PrecomputedMutator","replacement":"verb.toUpperCase()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (3 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.111 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":33},"start":{"column":36,"line":33}}},{"id":"113","mutatorName":"PrecomputedMutator","replacement":"verb.toLowerCase()","status":"Survived","testsCompleted":1,"location":{"end":{"column":40,"line":33},"start":{"column":36,"line":33}}},{"id":"114","mutatorName":"PrecomputedMutator","replacement":"verb + \"X\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.114 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":33},"start":{"column":36,"line":33}}},{"id":"115","mutatorName":"PrecomputedMutator","replacement":"undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (3 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.146 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":33},"start":{"column":42,"line":33}}},{"id":"116","mutatorName":"PrecomputedMutator","replacement":"null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of null (reading 'foo')\n\n      147 |       }\n      148 |       for (let index = 0; stryMutAct_9fa48(\"236\") ? index >= count : stryMutAct_9fa48(\"235\") ? index > count : stryMutAct_9fa48(\"234\") ? index <= count : (stryCov_9fa48(\"234\", \"235\", \"236\"), index < count); stryMutAct_9fa48(\"239\") ? index = 0 : stryMutAct_9fa48(\"238\") ? index += 2 : stryMutAct_9fa48(\"237\") ? index-- : (stryCov_9fa48(\"237\", \"238\", \"239\"), index++)) {\n    > 149 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      150 |         if (stryMutAct_9fa48(\"242\") ? prop !== null && match[index + 1] === prop : stryMutAct_9fa48(\"241\") ? prop !== undefined && match[index + 1] === prop : stryMutAct_9fa48(\"240\") ? prop === null || match[index + 1] !== prop : (stryCov_9fa48(\"240\", \"241\", \"242\"), prop === undefined || match[index + 1] !== prop)) {\n      151 |           return false;\n      152 |         }\n\n      at Rule.matches (src/rule.ts:149:25)\n      at Rule.query (src/rule.ts:129:578)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of null (reading 'maybe')\n\n      147 |       }\n      148 |       for (let index = 0; stryMutAct_9fa48(\"236\") ? index >= count : stryMutAct_9fa48(\"235\") ? index > count : stryMutAct_9fa48(\"234\") ? index <= count : (stryCov_9fa48(\"234\", \"235\", \"236\"), index < count); stryMutAct_9fa48(\"239\") ? index = 0 : stryMutAct_9fa48(\"238\") ? index += 2 : stryMutAct_9fa48(\"237\") ? index-- : (stryCov_9fa48(\"237\", \"238\", \"239\"), index++)) {\n    > 149 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      150 |         if (stryMutAct_9fa48(\"242\") ? prop !== null && match[index + 1] === prop : stryMutAct_9fa48(\"241\") ? prop !== undefined && match[index + 1] === prop : stryMutAct_9fa48(\"240\") ? prop === null || match[index + 1] !== prop : (stryCov_9fa48(\"240\", \"241\", \"242\"), prop === undefined || match[index + 1] !== prop)) {\n      151 |           return false;\n      152 |         }\n\n      at Rule.matches (src/rule.ts:149:25)\n      at Rule.query (src/rule.ts:129:578)\n      at Policy.query (src/policy.ts:79:176)\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.1 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":33},"start":{"column":42,"line":33}}},{"id":"117","mutatorName":"PrecomputedMutator","replacement":"\"\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.185 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":45,"line":33},"start":{"column":42,"line":33}}},{"id":"118","mutatorName":"PrecomputedMutator","replacement":"res !== false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (14 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.129 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":24,"line":34},"start":{"column":11,"line":34}}},{"id":"119","mutatorName":"PrecomputedMutator","replacement":"res !== true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.232 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":24,"line":34},"start":{"column":11,"line":34}}},{"id":"120","mutatorName":"PrecomputedMutator","replacement":"res === null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (2 ms)\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards (2 ms)\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (4 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.351 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":24,"line":34},"start":{"column":11,"line":34}}},{"id":"121","mutatorName":"PrecomputedMutator","replacement":"res === false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (8 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (9 ms)\n    ✓ matches capture segments correctly (4 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (4 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.275 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":37},"start":{"column":11,"line":37}}},{"id":"122","mutatorName":"PrecomputedMutator","replacement":"res !== false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'shallow'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:138:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.166 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":37},"start":{"column":11,"line":37}}},{"id":"123","mutatorName":"PrecomputedMutator","replacement":"res === null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (14 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (2 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'shallow'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:138:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.29 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":37},"start":{"column":11,"line":37}}},{"id":"124","mutatorName":"PrecomputedMutator","replacement":"this.rules.slice()","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":48},"start":{"column":24,"line":48}}},{"id":"125","mutatorName":"PrecomputedMutator","replacement":"this.rules.concat([])","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":48},"start":{"column":24,"line":48}}},{"id":"126","mutatorName":"PrecomputedMutator","replacement":"this.rules.slice(0, -1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (8 ms)\n    ✓ answers queries correctly (3 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/nah/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/bar') for policy 'allow first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:109:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'shallow'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:138:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.189 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":48},"start":{"column":24,"line":48}}},{"id":"127","mutatorName":"PrecomputedMutator","replacement":"!rule.matches(path, ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✓ answers queries correctly (3 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.196 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":49},"start":{"column":11,"line":49}}},{"id":"128","mutatorName":"PrecomputedMutator","replacement":"rule.matches(path, ctx) && false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (7 ms)\n    ✓ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (4 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (6 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.226 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":49},"start":{"column":11,"line":49}}},{"id":"129","mutatorName":"PrecomputedMutator","replacement":"rule.matches(path, ctx) || true","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (7 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (4 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       4 failed, 34 passed, 38 total\nSnapshots:   0 total\nTime:        2.167 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":49},"start":{"column":11,"line":49}}},{"id":"130","mutatorName":"PrecomputedMutator","replacement":"rule.matches(path, ctx.parent)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly (3 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (3 ms)\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly (4 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✓ answers queries correctly (3 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (2 ms)\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'parent')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                      ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:182)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'parent')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                      ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:182)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'parent')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                      ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:182)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'parent')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                      ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:182)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'parent')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMut\nAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                      ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:182)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.233 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":49},"start":{"column":11,"line":49}}},{"id":"131","mutatorName":"PrecomputedMutator","replacement":"rule.matches(path, ctx.children)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (7 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (2 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'children')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                         ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:121)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'children')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                         ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:121)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'children')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                         ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:121)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'children')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                         ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:121)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'children')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\n\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                         ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:121)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.168 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":49},"start":{"column":11,"line":49}}},{"id":"132","mutatorName":"PrecomputedMutator","replacement":"rule.matches(path, ctx.siblings)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (8 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (2 ms)\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'siblings')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                            ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:60)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'siblings')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                            ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:60)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'siblings')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                            ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:60)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'siblings')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                            ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:60)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'siblings')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                            ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:60\n)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.193 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":49},"start":{"column":11,"line":49}}},{"id":"133","mutatorName":"PrecomputedMutator","replacement":"path.toLowerCase()","status":"Survived","testsCompleted":1,"location":{"end":{"column":28,"line":49},"start":{"column":24,"line":49}}},{"id":"134","mutatorName":"PrecomputedMutator","replacement":"path.substring(1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✓ answers queries correctly (3 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (6 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.154 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":49},"start":{"column":24,"line":49}}},{"id":"135","mutatorName":"PrecomputedMutator","replacement":"path.split(\"/\")[0]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (3 ms)\n\n    ✓ answers context-dependent queries correctly (13 ms)\n\n    ✓ prioritises deny over allow (2 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✓ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.197 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":49},"start":{"column":24,"line":49}}},{"id":"136","mutatorName":"PrecomputedMutator","replacement":"ctx.path","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly (4 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (3 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (2 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'path')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:734)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'path')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:734)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'path')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:734)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'path')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.par\nent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:734)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'path')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:734)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.212 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":49},"start":{"column":30,"line":49}}},{"id":"137","mutatorName":"PrecomputedMutator","replacement":"ctx.verb","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (11 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (2 ms)\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'verb')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:697)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'verb')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:697)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'verb')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:697)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'verb')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCa\nse() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:697)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'verb')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:697)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.178 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":49},"start":{"column":30,"line":49}}},{"id":"138","mutatorName":"PrecomputedMutator","replacement":"ctx.path.slice(0)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (5 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'slice')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:656)\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● policy › matches paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'path')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:651)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'path')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:651)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'path')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:651)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'slice')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      96 |         return t\nrue;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:656)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'path')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:651)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'path')\n\n      93 |   matches(path: string, ctx?: QueryContext): boolean {\n      94 |     for (const rule of stryMutAct_9fa48(\"126\") ? this.rules.slice(0, -1) : stryMutAct_9fa48(\"125\") ? this.rules.concat([]) : stryMutAct_9fa48(\"124\") ? this.rules.slice() : (stryCov_9fa48(\"124\", \"125\", \"126\"), this.rules)) {\n    > 95 |       if (stryMutAct_9fa48(\"132\") ? rule.matches(path, ctx.siblings) : stryMutAct_9fa48(\"131\") ? rule.matches(path, ctx.children) : stryMutAct_9fa48(\"130\") ? rule.matches(path, ctx.parent) : stryMutAct_9fa48(\"129\") ? rule.matches(path, ctx) || true : stryMutAct_9fa48(\"128\") ? rule.matches(path, ctx) && false : stryMutAct_9fa48(\"127\") ? !rule.matches(path, ctx) : (stryCov_9fa48(\"127\", \"128\", \"129\", \"130\", \"131\", \"132\"), rule.matches(stryMutAct_9fa48(\"135\") ? path.split(\"/\")[0] : stryMutAct_9fa48(\"134\") ? path.substring(1) : stryMutAct_9fa48(\"133\") ? path.toLowerCase() : (stryCov_9fa48(\"133\", \"134\", \"135\"), path), stryMutAct_9fa48(\"138\") ? ctx.path.slice(0) : stryMutAct_9fa48(\"137\") ? ctx.verb : stryMutAct_9fa48(\"136\") ? ctx.path : (stryCov_9fa48(\"136\", \"137\", \"138\"), ctx)))) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      96 |         return true;\n      97 |       }\n      98 |     }\n\n      at Policy.matches (src/policy.ts:95:651)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.188 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":49},"start":{"column":30,"line":49}}},{"id":"139","mutatorName":"PrecomputedMutator","replacement":"rule => rule.clone(name, false)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › clones itself correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Rule.clone (src/rule.ts:161:18)\n      at src/policy.ts:106:226\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:50)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (4 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.21 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":66,"line":61},"start":{"column":44,"line":61}}},{"id":"140","mutatorName":"PrecomputedMutator","replacement":"rule => rule.clone(name, true)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (9 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n\n  ● policy › clones itself correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Rule.clone (src/rule.ts:161:18)\n      at src/policy.ts:106:167\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:50)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.257 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":66,"line":61},"start":{"column":44,"line":61}}},{"id":"141","mutatorName":"PrecomputedMutator","replacement":"rule => rule.clone(name, Math.random() < 0.5)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (3 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (2 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › clones itself correctly\n\n    Path must begin with a slash\n\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n    > 62 |       throw new Error('Path must begin with a slash');\n         |             ^\n      63 |     }\n      64 |     if ((stryMutAct_9fa48(\"12\") ? spec.split(/\\/\\//) : stryMutAct_9fa48(\"11\") ? spec.replace(/\\/\\//) : stryMutAct_9fa48(\"10\") ? spec.search(/\\/\\//) : (stryCov_9fa48(\"10\", \"11\", \"12\"), spec.match(/\\/\\//))) !== null) {\n      65 |       throw new Error('Path contains empty segments');\n\n      at new Matcher (src/matcher.ts:62:13)\n      at new Rule (src/rule.ts:64:51)\n      at Rule.clone (src/rule.ts:161:18)\n      at src/policy.ts:106:93\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:50)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.182 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":66,"line":61},"start":{"column":44,"line":61}}}],"source":"import { Rule } from './rule'\nimport { Queryable, QueryContext } from './queryable'\n\n/** Access-control policy. */\nexport class Policy implements Queryable {\n  /** Policy name. */\n  readonly name: string\n  /** Rules comprising policy. */\n  readonly rules: Rule[]\n\n  constructor (name: string, ...rules: Rule[]) {\n    this.name = name\n    this.rules = rules\n  }\n\n  /** Add rules to a policy. */\n  push (...rules: Rule[]): Policy {\n    this.rules.push(...rules)\n    return this\n  }\n\n  /** Check whether an action is allowed on a path.\n    * @param path Path to be acted on.\n    * @param verb Action to be performed.\n    * @param ctx Query context for resolving context-dependent paths.\n    * @returns Returns `true` if the action is explicitly allowed,\n    *          `false` if the action is explicitly denied, or\n    *          `null` if the combination of path and action\n    *          is not governed by this policy. */\n  query (path: string, verb: string, ctx?: QueryContext): boolean | null {\n    let allow = null\n    for (const rule of this.rules) {\n      const res = rule.query(path, verb, ctx)\n      if (res === false) {\n        return false\n      }\n      if (res === true) {\n        allow = true\n      }\n    }\n    return allow\n  }\n\n  /** Check whether a path is governed by this policy.\n    * @param path Path to be checked.\n    * @param ctx Query context for resolving context-dependent paths. */\n  matches (path: string, ctx?: QueryContext): boolean {\n    for (const rule of this.rules) {\n      if (rule.matches(path, ctx)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /** Create clone of a policy.\n    * @param name Replacement name for new policy.\n    * @param deep Deep copy; clone underlying rules as well. */\n  clone (name: string = this.name, deep: boolean = true): Policy {\n    return deep\n      ? new Policy(name, ...this.rules.map((rule) => rule.clone()))\n      : new Policy(name, ...this.rules)\n  }\n\n  /** Static constructor function; returns a new Policy. */\n  static for (name: string, ...rules: Rule[]): Policy {\n    return new Policy(name, ...rules)\n  }\n}\n"},"src/policymap.ts":{"language":"typescript","mutants":[{"id":"142","mutatorName":"PrecomputedMutator","replacement":"policy => [policy.name, policy.name]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: policy.matches is not a function\n\n      83 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n      84 |     const policy = stryMutAct_9fa48(\"178\") ? this.set(name) : stryMutAct_9fa48(\"177\") ? this.has(name) : (stryCov_9fa48(\"177\", \"178\"), this.get(stryMutAct_9fa48(\"181\") ? name.substring(1) : stryMutAct_9fa48(\"180\") ? name.toUpperCase() : stryMutAct_9fa48(\"179\") ? \"name\" : (stryCov_9fa48(\"179\", \"180\", \"181\"), name)));\n    > 85 |     return policy !== undefined ? stryMutAct_9fa48(\"186\") ? policy.match(path, ctx) : stryMutAct_9fa48(\"185\") ? policy.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"184\") ? policy.matches(ctx.path) : stryMutAct_9fa48(\"183\") ? policy.matches(path - ctx) : stryMutAct_9fa48(\"182\") ? policy.matches(path + ctx) : (stryCov_9fa48(\"182\", \"183\", \"184\", \"185\", \"186\"), policy.matches(stryMutAct_9fa48(\"189\") ? path.split('/').pop() : stryMutAct_9fa48(\"188\") ? path + 'foo' : stryMutAct_9fa48(\"187\") ? path.toLowerCase() : (stryCov_9fa48(\"187\", \"188\", \"189\"), path), stryMutAct_9fa48(\"192\") ? \"different_context\" : stryMutAct_9fa48(\"191\") ? null : stryMutAct_9fa48(\"190\") ? undefined : (stryCov_9fa48(\"190\", \"191\", \"192\"), ctx))) : false;\n         |                                                                                                                                                                                                                                                                                                                                                                               ^\n      86 |   }\n      87 |\n      88 |   /** Static constructor function; returns a new PolicyMap. */\n\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: policy.query is not a function\n\n      74 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      75 |     const policy = stryMutAct_9fa48(\"161\") ? this.entries(name) : stryMutAct_9fa48(\"160\") ? this.values(name) : stryMutAct_9fa48(\"159\") ? this.has(name) : (stryCov_9fa48(\"159\", \"160\", \"161\"), this.get(stryMutAct_9fa48(\"164\") ? name.replace('a', 'b') : stryMutAct_9fa48(\"163\") ? name.slice(1) : stryMutAct_9fa48(\"162\") ? name.toLowerCase() : (stryCov_9fa48(\"162\", \"163\", \"164\"), name)));\n    > 76 |     return policy !== undefined ? stryMutAct_9fa48(\"167\") ? policy.query(path, verb, \"different context\") : stryMutAct_9fa48(\"166\") ? policy.query(path, verb, undefined) : stryMutAct_9fa48(\"165\") ? policy.query(path + verb, ctx) : (stryCov_9fa48(\"165\", \"166\", \"167\"), policy.query(stryMutAct_9fa48(\"170\") ? path.replace('/', '') : stryMutAct_9fa48(\"169\") ? path.length : stryMutAct_9fa48(\"168\") ? path.toLowerCase() : (stryCov_9fa48(\"168\", \"169\", \"170\"), path), stryMutAct_9fa48(\"173\") ? verb * \"foo\" : stryMutAct_9fa48(\"172\") ? verb - \"foo\" : stryMutAct_9fa48(\"171\") ? verb + \"foo\" : (stryCov_9fa48(\"171\", \"172\", \"173\"), verb), stryMutAct_9fa48(\"176\") ? false : stryMutAct_9fa48(\"175\") ? null : stryMutAct_9fa48(\"174\") ? undefined : (stryCov_9fa48(\"174\", \"175\", \"176\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                    ^\n      77 |   }\n      78 |\n      79 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.24 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":57,"line":7},"start":{"column":24,"line":7}}},{"id":"143","mutatorName":"PrecomputedMutator","replacement":"policy => [policy.name, policy.name.toUpperCase()]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly (2 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: policy.matches is not a function\n\n      83 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n      84 |     const policy = stryMutAct_9fa48(\"178\") ? this.set(name) : stryMutAct_9fa48(\"177\") ? this.has(name) : (stryCov_9fa48(\"177\", \"178\"), this.get(stryMutAct_9fa48(\"181\") ? name.substring(1) : stryMutAct_9fa48(\"180\") ? name.toUpperCase() : stryMutAct_9fa48(\"179\") ? \"name\" : (stryCov_9fa48(\"179\", \"180\", \"181\"), name)));\n    > 85 |     return policy !== undefined ? stryMutAct_9fa48(\"186\") ? policy.match(path, ctx) : stryMutAct_9fa48(\"185\") ? policy.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"184\") ? policy.matches(ctx.path) : stryMutAct_9fa48(\"183\") ? policy.matches(path - ctx) : stryMutAct_9fa48(\"182\") ? policy.matches(path + ctx) : (stryCov_9fa48(\"182\", \"183\", \"184\", \"185\", \"186\"), policy.matches(stryMutAct_9fa48(\"189\") ? path.split('/').pop() : stryMutAct_9fa48(\"188\") ? path + 'foo' : stryMutAct_9fa48(\"187\") ? path.toLowerCase() : (stryCov_9fa48(\"187\", \"188\", \"189\"), path), stryMutAct_9fa48(\"192\") ? \"different_context\" : stryMutAct_9fa48(\"191\") ? null : stryMutAct_9fa48(\"190\") ? undefined : (stryCov_9fa48(\"190\", \"191\", \"192\"), ctx))) : false;\n         |                                                                                                                                                                                                                                                                                                                                                                               ^\n      86 |   }\n      87 |\n      88 |   /** Static constructor function; returns a new PolicyMap. */\n\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: policy.query is not a function\n\n      74 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      75 |     const policy = stryMutAct_9fa48(\"161\") ? this.entries(name) : stryMutAct_9fa48(\"160\") ? this.values(name) : stryMutAct_9fa48(\"159\") ? this.has(name) : (stryCov_9fa48(\"159\", \"160\", \"161\"), this.get(stryMutAct_9fa48(\"164\") ? name.replace('a', 'b') : stryMutAct_9fa48(\"163\") ? name.slice(1) : stryMutAct_9fa48(\"162\") ? name.toLowerCase() : (stryCov_9fa48(\"162\", \"163\", \"164\"), name)));\n    > 76 |     return policy !== undefined ? stryMutAct_9fa48(\"167\") ? policy.query(path, verb, \"different context\") : stryMutAct_9fa48(\"166\") ? policy.query(path, verb, undefined) : stryMutAct_9fa48(\"165\") ? policy.query(path + verb, ctx) : (stryCov_9fa48(\"165\", \"166\", \"167\"), policy.query(stryMutAct_9fa48(\"170\") ? path.replace('/', '') : stryMutAct_9fa48(\"169\") ? path.length : stryMutAct_9fa48(\"168\") ? path.toLowerCase() : (stryCov_9fa48(\"168\", \"169\", \"170\"), path), stryMutAct_9fa48(\"173\") ? verb * \"foo\" : stryMutAct_9fa48(\"172\") ? verb - \"foo\" : stryMutAct_9fa48(\"171\") ? verb + \"foo\" : (stryCov_9fa48(\"171\", \"172\", \"173\"), verb), stryMutAct_9fa48(\"176\") ? false : stryMutAct_9fa48(\"175\") ? null : stryMutAct_9fa48(\"174\") ? undefined : (stryCov_9fa48(\"174\", \"175\", \"176\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                    ^\n      77 |   }\n      78 |\n      79 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.208 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":57,"line":7},"start":{"column":24,"line":7}}},{"id":"144","mutatorName":"PrecomputedMutator","replacement":"policy => [policy.name, policy.name + '1']","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: policy.matches is not a function\n\n      83 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n      84 |     const policy = stryMutAct_9fa48(\"178\") ? this.set(name) : stryMutAct_9fa48(\"177\") ? this.has(name) : (stryCov_9fa48(\"177\", \"178\"), this.get(stryMutAct_9fa48(\"181\") ? name.substring(1) : stryMutAct_9fa48(\"180\") ? name.toUpperCase() : stryMutAct_9fa48(\"179\") ? \"name\" : (stryCov_9fa48(\"179\", \"180\", \"181\"), name)));\n    > 85 |     return policy !== undefined ? stryMutAct_9fa48(\"186\") ? policy.match(path, ctx) : stryMutAct_9fa48(\"185\") ? policy.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"184\") ? policy.matches(ctx.path) : stryMutAct_9fa48(\"183\") ? policy.matches(path - ctx) : stryMutAct_9fa48(\"182\") ? policy.matches(path + ctx) : (stryCov_9fa48(\"182\", \"183\", \"184\", \"185\", \"186\"), policy.matches(stryMutAct_9fa48(\"189\") ? path.split('/').pop() : stryMutAct_9fa48(\"188\") ? path + 'foo' : stryMutAct_9fa48(\"187\") ? path.toLowerCase() : (stryCov_9fa48(\"187\", \"188\", \"189\"), path), stryMutAct_9fa48(\"192\") ? \"different_context\" : stryMutAct_9fa48(\"191\") ? null : stryMutAct_9fa48(\"190\") ? undefined : (stryCov_9fa48(\"190\", \"191\", \"192\"), ctx))) : false;\n         |                                                                                                                                                                                                                                                                                                                                                                               ^\n      86 |   }\n      87 |\n      88 |   /** Static constructor function; returns a new PolicyMap. */\n\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: policy.query is not a function\n\n      74 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      75 |     const policy = stryMutAct_9fa48(\"161\") ? this.entries(name) : stryMutAct_9fa48(\"160\") ? this.values(name) : stryMutAct_9fa48(\"159\") ? this.has(name) : (stryCov_9fa48(\"159\", \"160\", \"161\"), this.get(stryMutAct_9fa48(\"164\") ? name.replace('a', 'b') : stryMutAct_9fa48(\"163\") ? name.slice(1) : stryMutAct_9fa48(\"162\") ? name.toLowerCase() : (stryCov_9fa48(\"162\", \"163\", \"164\"), name)));\n    > 76 |     return policy !== undefined ? stryMutAct_9fa48(\"167\") ? policy.query(path, verb, \"different context\") : stryMutAct_9fa48(\"166\") ? policy.query(path, verb, undefined) : stryMutAct_9fa48(\"165\") ? policy.query(path + verb, ctx) : (stryCov_9fa48(\"165\", \"166\", \"167\"), policy.query(stryMutAct_9fa48(\"170\") ? path.replace('/', '') : stryMutAct_9fa48(\"169\") ? path.length : stryMutAct_9fa48(\"168\") ? path.toLowerCase() : (stryCov_9fa48(\"168\", \"169\", \"170\"), path), stryMutAct_9fa48(\"173\") ? verb * \"foo\" : stryMutAct_9fa48(\"172\") ? verb - \"foo\" : stryMutAct_9fa48(\"171\") ? verb + \"foo\" : (stryCov_9fa48(\"171\", \"172\", \"173\"), verb), stryMutAct_9fa48(\"176\") ? false : stryMutAct_9fa48(\"175\") ? null : stryMutAct_9fa48(\"174\") ? undefined : (stryCov_9fa48(\"174\", \"175\", \"176\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                    ^\n      77 |   }\n      78 |\n      79 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.21 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":57,"line":7},"start":{"column":24,"line":7}}},{"id":"145","mutatorName":"PrecomputedMutator","replacement":"policies.reverse()","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":12},"start":{"column":26,"line":12}}},{"id":"146","mutatorName":"PrecomputedMutator","replacement":"policies.slice()","status":"Survived","testsCompleted":1,"location":{"end":{"column":34,"line":12},"start":{"column":26,"line":12}}},{"id":"147","mutatorName":"PrecomputedMutator","replacement":"policies.map(policy => policy.name)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (2 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.306 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":12},"start":{"column":26,"line":12}}},{"id":"148","mutatorName":"PrecomputedMutator","replacement":"this.set(this.set(policy.name, policy))","status":"Survived","testsCompleted":1,"location":{"end":{"column":36,"line":13},"start":{"column":7,"line":13}}},{"id":"149","mutatorName":"PrecomputedMutator","replacement":"this.set(this.set(policy.name, policy.name))","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: policy.matches is not a function\n\n      83 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n      84 |     const policy = stryMutAct_9fa48(\"178\") ? this.set(name) : stryMutAct_9fa48(\"177\") ? this.has(name) : (stryCov_9fa48(\"177\", \"178\"), this.get(stryMutAct_9fa48(\"181\") ? name.substring(1) : stryMutAct_9fa48(\"180\") ? name.toUpperCase() : stryMutAct_9fa48(\"179\") ? \"name\" : (stryCov_9fa48(\"179\", \"180\", \"181\"), name)));\n    > 85 |     return policy !== undefined ? stryMutAct_9fa48(\"186\") ? policy.match(path, ctx) : stryMutAct_9fa48(\"185\") ? policy.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"184\") ? policy.matches(ctx.path) : stryMutAct_9fa48(\"183\") ? policy.matches(path - ctx) : stryMutAct_9fa48(\"182\") ? policy.matches(path + ctx) : (stryCov_9fa48(\"182\", \"183\", \"184\", \"185\", \"186\"), policy.matches(stryMutAct_9fa48(\"189\") ? path.split('/').pop() : stryMutAct_9fa48(\"188\") ? path + 'foo' : stryMutAct_9fa48(\"187\") ? path.toLowerCase() : (stryCov_9fa48(\"187\", \"188\", \"189\"), path), stryMutAct_9fa48(\"192\") ? \"different_context\" : stryMutAct_9fa48(\"191\") ? null : stryMutAct_9fa48(\"190\") ? undefined : (stryCov_9fa48(\"190\", \"191\", \"192\"), ctx))) : false;\n         |                                                                                                                                                                                                                                                                                                                                                                               ^\n      86 |   }\n      87 |\n      88 |   /** Static constructor function; returns a new PolicyMap. */\n\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: policy.query is not a function\n\n      74 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      75 |     const policy = stryMutAct_9fa48(\"161\") ? this.entries(name) : stryMutAct_9fa48(\"160\") ? this.values(name) : stryMutAct_9fa48(\"159\") ? this.has(name) : (stryCov_9fa48(\"159\", \"160\", \"161\"), this.get(stryMutAct_9fa48(\"164\") ? name.replace('a', 'b') : stryMutAct_9fa48(\"163\") ? name.slice(1) : stryMutAct_9fa48(\"162\") ? name.toLowerCase() : (stryCov_9fa48(\"162\", \"163\", \"164\"), name)));\n    > 76 |     return policy !== undefined ? stryMutAct_9fa48(\"167\") ? policy.query(path, verb, \"different context\") : stryMutAct_9fa48(\"166\") ? policy.query(path, verb, undefined) : stryMutAct_9fa48(\"165\") ? policy.query(path + verb, ctx) : (stryCov_9fa48(\"165\", \"166\", \"167\"), policy.query(stryMutAct_9fa48(\"170\") ? path.replace('/', '') : stryMutAct_9fa48(\"169\") ? path.length : stryMutAct_9fa48(\"168\") ? path.toLowerCase() : (stryCov_9fa48(\"168\", \"169\", \"170\"), path), stryMutAct_9fa48(\"173\") ? verb * \"foo\" : stryMutAct_9fa48(\"172\") ? verb - \"foo\" : stryMutAct_9fa48(\"171\") ? verb + \"foo\" : (stryCov_9fa48(\"171\", \"172\", \"173\"), verb), stryMutAct_9fa48(\"176\") ? false : stryMutAct_9fa48(\"175\") ? null : stryMutAct_9fa48(\"174\") ? undefined : (stryCov_9fa48(\"174\", \"175\", \"176\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                    ^\n      77 |   }\n      78 |\n      79 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.303 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":36,"line":13},"start":{"column":7,"line":13}}},{"id":"150","mutatorName":"PrecomputedMutator","replacement":"this.set(this.set(policy.name, null))","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards (8 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of null (reading 'matches')\n\n      83 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n      84 |     const policy = stryMutAct_9fa48(\"178\") ? this.set(name) : stryMutAct_9fa48(\"177\") ? this.has(name) : (stryCov_9fa48(\"177\", \"178\"), this.get(stryMutAct_9fa48(\"181\") ? name.substring(1) : stryMutAct_9fa48(\"180\") ? name.toUpperCase() : stryMutAct_9fa48(\"179\") ? \"name\" : (stryCov_9fa48(\"179\", \"180\", \"181\"), name)));\n    > 85 |     return policy !== undefined ? stryMutAct_9fa48(\"186\") ? policy.match(path, ctx) : stryMutAct_9fa48(\"185\") ? policy.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"184\") ? policy.matches(ctx.path) : stryMutAct_9fa48(\"183\") ? policy.matches(path - ctx) : stryMutAct_9fa48(\"182\") ? policy.matches(path + ctx) : (stryCov_9fa48(\"182\", \"183\", \"184\", \"185\", \"186\"), policy.matches(stryMutAct_9fa48(\"189\") ? path.split('/').pop() : stryMutAct_9fa48(\"188\") ? path + 'foo' : stryMutAct_9fa48(\"187\") ? path.toLowerCase() : (stryCov_9fa48(\"187\", \"188\", \"189\"), path), stryMutAct_9fa48(\"192\") ? \"different_context\" : stryMutAct_9fa48(\"191\") ? null : stryMutAct_9fa48(\"190\") ? undefined : (stryCov_9fa48(\"190\", \"191\", \"192\"), ctx))) : false;\n         |                                                                                                                                                                                                                                                                                                                                                                               ^\n      86 |   }\n      87 |\n      88 |   /** Static constructor function; returns a new PolicyMap. */\n\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of null (reading 'query')\n\n      74 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      75 |     const policy = stryMutAct_9fa48(\"161\") ? this.entries(name) : stryMutAct_9fa48(\"160\") ? this.values(name) : stryMutAct_9fa48(\"159\") ? this.has(name) : (stryCov_9fa48(\"159\", \"160\", \"161\"), this.get(stryMutAct_9fa48(\"164\") ? name.replace('a', 'b') : stryMutAct_9fa48(\"163\") ? name.slice(1) : stryMutAct_9fa48(\"162\") ? name.toLowerCase() : (stryCov_9fa48(\"162\", \"163\", \"164\"), name)));\n    > 76 |     return policy !== undefined ? stryMutAct_9fa48(\"167\") ? policy.query(path, verb, \"different context\") : stryMutAct_9fa48(\"166\") ? policy.query(path, verb, undefined) : stryMutAct_9fa48(\"165\") ? policy.query(path + verb, ctx) : (stryCov_9fa48(\"165\", \"166\", \"167\"), policy.query(stryMutAct_9fa48(\"170\") ? path.replace('/', '') : stryMutAct_9fa48(\"169\") ? path.length : stryMutAct_9fa48(\"168\") ? path.toLowerCase() : (stryCov_9fa48(\"168\", \"169\", \"170\"), path), stryMutAct_9fa48(\"173\") ? verb * \"foo\" : stryMutAct_9fa48(\"172\") ? verb - \"foo\" : stryMutAct_9fa48(\"171\") ? verb + \"foo\" : (stryCov_9fa48(\"171\", \"172\", \"173\"), verb), stryMutAct_9fa48(\"176\") ? false : stryMutAct_9fa48(\"175\") ? null : stryMutAct_9fa48(\"174\") ? undefined : (stryCov_9fa48(\"174\", \"175\", \"176\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                    ^\n      77 |   }\n      78 |\n      79 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.252 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":36,"line":13},"start":{"column":7,"line":13}}},{"id":"151","mutatorName":"PrecomputedMutator","replacement":"this.clear","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.273 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":15,"line":13},"start":{"column":7,"line":13}}},{"id":"152","mutatorName":"PrecomputedMutator","replacement":"this.get","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (8 ms)\n\n    ✕ answers queries correctly (4 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/policy.ts\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.316 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":15,"line":13},"start":{"column":7,"line":13}}},{"id":"153","mutatorName":"PrecomputedMutator","replacement":"policy.name.toLowerCase()","status":"Survived","testsCompleted":1,"location":{"end":{"column":27,"line":13},"start":{"column":16,"line":13}}},{"id":"154","mutatorName":"PrecomputedMutator","replacement":"policy.name.substring(1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (10 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (2 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (5 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.246 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":27,"line":13},"start":{"column":16,"line":13}}},{"id":"155","mutatorName":"PrecomputedMutator","replacement":"policy.name.split('').reverse().join('')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (2 ms)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.242 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":27,"line":13},"start":{"column":16,"line":13}}},{"id":"156","mutatorName":"PrecomputedMutator","replacement":"null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (8 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of null (reading 'matches')\n\n      83 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n      84 |     const policy = stryMutAct_9fa48(\"178\") ? this.set(name) : stryMutAct_9fa48(\"177\") ? this.has(name) : (stryCov_9fa48(\"177\", \"178\"), this.get(stryMutAct_9fa48(\"181\") ? name.substring(1) : stryMutAct_9fa48(\"180\") ? name.toUpperCase() : stryMutAct_9fa48(\"179\") ? \"name\" : (stryCov_9fa48(\"179\", \"180\", \"181\"), name)));\n    > 85 |     return policy !== undefined ? stryMutAct_9fa48(\"186\") ? policy.match(path, ctx) : stryMutAct_9fa48(\"185\") ? policy.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"184\") ? policy.matches(ctx.path) : stryMutAct_9fa48(\"183\") ? policy.matches(path - ctx) : stryMutAct_9fa48(\"182\") ? policy.matches(path + ctx) : (stryCov_9fa48(\"182\", \"183\", \"184\", \"185\", \"186\"), policy.matches(stryMutAct_9fa48(\"189\") ? path.split('/').pop() : stryMutAct_9fa48(\"188\") ? path + 'foo' : stryMutAct_9fa48(\"187\") ? path.toLowerCase() : (stryCov_9fa48(\"187\", \"188\", \"189\"), path), stryMutAct_9fa48(\"192\") ? \"different_context\" : stryMutAct_9fa48(\"191\") ? null : stryMutAct_9fa48(\"190\") ? undefined : (stryCov_9fa48(\"190\", \"191\", \"192\"), ctx))) : false;\n         |                                                                                                                                                                                                                                                                                                                                                                               ^\n      86 |   }\n      87 |\n      88 |   /** Static constructor function; returns a new PolicyMap. */\n\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of null (reading 'query')\n\n      74 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      75 |     const policy = stryMutAct_9fa48(\"161\") ? this.entries(name) : stryMutAct_9fa48(\"160\") ? this.values(name) : stryMutAct_9fa48(\"159\") ? this.has(name) : (stryCov_9fa48(\"159\", \"160\", \"161\"), this.get(stryMutAct_9fa48(\"164\") ? name.replace('a', 'b') : stryMutAct_9fa48(\"163\") ? name.slice(1) : stryMutAct_9fa48(\"162\") ? name.toLowerCase() : (stryCov_9fa48(\"162\", \"163\", \"164\"), name)));\n    > 76 |     return policy !== undefined ? stryMutAct_9fa48(\"167\") ? policy.query(path, verb, \"different context\") : stryMutAct_9fa48(\"166\") ? policy.query(path, verb, undefined) : stryMutAct_9fa48(\"165\") ? policy.query(path + verb, ctx) : (stryCov_9fa48(\"165\", \"166\", \"167\"), policy.query(stryMutAct_9fa48(\"170\") ? path.replace('/', '') : stryMutAct_9fa48(\"169\") ? path.length : stryMutAct_9fa48(\"168\") ? path.toLowerCase() : (stryCov_9fa48(\"168\", \"169\", \"170\"), path), stryMutAct_9fa48(\"173\") ? verb * \"foo\" : stryMutAct_9fa48(\"172\") ? verb - \"foo\" : stryMutAct_9fa48(\"171\") ? verb + \"foo\" : (stryCov_9fa48(\"171\", \"172\", \"173\"), verb), stryMutAct_9fa48(\"176\") ? false : stryMutAct_9fa48(\"175\") ? null : stryMutAct_9fa48(\"174\") ? undefined : (stryCov_9fa48(\"174\", \"175\", \"176\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                    ^\n      77 |   }\n      78 |\n      79 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.672 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":13},"start":{"column":29,"line":13}}},{"id":"157","mutatorName":"PrecomputedMutator","replacement":"undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters (2 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.206 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":13},"start":{"column":29,"line":13}}},{"id":"158","mutatorName":"PrecomputedMutator","replacement":"new Policy()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (18 ms)\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (5 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.304 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":35,"line":13},"start":{"column":29,"line":13}}},{"id":"159","mutatorName":"PrecomputedMutator","replacement":"this.has","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (3 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: policy.query is not a function\n\n      74 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      75 |     const policy = stryMutAct_9fa48(\"161\") ? this.entries(name) : stryMutAct_9fa48(\"160\") ? this.values(name) : stryMutAct_9fa48(\"159\") ? this.has(name) : (stryCov_9fa48(\"159\", \"160\", \"161\"), this.get(stryMutAct_9fa48(\"164\") ? name.replace('a', 'b') : stryMutAct_9fa48(\"163\") ? name.slice(1) : stryMutAct_9fa48(\"162\") ? name.toLowerCase() : (stryCov_9fa48(\"162\", \"163\", \"164\"), name)));\n    > 76 |     return policy !== undefined ? stryMutAct_9fa48(\"167\") ? policy.query(path, verb, \"different context\") : stryMutAct_9fa48(\"166\") ? policy.query(path, verb, undefined) : stryMutAct_9fa48(\"165\") ? policy.query(path + verb, ctx) : (stryCov_9fa48(\"165\", \"166\", \"167\"), policy.query(stryMutAct_9fa48(\"170\") ? path.replace('/', '') : stryMutAct_9fa48(\"169\") ? path.length : stryMutAct_9fa48(\"168\") ? path.toLowerCase() : (stryCov_9fa48(\"168\", \"169\", \"170\"), path), stryMutAct_9fa48(\"173\") ? verb * \"foo\" : stryMutAct_9fa48(\"172\") ? verb - \"foo\" : stryMutAct_9fa48(\"171\") ? verb + \"foo\" : (stryCov_9fa48(\"171\", \"172\", \"173\"), verb), stryMutAct_9fa48(\"176\") ? false : stryMutAct_9fa48(\"175\") ? null : stryMutAct_9fa48(\"174\") ? undefined : (stryCov_9fa48(\"174\", \"175\", \"176\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                    ^\n      77 |   }\n      78 |\n      79 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.335 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":28},"start":{"column":20,"line":28}}},{"id":"160","mutatorName":"PrecomputedMutator","replacement":"this.values","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: policy.query is not a function\n\n      74 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      75 |     const policy = stryMutAct_9fa48(\"161\") ? this.entries(name) : stryMutAct_9fa48(\"160\") ? this.values(name) : stryMutAct_9fa48(\"159\") ? this.has(name) : (stryCov_9fa48(\"159\", \"160\", \"161\"), this.get(stryMutAct_9fa48(\"164\") ? name.replace('a', 'b') : stryMutAct_9fa48(\"163\") ? name.slice(1) : stryMutAct_9fa48(\"162\") ? name.toLowerCase() : (stryCov_9fa48(\"162\", \"163\", \"164\"), name)));\n    > 76 |     return policy !== undefined ? stryMutAct_9fa48(\"167\") ? policy.query(path, verb, \"different context\") : stryMutAct_9fa48(\"166\") ? policy.query(path, verb, undefined) : stryMutAct_9fa48(\"165\") ? policy.query(path + verb, ctx) : (stryCov_9fa48(\"165\", \"166\", \"167\"), policy.query(stryMutAct_9fa48(\"170\") ? path.replace('/', '') : stryMutAct_9fa48(\"169\") ? path.length : stryMutAct_9fa48(\"168\") ? path.toLowerCase() : (stryCov_9fa48(\"168\", \"169\", \"170\"), path), stryMutAct_9fa48(\"173\") ? verb * \"foo\" : stryMutAct_9fa48(\"172\") ? verb - \"foo\" : stryMutAct_9fa48(\"171\") ? verb + \"foo\" : (stryCov_9fa48(\"171\", \"172\", \"173\"), verb), stryMutAct_9fa48(\"176\") ? false : stryMutAct_9fa48(\"175\") ? null : stryMutAct_9fa48(\"174\") ? undefined : (stryCov_9fa48(\"174\", \"175\", \"176\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                    ^\n      77 |   }\n      78 |\n      79 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.167 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":28},"start":{"column":20,"line":28}}},{"id":"161","mutatorName":"PrecomputedMutator","replacement":"this.entries","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (12 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (4 ms)\n\n\n  ● policymap › answers queries correctly\n\n    TypeError: policy.query is not a function\n\n      74 |   query(name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n      75 |     const policy = stryMutAct_9fa48(\"161\") ? this.entries(name) : stryMutAct_9fa48(\"160\") ? this.values(name) : stryMutAct_9fa48(\"159\") ? this.has(name) : (stryCov_9fa48(\"159\", \"160\", \"161\"), this.get(stryMutAct_9fa48(\"164\") ? name.replace('a', 'b') : stryMutAct_9fa48(\"163\") ? name.slice(1) : stryMutAct_9fa48(\"162\") ? name.toLowerCase() : (stryCov_9fa48(\"162\", \"163\", \"164\"), name)));\n    > 76 |     return policy !== undefined ? stryMutAct_9fa48(\"167\") ? policy.query(path, verb, \"different context\") : stryMutAct_9fa48(\"166\") ? policy.query(path, verb, undefined) : stryMutAct_9fa48(\"165\") ? policy.query(path + verb, ctx) : (stryCov_9fa48(\"165\", \"166\", \"167\"), policy.query(stryMutAct_9fa48(\"170\") ? path.replace('/', '') : stryMutAct_9fa48(\"169\") ? path.length : stryMutAct_9fa48(\"168\") ? path.toLowerCase() : (stryCov_9fa48(\"168\", \"169\", \"170\"), path), stryMutAct_9fa48(\"173\") ? verb * \"foo\" : stryMutAct_9fa48(\"172\") ? verb - \"foo\" : stryMutAct_9fa48(\"171\") ? verb + \"foo\" : (stryCov_9fa48(\"171\", \"172\", \"173\"), verb), stryMutAct_9fa48(\"176\") ? false : stryMutAct_9fa48(\"175\") ? null : stryMutAct_9fa48(\"174\") ? undefined : (stryCov_9fa48(\"174\", \"175\", \"176\"), ctx))) : null;\n         |                                                                                                                                                                                                                                                                                    ^\n      77 |   }\n      78 |\n      79 |   /** Check whether a path is governed by a policy in this collection.\n\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.35 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":28},"start":{"column":20,"line":28}}},{"id":"162","mutatorName":"PrecomputedMutator","replacement":"name.toLowerCase()","status":"Survived","testsCompleted":1,"location":{"end":{"column":33,"line":28},"start":{"column":29,"line":28}}},{"id":"163","mutatorName":"PrecomputedMutator","replacement":"name.slice(1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (2 ms)\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.35 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":28},"start":{"column":29,"line":28}}},{"id":"164","mutatorName":"PrecomputedMutator","replacement":"name.replace('a', 'b')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (14 ms)\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly (2 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (7 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.597 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":28},"start":{"column":29,"line":28}}},{"id":"165","mutatorName":"PrecomputedMutator","replacement":"policy.query(path + verb, ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.277 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":30},"start":{"column":9,"line":30}}},{"id":"166","mutatorName":"PrecomputedMutator","replacement":"policy.query(path, verb, undefined)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (4 ms)\n\n    ✕ answers queries correctly (4 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.33 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":30},"start":{"column":9,"line":30}}},{"id":"167","mutatorName":"PrecomputedMutator","replacement":"policy.query(path, verb, \"different context\")","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (7 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (4 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.296 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":38,"line":30},"start":{"column":9,"line":30}}},{"id":"168","mutatorName":"PrecomputedMutator","replacement":"path.toLowerCase()","status":"Survived","testsCompleted":1,"location":{"end":{"column":26,"line":30},"start":{"column":22,"line":30}}},{"id":"169","mutatorName":"PrecomputedMutator","replacement":"path.length","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    TypeError: path.match is not a function\n\n      137 |     * @param ctx Query context for resolving context-dependent paths. */\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n          |                                                                                                                                                                                                                         ^\n      140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n      141 |       return false;\n      142 |     }\n\n      at Rule.matches (src/rule.ts:139:217)\n      at Rule.query (src/rule.ts:129:578)\n      at Policy.query (src/policy.ts:79:176)\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.251 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":26,"line":30},"start":{"column":22,"line":30}}},{"id":"170","mutatorName":"PrecomputedMutator","replacement":"path.replace('/', '')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (2 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (4 ms)\n    ✕ answers queries correctly (5 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.291 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":26,"line":30},"start":{"column":22,"line":30}}},{"id":"171","mutatorName":"PrecomputedMutator","replacement":"verb + \"foo\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (6 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.31 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":30},"start":{"column":28,"line":30}}},{"id":"172","mutatorName":"PrecomputedMutator","replacement":"verb - \"foo\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (5 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.212 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":30},"start":{"column":28,"line":30}}},{"id":"173","mutatorName":"PrecomputedMutator","replacement":"verb * \"foo\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (5 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.267 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":30},"start":{"column":28,"line":30}}},{"id":"174","mutatorName":"PrecomputedMutator","replacement":"undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (2 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.279 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":37,"line":30},"start":{"column":34,"line":30}}},{"id":"175","mutatorName":"PrecomputedMutator","replacement":"null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (3 ms)\n\n    ✓ answers queries correctly (16 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (7 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of null (reading 'maybe')\n\n      147 |       }\n      148 |       for (let index = 0; stryMutAct_9fa48(\"236\") ? index >= count : stryMutAct_9fa48(\"235\") ? index > count : stryMutAct_9fa48(\"234\") ? index <= count : (stryCov_9fa48(\"234\", \"235\", \"236\"), index < count); stryMutAct_9fa48(\"239\") ? index = 0 : stryMutAct_9fa48(\"238\") ? index += 2 : stryMutAct_9fa48(\"237\") ? index-- : (stryCov_9fa48(\"237\", \"238\", \"239\"), index++)) {\n    > 149 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      150 |         if (stryMutAct_9fa48(\"242\") ? prop !== null && match[index + 1] === prop : stryMutAct_9fa48(\"241\") ? prop !== undefined && match[index + 1] === prop : stryMutAct_9fa48(\"240\") ? prop === null || match[index + 1] !== prop : (stryCov_9fa48(\"240\", \"241\", \"242\"), prop === undefined || match[index + 1] !== prop)) {\n      151 |           return false;\n      152 |         }\n\n      at Rule.matches (src/rule.ts:149:25)\n      at Rule.query (src/rule.ts:129:578)\n      at Policy.query (src/policy.ts:79:176)\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.306 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":37,"line":30},"start":{"column":34,"line":30}}},{"id":"176","mutatorName":"PrecomputedMutator","replacement":"false","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (5 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.698 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":37,"line":30},"start":{"column":34,"line":30}}},{"id":"177","mutatorName":"PrecomputedMutator","replacement":"this.has","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (26 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: policy.matches is not a function\n\n      83 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n      84 |     const policy = stryMutAct_9fa48(\"178\") ? this.set(name) : stryMutAct_9fa48(\"177\") ? this.has(name) : (stryCov_9fa48(\"177\", \"178\"), this.get(stryMutAct_9fa48(\"181\") ? name.substring(1) : stryMutAct_9fa48(\"180\") ? name.toUpperCase() : stryMutAct_9fa48(\"179\") ? \"name\" : (stryCov_9fa48(\"179\", \"180\", \"181\"), name)));\n    > 85 |     return policy !== undefined ? stryMutAct_9fa48(\"186\") ? policy.match(path, ctx) : stryMutAct_9fa48(\"185\") ? policy.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"184\") ? policy.matches(ctx.path) : stryMutAct_9fa48(\"183\") ? policy.matches(path - ctx) : stryMutAct_9fa48(\"182\") ? policy.matches(path + ctx) : (stryCov_9fa48(\"182\", \"183\", \"184\", \"185\", \"186\"), policy.matches(stryMutAct_9fa48(\"189\") ? path.split('/').pop() : stryMutAct_9fa48(\"188\") ? path + 'foo' : stryMutAct_9fa48(\"187\") ? path.toLowerCase() : (stryCov_9fa48(\"187\", \"188\", \"189\"), path), stryMutAct_9fa48(\"192\") ? \"different_context\" : stryMutAct_9fa48(\"191\") ? null : stryMutAct_9fa48(\"190\") ? undefined : (stryCov_9fa48(\"190\", \"191\", \"192\"), ctx))) : false;\n         |                                                                                                                                                                                                                                                                                                                                                                               ^\n      86 |   }\n      87 |\n      88 |   /** Static constructor function; returns a new PolicyMap. */\n\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.538 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":39},"start":{"column":20,"line":39}}},{"id":"178","mutatorName":"PrecomputedMutator","replacement":"this.set","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (7 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    RangeError: Maximum call stack size exceeded\n        at PolicyMap.set (<anonymous>)\n\n      82 |     * @param ctx Query context for resolving context-dependent paths. */\n      83 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n    > 84 |     const policy = stryMutAct_9fa48(\"178\") ? this.set(name) : stryMutAct_9fa48(\"177\") ? this.has(name) : (stryCov_9fa48(\"177\", \"178\"), this.get(stryMutAct_9fa48(\"181\") ? name.substring(1) : stryMutAct_9fa48(\"180\") ? name.toUpperCase() : stryMutAct_9fa48(\"179\") ? \"name\" : (stryCov_9fa48(\"179\", \"180\", \"181\"), name)));\n         |                                                   ^\n      85 |     return policy !== undefined ? stryMutAct_9fa48(\"186\") ? policy.match(path, ctx) : stryMutAct_9fa48(\"185\") ? policy.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"184\") ? policy.matches(ctx.path) : stryMutAct_9fa48(\"183\") ? policy.matches(path - ctx) : stryMutAct_9fa48(\"182\") ? policy.matches(path + ctx) : (stryCov_9fa48(\"182\", \"183\", \"184\", \"185\", \"186\"), policy.matches(stryMutAct_9fa48(\"189\") ? path.split('/').pop() : stryMutAct_9fa48(\"188\") ? path + 'foo' : stryMutAct_9fa48(\"187\") ? path.toLowerCase() : (stryCov_9fa48(\"187\", \"188\", \"189\"), path), stryMutAct_9fa48(\"192\") ? \"different_context\" : stryMutAct_9fa48(\"191\") ? null : stryMutAct_9fa48(\"190\") ? undefined : (stryCov_9fa48(\"190\", \"191\", \"192\"), ctx))) : false;\n      86 |   }\n      87 |\n\n      at PolicyMap.matches (src/policymap.ts:84:51)\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at PolicyMap.matches (src/policymap.ts:85:367)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.318 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":39},"start":{"column":20,"line":39}}},{"id":"179","mutatorName":"PrecomputedMutator","replacement":"\"name\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.289 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":39},"start":{"column":29,"line":39}}},{"id":"180","mutatorName":"PrecomputedMutator","replacement":"name.toUpperCase()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.314 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":39},"start":{"column":29,"line":39}}},{"id":"181","mutatorName":"PrecomputedMutator","replacement":"name.substring(1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (7 ms)\n    ✓ rejects empty paths (3 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (8 ms)\n\n    ✓ rejects paths with empty segments (3 ms)\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly (2 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (2 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (3 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.879 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":39},"start":{"column":29,"line":39}}},{"id":"182","mutatorName":"PrecomputedMutator","replacement":"policy.matches(path + ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        3.111 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":41},"start":{"column":9,"line":41}}},{"id":"183","mutatorName":"PrecomputedMutator","replacement":"policy.matches(path - ctx)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: path.match is not a function\n\n      137 |     * @param ctx Query context for resolving context-dependent paths. */\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n          |                                                                                                                                                                                                                         ^\n      140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n      141 |       return false;\n      142 |     }\n\n      at Rule.matches (src/rule.ts:139:217)\n      at Policy.matches (src/policy.ts:95:429)\n      at PolicyMap.matches (src/policymap.ts:85:232)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (18 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.428 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":41},"start":{"column":9,"line":41}}},{"id":"184","mutatorName":"PrecomputedMutator","replacement":"policy.matches(ctx.path)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (14 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (4 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (6 ms)\n    ✓ matches context-dependent paths correctly (12 ms)\n\n    ✓ answers queries correctly (3 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/rule.ts\n  rule\n\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (2 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'match')\n\n      137 |     * @param ctx Query context for resolving context-dependent paths. */\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n          |                                                                                                                                                                                                                         ^\n      140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n      141 |       return false;\n      142 |     }\n\n      at Rule.matches (src/rule.ts:139:217)\n      at Policy.matches (src/policy.ts:95:429)\n      at PolicyMap.matches (src/policymap.ts:85:179)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.428 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":41},"start":{"column":9,"line":41}}},{"id":"185","mutatorName":"PrecomputedMutator","replacement":"policy.doesNotMatch","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (2 ms)\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (3 ms)\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: policy.doesNotMatch is not a function\n\n      83 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n      84 |     const policy = stryMutAct_9fa48(\"178\") ? this.set(name) : stryMutAct_9fa48(\"177\") ? this.has(name) : (stryCov_9fa48(\"177\", \"178\"), this.get(stryMutAct_9fa48(\"181\") ? name.substring(1) : stryMutAct_9fa48(\"180\") ? name.toUpperCase() : stryMutAct_9fa48(\"179\") ? \"name\" : (stryCov_9fa48(\"179\", \"180\", \"181\"), name)));\n    > 85 |     return policy !== undefined ? stryMutAct_9fa48(\"186\") ? policy.match(path, ctx) : stryMutAct_9fa48(\"185\") ? policy.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"184\") ? policy.matches(ctx.path) : stryMutAct_9fa48(\"183\") ? policy.matches(path - ctx) : stryMutAct_9fa48(\"182\") ? policy.matches(path + ctx) : (stryCov_9fa48(\"182\", \"183\", \"184\", \"185\", \"186\"), policy.matches(stryMutAct_9fa48(\"189\") ? path.split('/').pop() : stryMutAct_9fa48(\"188\") ? path + 'foo' : stryMutAct_9fa48(\"187\") ? path.toLowerCase() : (stryCov_9fa48(\"187\", \"188\", \"189\"), path), stryMutAct_9fa48(\"192\") ? \"different_context\" : stryMutAct_9fa48(\"191\") ? null : stryMutAct_9fa48(\"190\") ? undefined : (stryCov_9fa48(\"190\", \"191\", \"192\"), ctx))) : false;\n         |                                                                                                                        ^\n      86 |   }\n      87 |\n      88 |   /** Static constructor function; returns a new PolicyMap. */\n\n      at PolicyMap.matches (src/policymap.ts:85:120)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nPASS test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.491 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":41},"start":{"column":9,"line":41}}},{"id":"186","mutatorName":"PrecomputedMutator","replacement":"policy.match","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (3 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: policy.match is not a function\n\n      83 |   matches(name: string, path: string, ctx?: QueryContext): boolean {\n      84 |     const policy = stryMutAct_9fa48(\"178\") ? this.set(name) : stryMutAct_9fa48(\"177\") ? this.has(name) : (stryCov_9fa48(\"177\", \"178\"), this.get(stryMutAct_9fa48(\"181\") ? name.substring(1) : stryMutAct_9fa48(\"180\") ? name.toUpperCase() : stryMutAct_9fa48(\"179\") ? \"name\" : (stryCov_9fa48(\"179\", \"180\", \"181\"), name)));\n    > 85 |     return policy !== undefined ? stryMutAct_9fa48(\"186\") ? policy.match(path, ctx) : stryMutAct_9fa48(\"185\") ? policy.doesNotMatch(path, ctx) : stryMutAct_9fa48(\"184\") ? policy.matches(ctx.path) : stryMutAct_9fa48(\"183\") ? policy.matches(path - ctx) : stryMutAct_9fa48(\"182\") ? policy.matches(path + ctx) : (stryCov_9fa48(\"182\", \"183\", \"184\", \"185\", \"186\"), policy.matches(stryMutAct_9fa48(\"189\") ? path.split('/').pop() : stryMutAct_9fa48(\"188\") ? path + 'foo' : stryMutAct_9fa48(\"187\") ? path.toLowerCase() : (stryCov_9fa48(\"187\", \"188\", \"189\"), path), stryMutAct_9fa48(\"192\") ? \"different_context\" : stryMutAct_9fa48(\"191\") ? null : stryMutAct_9fa48(\"190\") ? undefined : (stryCov_9fa48(\"190\", \"191\", \"192\"), ctx))) : false;\n         |                                                                    ^\n      86 |   }\n      87 |\n      88 |   /** Static constructor function; returns a new PolicyMap. */\n\n      at PolicyMap.matches (src/policymap.ts:85:68)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.508 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":41},"start":{"column":9,"line":41}}},{"id":"187","mutatorName":"PrecomputedMutator","replacement":"path.toLowerCase()","status":"Survived","testsCompleted":1,"location":{"end":{"column":28,"line":41},"start":{"column":24,"line":41}}},{"id":"188","mutatorName":"PrecomputedMutator","replacement":"path + 'foo'","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (6 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.949 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":41},"start":{"column":24,"line":41}}},{"id":"189","mutatorName":"PrecomputedMutator","replacement":"path.split('/').pop()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (2 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.331 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":41},"start":{"column":24,"line":41}}},{"id":"190","mutatorName":"PrecomputedMutator","replacement":"undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (8 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✓ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.281 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":41},"start":{"column":30,"line":41}}},{"id":"191","mutatorName":"PrecomputedMutator","replacement":"null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (10 ms)\n\n    ✓ answers context-dependent queries correctly (8 ms)\n    ✓ prioritises deny over allow (6 ms)\n    ✓ clones itself correctly (1 ms)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (10 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of null (reading 'maybe')\n\n      147 |       }\n      148 |       for (let index = 0; stryMutAct_9fa48(\"236\") ? index >= count : stryMutAct_9fa48(\"235\") ? index > count : stryMutAct_9fa48(\"234\") ? index <= count : (stryCov_9fa48(\"234\", \"235\", \"236\"), index < count); stryMutAct_9fa48(\"239\") ? index = 0 : stryMutAct_9fa48(\"238\") ? index += 2 : stryMutAct_9fa48(\"237\") ? index-- : (stryCov_9fa48(\"237\", \"238\", \"239\"), index++)) {\n    > 149 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      150 |         if (stryMutAct_9fa48(\"242\") ? prop !== null && match[index + 1] === prop : stryMutAct_9fa48(\"241\") ? prop !== undefined && match[index + 1] === prop : stryMutAct_9fa48(\"240\") ? prop === null || match[index + 1] !== prop : (stryCov_9fa48(\"240\", \"241\", \"242\"), prop === undefined || match[index + 1] !== prop)) {\n      151 |           return false;\n      152 |         }\n\n      at Rule.matches (src/rule.ts:149:25)\n      at Policy.matches (src/policy.ts:95:429)\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.375 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":41},"start":{"column":30,"line":41}}},{"id":"192","mutatorName":"PrecomputedMutator","replacement":"\"different_context\"","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (17 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/policy.ts\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 1 failed, 3 passed, 4 total\nTests:       1 failed, 37 passed, 38 total\nSnapshots:   0 total\nTime:        2.425 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":33,"line":41},"start":{"column":30,"line":41}}}],"source":"import { Policy } from './policy'\nimport { QueryableMap, QueryContext } from './queryable'\n\n/** Queryable collection of policy documents. */\nexport class PolicyMap extends Map<string, Policy> implements QueryableMap {\n  constructor (...policies: Policy[]) {\n    super(policies.map((policy) => [policy.name, policy]))\n  }\n\n  /** Add policies to colllection. */\n  push (...policies: Policy[]): this {\n    for (const policy of policies) {\n      this.set(policy.name, policy)\n    }\n    return this\n  }\n\n  /** Check whether an action is allowed on a path.\n    * @param name Policy to be queried.\n    * @param path Path to be acted on.\n    * @param verb Action to be performed.\n    * @param ctx Query context for resolving context-dependent paths.\n    * @returns Returns `true` if the action is explicitly allowed,\n    *          `false` if the action is explicitly denied, or\n    *          `null` if the combination of policy, path and\n    *          action is not governed by this collection. */\n  query (name: string, path: string, verb: string, ctx?: QueryContext): boolean | null {\n    const policy = this.get(name)\n    return policy !== undefined\n      ? policy.query(path, verb, ctx)\n      : null\n  }\n\n  /** Check whether a path is governed by a policy in this collection.\n    * @param name Policy to be queried.\n    * @param path Path to be checked.\n    * @param ctx Query context for resolving context-dependent paths. */\n  matches (name: string, path: string, ctx?: QueryContext): boolean {\n    const policy = this.get(name)\n    return policy !== undefined\n      ? policy.matches(path, ctx)\n      : false\n  }\n\n  /** Static constructor function; returns a new PolicyMap. */\n  static for (...policies: Policy[]): PolicyMap {\n    return new PolicyMap(...policies)\n  }\n}\n"},"src/rule.ts":{"language":"typescript","mutants":[{"id":"193","mutatorName":"PrecomputedMutator","replacement":"for (const verb of this.verbs) {\n  if (!(verb in this.verbs)) {\n    this.verbs[verb] = true;\n  }\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n  rule\n\n    ✓ matches paths correctly (10 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n\n\n  ● rule › answers queries correctly\n\n    TypeError: this.verbs is not iterable\n\n      83 |       }\n      84 |     } else if (stryMutAct_9fa48(\"193\")) {\n    > 85 |       for (const verb of this.verbs) {\n         |                               ^\n      86 |         if (!(verb in this.verbs)) {\n      87 |           this.verbs[verb] = true;\n      88 |         }\n\n      at Rule.allow (src/rule.ts:85:31)\n      at Object.<anonymous> (test/rule.ts:61:10)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: this.verbs is not iterable\n\n      83 |       }\n      84 |     } else if (stryMutAct_9fa48(\"193\")) {\n    > 85 |       for (const verb of this.verbs) {\n         |                               ^\n      86 |         if (!(verb in this.verbs)) {\n      87 |           this.verbs[verb] = true;\n      88 |         }\n\n      at Rule.allow (src/rule.ts:85:31)\n      at Object.<anonymous> (test/rule.ts:77:10)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: this.verbs is not iterable\n\n      83 |       }\n      84 |     } else if (stryMutAct_9fa48(\"193\")) {\n    > 85 |       for (const verb of this.verbs) {\n         |                               ^\n      86 |         if (!(verb in this.verbs)) {\n      87 |           this.verbs[verb] = true;\n      88 |         }\n\n      at Rule.allow (src/rule.ts:85:31)\n      at Object.<anonymous> (test/rule.ts:107:10)\n\n  ● rule › clones itself correctly\n\n    TypeError: this.verbs is not iterable\n\n      83 |       }\n      84 |     } else if (stryMutAct_9fa48(\"193\")) {\n    > 85 |       for (const verb of this.verbs) {\n         |                               ^\n      86 |         if (!(verb in this.verbs)) {\n      87 |           this.verbs[verb] = true;\n      88 |         }\n\n      at Rule.allow (src/rule.ts:85:31)\n      at Object.<anonymous> (test/rule.ts:123:10)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly\n\n  ● policymap › answers queries correctly\n\n    TypeError: this.verbs is not iterable\n\n      83 |       }\n      84 |     } else if (stryMutAct_9fa48(\"193\")) {\n    > 85 |       for (const verb of this.verbs) {\n         |                               ^\n      86 |         if (!(verb in this.verbs)) {\n      87 |           this.verbs[verb] = true;\n      88 |         }\n\n      at Rule.allow (src/rule.ts:85:31)\n      at Object.<anonymous> (test/policymap.ts:54:27)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    TypeError: this.verbs is not iterable\n\n      83 |       }\n      84 |     } else if (stryMutAct_9fa48(\"193\")) {\n    > 85 |       for (const verb of this.verbs) {\n         |                               ^\n      86 |         if (!(verb in this.verbs)) {\n      87 |           this.verbs[verb] = true;\n      88 |         }\n\n      at Rule.allow (src/rule.ts:85:31)\n      at Object.<anonymous> (test/policy.ts:58:26)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: this.verbs is not iterable\n\n      83 |       }\n      84 |     } else if (stryMutAct_9fa48(\"193\")) {\n    > 85 |       for (const verb of this.verbs) {\n         |                               ^\n      86 |         if (!(verb in this.verbs)) {\n      87 |           this.verbs[verb] = true;\n      88 |         }\n\n      at Rule.allow (src/rule.ts:85:31)\n      at Object.<anonymous> (test/policy.ts:80:27)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: this.verbs is not iterable\n\n      83 |       }\n      84 |     } else if (stryMutAct_9fa48(\"193\")) {\n    > 85 |       for (const verb of this.verbs) {\n         |                               ^\n      86 |         if (!(verb in this.verbs)) {\n      87 |           this.verbs[verb] = true;\n      88 |         }\n\n      at Rule.allow (src/rule.ts:85:31)\n      at Object.<anonymous> (test/policy.ts:103:26)\n\n  ● policy › clones itself correctly\n\n    TypeError: this.verbs is not iterable\n\n      83 |       }\n      84 |     } else if (stryMutAct_9fa48(\"193\")) {\n    > 85 |       for (const verb of this.verbs) {\n         |                               ^\n      86 |         if (!(verb in this.verbs)) {\n      87 |           this.verbs[verb] = true;\n      88 |         }\n\n      at Rule.allow (src/rule.ts:85:31)\n      at Object.<anonymous> (test/policy.ts:120:36)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.538 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":29},"start":{"column":5,"line":25}}},{"id":"194","mutatorName":"PrecomputedMutator","replacement":"for (const verb of verbs.values()) {\n  if (!(verb in this.verbs)) {\n    this.verbs[verb] = true;\n  }\n}","status":"Survived","testsCompleted":1,"location":{"end":{"column":6,"line":29},"start":{"column":5,"line":25}}},{"id":"195","mutatorName":"PrecomputedMutator","replacement":"for (const verb of verbs.keys()) {\n  if (!(verb in this.verbs)) {\n    this.verbs[verb] = true;\n  }\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (5 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'bar') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.643 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":29},"start":{"column":5,"line":25}}},{"id":"196","mutatorName":"PrecomputedMutator","replacement":"verbs.keys()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (4 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'bar') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.431 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":29,"line":25},"start":{"column":24,"line":25}}},{"id":"197","mutatorName":"PrecomputedMutator","replacement":"Object.keys(verbs)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (5 ms)\n    ✕ answers context-dependent queries correctly (2 ms)\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'bar') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (3 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.526 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":29,"line":25},"start":{"column":24,"line":25}}},{"id":"198","mutatorName":"PrecomputedMutator","replacement":"verb in this.verbs","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (8 ms)\n    ✕ answers queries correctly (8 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (6 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (4 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'bar') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        2.409 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":26},"start":{"column":11,"line":26}}},{"id":"199","mutatorName":"PrecomputedMutator","replacement":"this.verbs[verb]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (2 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'bar') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'bar') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (5 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'baz') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.366 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":26},"start":{"column":11,"line":26}}},{"id":"200","mutatorName":"PrecomputedMutator","replacement":"this.verbs[verb] === undefined","status":"Survived","testsCompleted":1,"location":{"end":{"column":32,"line":26},"start":{"column":11,"line":26}}},{"id":"201","mutatorName":"PrecomputedMutator","replacement":"for (let verb of verbs) {\n  this.verbs[verb] = false;\n}","status":"Survived","testsCompleted":1,"location":{"end":{"column":6,"line":37},"start":{"column":5,"line":35}}},{"id":"202","mutatorName":"PrecomputedMutator","replacement":"for (const verbs of verbs) {\n  this.verbs[verb] = false;\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (6 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    ReferenceError: Cannot access 'verbs' before initialization\n\n      102 |   deny(...verbs: string[]): Rule {\n      103 |     if (stryMutAct_9fa48(\"202\")) {\n    > 104 |       for (const verbs of verbs) {\n          |                           ^\n      105 |         this.verbs[verb] = false;\n      106 |       }\n      107 |     } else if (stryMutAct_9fa48(\"201\")) {\n\n      at Rule.deny (src/rule.ts:104:27)\n      at Object.<anonymous> (test/policy.ts:60:24)\n\n  ● policy › answers context-dependent queries correctly\n\n    ReferenceError: Cannot access 'verbs' before initialization\n\n      102 |   deny(...verbs: string[]): Rule {\n      103 |     if (stryMutAct_9fa48(\"202\")) {\n    > 104 |       for (const verbs of verbs) {\n          |                           ^\n      105 |         this.verbs[verb] = false;\n      106 |       }\n      107 |     } else if (stryMutAct_9fa48(\"201\")) {\n\n      at Rule.deny (src/rule.ts:104:27)\n      at Object.<anonymous> (test/policy.ts:82:27)\n\n  ● policy › prioritises deny over allow\n\n    ReferenceError: Cannot access 'verbs' before initialization\n\n      102 |   deny(...verbs: string[]): Rule {\n      103 |     if (stryMutAct_9fa48(\"202\")) {\n    > 104 |       for (const verbs of verbs) {\n          |                           ^\n      105 |         this.verbs[verb] = false;\n      106 |       }\n      107 |     } else if (stryMutAct_9fa48(\"201\")) {\n\n      at Rule.deny (src/rule.ts:104:27)\n      at Object.<anonymous> (test/policy.ts:102:24)\n\n  ● policy › clones itself correctly\n\n    ReferenceError: Cannot access 'verbs' before initialization\n\n      102 |   deny(...verbs: string[]): Rule {\n      103 |     if (stryMutAct_9fa48(\"202\")) {\n    > 104 |       for (const verbs of verbs) {\n          |                           ^\n      105 |         this.verbs[verb] = false;\n      106 |       }\n      107 |     } else if (stryMutAct_9fa48(\"201\")) {\n\n      at Rule.deny (src/rule.ts:104:27)\n      at Object.<anonymous> (test/policy.ts:125:10)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (5 ms)\n    ✕ answers queries correctly\n\n  ● policymap › answers queries correctly\n\n    ReferenceError: Cannot access 'verbs' before initialization\n\n      102 |   deny(...verbs: string[]): Rule {\n      103 |     if (stryMutAct_9fa48(\"202\")) {\n    > 104 |       for (const verbs of verbs) {\n          |                           ^\n      105 |         this.verbs[verb] = false;\n      106 |       }\n      107 |     } else if (stryMutAct_9fa48(\"201\")) {\n\n      at Rule.deny (src/rule.ts:104:27)\n      at Object.<anonymous> (test/policymap.ts:53:26)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● rule › answers queries correctly\n\n    ReferenceError: Cannot access 'verbs' before initialization\n\n      102 |   deny(...verbs: string[]): Rule {\n      103 |     if (stryMutAct_9fa48(\"202\")) {\n    > 104 |       for (const verbs of verbs) {\n          |                           ^\n      105 |         this.verbs[verb] = false;\n      106 |       }\n      107 |     } else if (stryMutAct_9fa48(\"201\")) {\n\n      at Rule.deny (src/rule.ts:104:27)\n      at Object.<anonymous> (test/rule.ts:60:10)\n\n  ● rule › answers context-dependent queries correctly\n\n    ReferenceError: Cannot access 'verbs' before initialization\n\n      102 |   deny(...verbs: string[]): Rule {\n      103 |     if (stryMutAct_9fa48(\"202\")) {\n    > 104 |       for (const verbs of verbs) {\n          |                           ^\n      105 |         this.verbs[verb] = false;\n      106 |       }\n      107 |     } else if (stryMutAct_9fa48(\"201\")) {\n\n      at Rule.deny (src/rule.ts:104:27)\n      at Object.<anonymous> (test/rule.ts:76:10)\n\n  ● rule › prioritises deny over allow\n\n    ReferenceError: Cannot access 'verbs' before initialization\n\n      102 |   deny(...verbs: string[]): Rule {\n      103 |     if (stryMutAct_9fa48(\"202\")) {\n    > 104 |       for (const verbs of verbs) {\n          |                           ^\n      105 |         this.verbs[verb] = false;\n      106 |       }\n      107 |     } else if (stryMutAct_9fa48(\"201\")) {\n\n      at Rule.deny (src/rule.ts:104:27)\n      at Object.<anonymous> (test/rule.ts:106:10)\n\n  ● rule › clones itself correctly\n\n    ReferenceError: Cannot access 'verbs' before initialization\n\n      102 |   deny(...verbs: string[]): Rule {\n      103 |     if (stryMutAct_9fa48(\"202\")) {\n    > 104 |       for (const verbs of verbs) {\n          |                           ^\n      105 |         this.verbs[verb] = false;\n      106 |       }\n      107 |     } else if (stryMutAct_9fa48(\"201\")) {\n\n      at Rule.deny (src/rule.ts:104:27)\n      at Object.<anonymous> (test/rule.ts:122:10)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.252 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":37},"start":{"column":5,"line":35}}},{"id":"203","mutatorName":"PrecomputedMutator","replacement":"verbs.reverse()","status":"Survived","testsCompleted":1,"location":{"end":{"column":29,"line":35},"start":{"column":24,"line":35}}},{"id":"204","mutatorName":"PrecomputedMutator","replacement":"verbs.slice(1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (2 ms)\n\n    ✕ answers queries correctly (6 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'boo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        2.277 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":29,"line":35},"start":{"column":24,"line":35}}},{"id":"205","mutatorName":"PrecomputedMutator","replacement":"verbs.pop()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (5 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (4 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (3 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'boo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        2.265 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":29,"line":35},"start":{"column":24,"line":35}}},{"id":"206","mutatorName":"PrecomputedMutator","replacement":"this.matches(path, ctx) || verb in this.verbs","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (8 ms)\n    ✕ answers context-dependent queries correctly (2 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (2 ms)\n    ✓ compiles capture segments correctly (3 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/nah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('/', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (2 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.267 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":54,"line":50},"start":{"column":9,"line":50}}},{"id":"207","mutatorName":"PrecomputedMutator","replacement":"this.matches(path, ctx) && !(verb in this.verbs)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (5 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.24 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":54,"line":50},"start":{"column":9,"line":50}}},{"id":"208","mutatorName":"PrecomputedMutator","replacement":"this.matches(path, ctx) && this.verbs[verb]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly (2 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (6 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'boo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       8 failed, 30 passed, 38 total\nSnapshots:   0 total\nTime:        2.237 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":54,"line":50},"start":{"column":9,"line":50}}},{"id":"209","mutatorName":"PrecomputedMutator","replacement":"this.matches(path.match(this.regex)[0])","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly (2 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of null (reading '0')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:522)\n      at Policy.query (src/policy.ts:79:176)\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (2 ms)\n    ✕ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of null (reading '0')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:522)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of null (reading '0')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:522)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:109:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (2 ms)\n\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › answers queries correctly\n\n    TypeError: Cannot read properties of null (reading '0')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:522)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    TypeError: Cannot read properties of null (reading '0')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:522)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       7 failed, 31 passed, 38 total\nSnapshots:   0 total\nTime:        2.231 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":50},"start":{"column":9,"line":50}}},{"id":"210","mutatorName":"PrecomputedMutator","replacement":"this.matches(path.replace(this.regex, ''))","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (10 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✕ answers queries correctly (3 ms)\n\n    ✕ answers context-dependent queries correctly (3 ms)\n\n    ✕ prioritises deny over allow (4 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✕ answers queries correctly (8 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.451 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":50},"start":{"column":9,"line":50}}},{"id":"211","mutatorName":"PrecomputedMutator","replacement":"this.matches(path.split(this.regex))","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.query (src/rule.ts:129:369)\n      at Policy.query (src/policy.ts:79:176)\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (10 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › answers queries correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.query (src/rule.ts:129:369)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.query (src/rule.ts:129:369)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.query (src/rule.ts:129:369)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.query (src/rule.ts:129:369)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › answers queries correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.query (src/rule.ts:129:369)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.query (src/rule.ts:129:369)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.query (src/rule.ts:129:369)\n      at Object.<anonymous> (test/rule.ts:108:10)\n\n  ● rule › clones itself correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.query (src/rule.ts:129:369)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.316 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":32,"line":50},"start":{"column":9,"line":50}}},{"id":"212","mutatorName":"PrecomputedMutator","replacement":"!this.matches","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › answers queries correctly\n\n    TypeError: (!this.matches) is not a function\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                       ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:311)\n      at Policy.query (src/policy.ts:79:176)\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    TypeError: (!this.matches) is not a function\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                       ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:311)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: (!this.matches) is not a function\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                       ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:311)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: (!this.matches) is not a function\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                       ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:311)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: (!this.matches) is not a function\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                       ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:311)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly\n\n\n  ● rule › answers queries correctly\n\n    TypeError: (!this.matches) is not a function\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                       ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:311)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: (!this.matches) is not a function\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                       ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:311)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: (!this.matches) is not a function\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                       ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:311)\n      at Object.<anonymous> (test/rule.ts:108:10)\n\n  ● rule › clones itself correctly\n\n    TypeError: (!this.matches) is not a function\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                       ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:311)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        3.342 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":21,"line":50},"start":{"column":9,"line":50}}},{"id":"213","mutatorName":"PrecomputedMutator","replacement":"path.toLowerCase()","status":"Survived","testsCompleted":1,"location":{"end":{"column":26,"line":50},"start":{"column":22,"line":50}}},{"id":"214","mutatorName":"PrecomputedMutator","replacement":"path.substring(1)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (2 ms)\n    ✕ answers queries correctly (10 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (2 ms)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'deny first'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for policy 'original'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (3 ms)\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (6 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/test', 'foo') for rule '/test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/:maybe'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/yeah', 'foo') for rule '/yeah'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      155 |         `unexpected result from query('${test[0]}', '${test[2]}') for rule '${opts.rule.regex.spec}'`)\n      156 |     }\n      157 |   }\n\n      at runTests (test/rule.ts:154:18)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.873 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":26,"line":50},"start":{"column":22,"line":50}}},{"id":"215","mutatorName":"PrecomputedMutator","replacement":"path.split('/')","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes (2 ms)\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n    ✓ compiles match-one-or-none wildcard segments correctly (2 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly (16 ms)\n    ✓ compiles combinations of wildcard segments correctly (2 ms)\n    ✓ compiles capture segments correctly (2 ms)\n    ✓ matches literal path segments correctly (5 ms)\n    ✓ matches match-one wildcard segments correctly (3 ms)\n    ✓ matches match-many wildcard segments correctly (19 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (3 ms)\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (18 ms)\n      ✓ rejects specs with match-many-or-none wildcards (130 ms)\n\n\nFAIL test/policy.ts (5.489 s)\n  policy\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly (2 ms)\n    ✕ answers queries correctly (3 ms)\n    ✕ answers context-dependent queries correctly (14 ms)\n    ✕ prioritises deny over allow (2 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › answers queries correctly\n\n    TypeError: path.match is not a function\n\n      137 |     * @param ctx Query context for resolving context-dependent paths. */\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n          |                                                                                                                                                                                                                         ^\n      140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n      141 |       return false;\n      142 |     }\n\n      at Rule.matches (src/rule.ts:139:217)\n      at Rule.query (src/rule.ts:129:578)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: path.match is not a function\n\n      137 |     * @param ctx Query context for resolving context-dependent paths. */\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n          |                                                                                                                                                                                                                         ^\n      140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n      141 |       return false;\n      142 |     }\n\n      at Rule.matches (src/rule.ts:139:217)\n      at Rule.query (src/rule.ts:129:578)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: path.match is not a function\n\n      137 |     * @param ctx Query context for resolving context-dependent paths. */\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n          |                                                                                                                                                                                                                         ^\n      140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n      141 |       return false;\n      142 |     }\n\n      at Rule.matches (src/rule.ts:139:217)\n      at Rule.query (src/rule.ts:129:578)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: path.match is not a function\n\n      137 |     * @param ctx Query context for resolving context-dependent paths. */\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n          |                                                                                                                                                                                                                         ^\n      140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n      141 |       return false;\n      142 |     }\n\n      at Rule.matches (src/rule.ts:139:217)\n      at Rule.query (src/rule.ts:129:578)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts (5.536 s)\n\n  policymap\n    ✓ matches queries correctly (5 ms)\n\n    ✕ answers queries correctly (5 ms)\n\n\n  ● policymap › answers queries correctly\n\n    TypeError: path.match is not a function\n\n      137 |     * @param ctx Query context for resolving context-dependent paths. */\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n          |                                                                                                                                                                                                                         ^\n      140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n      141 |       return false;\n      142 |     }\n\n      at Rule.matches (src/rule.ts:139:217)\n      at Rule.query (src/rule.ts:129:578)\n      at Policy.query (src/policy.ts:79:176)\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nFAIL test/rule.ts (5.624 s)\n\n  rule\n    ✓ matches paths correctly (7 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow (2 ms)\n    ✕ clones itself correctly (2 ms)\n\n\n\n  ● rule › answers queries correctly\n\n    TypeError: path.match is not a function\n\n      137 |     * @param ctx Query context for resolving context-dependent paths. */\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n          |                                                                                                                                                                                                                         ^\n      140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n      141 |       return false;\n      142 |     }\n\n      at Rule.matches (src/rule.ts:139:217)\n      at Rule.query (src/rule.ts:129:578)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: path.match is not a function\n\n      137 |     * @param ctx Query context for resolving context-dependent paths. */\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n          |                                                                                                                                                                                                                         ^\n      140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n      141 |       return false;\n      142 |     }\n\n      at Rule.matches (src/rule.ts:139:217)\n      at Rule.query (src/rule.ts:129:578)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: path.match is not a function\n\n      137 |     * @param ctx Query context for resolving context-dependent paths. */\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n          |                                                                                                                                                                                                                         ^\n      140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n      141 |       return false;\n      142 |     }\n\n      at Rule.matches (src/rule.ts:139:217)\n      at Rule.query (src/rule.ts:129:578)\n      at Object.<anonymous> (test/rule.ts:108:10)\n\n  ● rule › clones itself correctly\n\n    TypeError: path.match is not a function\n\n      137 |     * @param ctx Query context for resolving context-dependent paths. */\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n    > 139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n          |                                                                                                                                                                                                                         ^\n      140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n      141 |       return false;\n      142 |     }\n\n      at Rule.matches (src/rule.ts:139:217)\n      at Rule.query (src/rule.ts:129:578)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        5.904 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":26,"line":50},"start":{"column":22,"line":50}}},{"id":"216","mutatorName":"PrecomputedMutator","replacement":"ctx.length","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (6 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (3 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:875)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:875)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule\n.query (src/rule.ts:129:875)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (11 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments (9 ms)\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (4 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly (13 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (5 ms)\n    ✓ matches match-many-or-none wildcard segments correctly (2 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (6 ms)\n    ✕ answers queries correctly (7 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (5 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● rule › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:875)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:875)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:875)\n      at Object.<anonymous> (test/rule.ts:108:10)\n\n  ● rule › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'length')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct\n_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:875)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        3.845 s, estimated 6 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":31,"line":50},"start":{"column":28,"line":50}}},{"id":"217","mutatorName":"PrecomputedMutator","replacement":"ctx.toString()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'toString')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:832)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'toString')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:832)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'toString')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:832)\n      at Object.<anonymous> (test/rule.ts:108:10)\n\n  ● rule › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'toString')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                            \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:832)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths (5 ms)\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (8 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'toString')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:832)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading 'toString')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:832)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading 'toString')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:832)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✕ answers queries correctly (3 ms)\n\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.953 s, estimated 4 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":31,"line":50},"start":{"column":28,"line":50}}},{"id":"218","mutatorName":"PrecomputedMutator","replacement":"ctx[0]","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policymap.ts\n  policymap\n    ✓ matches queries correctly (10 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (3 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading '0')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:796)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading '0')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:796)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading '0')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:796)\n      at Policy.query (src/policy.ts:79:176)\n      at runTests (test/policy.ts:173:31)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › answers queries correctly\n\n    TypeError: Cannot read properties of undefined (reading '0')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:796)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading '0')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:796)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: Cannot read properties of undefined (reading '0')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:796)\n      at Object.<anonymous> (test/rule.ts:108:10)\n\n  ● rule › clones itself correctly\n\n    TypeError: Cannot read properties of undefined (reading '0')\n\n      127 |     *          is not governed by this rule. */\n      128 |   query(path: string, verb: string, ctx?: QueryContext): boolean | null {\n    > 129 |     if (stryMutAct_9fa48(\"208\") ? this.matches(path, ctx) && this.verbs[verb] : stryMutAct_9fa48(\"207\") ? this.matches(path, ctx) && !(verb in this.verbs) : stryMutAct_9fa48(\"206\") ? this.matches(path, ctx) || verb in this.verbs : (stryCov_9fa48(\"206\", \"207\", \"208\"), (stryMutAct_9fa48(\"212\") ? (!this.matches)(path, ctx) : stryMutAct_9fa48(\"211\") ? this.matches(path.split(this.regex)) : stryMutAct_9fa48(\"210\") ? this.matches(path.replace(this.regex, '')) : stryMutAct_9fa48(\"209\") ? this.matches(path.match(this.regex)[0]) : (stryCov_9fa48(\"209\", \"210\", \"211\", \"212\"), this.matches(stryMutAct_9fa48(\"215\") ? path.split('/') : stryMutAct_9fa48(\"214\") ? path.substring(1) : stryMutAct_9fa48(\"213\") ? path.toLowerCase() : (stryCov_9fa48(\"213\", \"214\", \"215\"), path), stryMutAct_9fa48(\"218\") ? ctx[0] : stryMutAct_9fa48(\"217\") ? ctx.toString() : stryMutAct_9fa48(\"216\") ? ctx.length : (stryCov_9fa48(\"216\", \"217\", \"218\"), ctx)))) && verb in this.verbs)) {\n          |                                                                                                                                                                                                                                    \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^\n      130 |       return this.verbs[verb];\n      131 |     }\n      132 |     return null;\n\n      at Rule.query (src/rule.ts:129:796)\n      at runTests (test/rule.ts:154:29)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.729 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":31,"line":50},"start":{"column":28,"line":50}}},{"id":"219","mutatorName":"PrecomputedMutator","replacement":"path.search","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (8 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (4 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       11 failed, 27 passed, 38 total\nSnapshots:   0 total\nTime:        2.603 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":29,"line":60},"start":{"column":19,"line":60}}},{"id":"220","mutatorName":"PrecomputedMutator","replacement":"path.split","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly (15 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (3 ms)\n    ✕ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.matches (src/rule.ts:139:103)\n      at Policy.matches (src/policy.ts:95:429)\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.matches (src/rule.ts:139:103)\n      at Rule.query (src/rule.ts:129:578)\n      at Policy.query (src/policy.ts:79:176)\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.matches (src/rule.ts:139:103)\n      at Policy.matches (src/policy.ts:95:429)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.matches (src/rule.ts:139:103)\n      at Policy.matches (src/policy.ts:95:429)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.matches (src/rule.ts:139:103)\n      at Policy.matches (src/policy.ts:95:429)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.matches (src/rule.ts:139:103)\n      at Policy.matches (src/policy.ts:95:429)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/\n^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.matches (src/rule.ts:139:103)\n      at Policy.matches (src/policy.ts:95:429)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.matches (src/rule.ts:139:103)\n      at Policy.matches (src/policy.ts:95:429)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.matches (src/rule.ts:139:103)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.matches (src/rule.ts:139:103)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.matches (src/rule.ts:139:103)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.matches (src/rule.ts:139:103)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9f\na48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.matches (src/rule.ts:139:103)\n      at Rule.query (src/rule.ts:129:578)\n      at Object.<anonymous> (test/rule.ts:108:10)\n\n  ● rule › clones itself correctly\n\n    TypeError: spec.match is not a function\n\n      56 |     * @param version Specification language version. */\n      57 |   constructor(spec: string, version: '1' | '1.0' | '1.1' = '1.1') {\n    > 58 |     if (stryMutAct_9fa48(\"1\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) === null && spec.length > 0 : stryMutAct_9fa48(\"0\") ? spec.match(/^[a-zA-Z0-9_/:~.$+*-]*$/) !== null : (stryCov_9fa48(\"0\", \"1\"), (stryMutAct_9fa48(\"4\") ? spec.split(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"3\") ? spec.replace(/^[a-zA-Z0-9_/:~.$+*-]*$/) : stryMutAct_9fa48(\"2\") ? spec.search(/^[a-zA-Z0-9_/:~.$+*-]*$/) : (stryCov_9fa48(\"2\", \"3\", \"4\"), spec.match(stryMutAct_9fa48(\"6\") ? /^[a-zA-Z0-9_/:~.$+*-]{0}$/ : stryMutAct_9fa48(\"5\") ? /^[a-zA-Z0-9_/:~.$+*-]+$/ : (stryCov_9fa48(\"5\", \"6\"), /^[a-zA-Z0-9_/:~.$+*-]*$/)))) === null)) {\n         |                                                                                                                                                                                                                                                                                                                                                                                                                                                ^\n      59 |       throw new Error('Path contains invalid characters');\n      60 |     }\n      61 |     if ((stryMutAct_9fa48(\"9\") ? spec.replace(/^\\//) : stryMutAct_9fa48(\"8\") ? spec.search(/^\\//) : stryMutAct_9fa48(\"7\") ? spec.split(/^\\//) : (stryCov_9fa48(\"7\", \"8\", \"9\"), spec.match(/^\\//))) === null) {\n\n      at new Matcher (src/matcher.ts:58:432)\n          at [Symbol.split] (<anonymous>)\n          at String.split (<anonymous>)\n      at Rule.matches (src/rule.ts:139:103)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       14 failed, 24 passed, 38 total\nSnapshots:   0 total\nTime:        2.847 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":29,"line":60},"start":{"column":19,"line":60}}},{"id":"221","mutatorName":"PrecomputedMutator","replacement":"path.replace","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✕ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (6 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nPASS test/matcher.ts\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       11 failed, 27 passed, 38 total\nSnapshots:   0 total\nTime:        2.7 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":29,"line":60},"start":{"column":19,"line":60}}},{"id":"222","mutatorName":"PrecomputedMutator","replacement":"this.regex.test(path)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (6 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('static', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Message:\n      unexpected result from query('static', '/nah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (5 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       14 failed, 24 passed, 38 total\nSnapshots:   0 total\nTime:        2.656 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":60},"start":{"column":30,"line":60}}},{"id":"223","mutatorName":"PrecomputedMutator","replacement":"path.match(this.regex)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (10 ms)\n\n    ✕ matches context-dependent paths correctly (5 ms)\n    ✓ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly (1 ms)\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths (1 ms)\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (2 ms)\n\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.906 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":60},"start":{"column":30,"line":60}}},{"id":"224","mutatorName":"PrecomputedMutator","replacement":"this.regex.exec(path)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (2 ms)\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n  rule\n\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.6 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":60},"start":{"column":30,"line":60}}},{"id":"225","mutatorName":"PrecomputedMutator","replacement":"match !== null","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly (1 ms)\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (7 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of null (reading '1')\n\n      148 |       for (let index = 0; stryMutAct_9fa48(\"236\") ? index >= count : stryMutAct_9fa48(\"235\") ? index > count : stryMutAct_9fa48(\"234\") ? index <= count : (stryCov_9fa48(\"234\", \"235\", \"236\"), index < count); stryMutAct_9fa48(\"239\") ? index = 0 : stryMutAct_9fa48(\"238\") ? index += 2 : stryMutAct_9fa48(\"237\") ? index-- : (stryCov_9fa48(\"237\", \"238\", \"239\"), index++)) {\n      149 |         const prop = ctx[this.regex.props[index]];\n    > 150 |         if (stryMutAct_9fa48(\"242\") ? prop !== null && match[index + 1] === prop : stryMutAct_9fa48(\"241\") ? prop !== undefined && match[index + 1] === prop : stryMutAct_9fa48(\"240\") ? prop === null || match[index + 1] !== prop : (stryCov_9fa48(\"240\", \"241\", \"242\"), prop === undefined || match[index + 1] !== prop)) {\n          |                                                                                                                                                                                                                                                                                                       ^\n      151 |           return false;\n      152 |         }\n      153 |       }\n\n      at Rule.matches (src/rule.ts:150:295)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✕ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of null (reading '1')\n\n      148 |       for (let index = 0; stryMutAct_9fa48(\"236\") ? index >= count : stryMutAct_9fa48(\"235\") ? index > count : stryMutAct_9fa48(\"234\") ? index <= count : (stryCov_9fa48(\"234\", \"235\", \"236\"), index < count); stryMutAct_9fa48(\"239\") ? index = 0 : stryMutAct_9fa48(\"238\") ? index += 2 : stryMutAct_9fa48(\"237\") ? index-- : (stryCov_9fa48(\"237\", \"238\", \"239\"), index++)) {\n      149 |         const prop = ctx[this.regex.props[index]];\n    > 150 |         if (stryMutAct_9fa48(\"242\") ? prop !== null && match[index + 1] === prop : stryMutAct_9fa48(\"241\") ? prop !== undefined && match[index + 1] === prop : stryMutAct_9fa48(\"240\") ? prop === null || match[index + 1] !== prop : (stryCov_9fa48(\"240\", \"241\", \"242\"), prop === undefined || match[index + 1] !== prop)) {\n          |                                                                                                                                                                                                                                                                                                       ^\n      151 |           return false;\n      152 |         }\n      153 |       }\n\n      at Rule.matches (src/rule.ts:150:295)\n      at Policy.matches (src/policy.ts:95:429)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       14 failed, 24 passed, 38 total\nSnapshots:   0 total\nTime:        2.477 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":61},"start":{"column":9,"line":61}}},{"id":"226","mutatorName":"PrecomputedMutator","replacement":"match === undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (6 ms)\n\n    ✕ answers queries correctly (4 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('static', '/')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      false\n\n    Message:\n      unexpected result from query('static', '/', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (8 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/yeah/nah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of null (reading '1')\n\n      148 |       for (let index = 0; stryMutAct_9fa48(\"236\") ? index >= count : stryMutAct_9fa48(\"235\") ? index > count : stryMutAct_9fa48(\"234\") ? index <= count : (stryCov_9fa48(\"234\", \"235\", \"236\"), index < count); stryMutAct_9fa48(\"239\") ? index = 0 : stryMutAct_9fa48(\"238\") ? index += 2 : stryMutAct_9fa48(\"237\") ? index-- : (stryCov_9fa48(\"237\", \"238\", \"239\"), index++)) {\n      149 |         const prop = ctx[this.regex.props[index]];\n    > 150 |         if (stryMutAct_9fa48(\"242\") ? prop !== null && match[index + 1] === prop : stryMutAct_9fa48(\"241\") ? prop !== undefined && match[index + 1] === prop : stryMutAct_9fa48(\"240\") ? prop === null || match[index + 1] !== prop : (stryCov_9fa48(\"240\", \"241\", \"242\"), prop === undefined || match[index + 1] !== prop)) {\n          |                                                                                                                                                                                                                                                                                                       ^\n      151 |           return false;\n      152 |         }\n      153 |       }\n\n      at Rule.matches (src/rule.ts:150:295)\n      at Policy.matches (src/policy.ts:95:429)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n\n  rule\n    ✕ matches paths correctly (4 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✕ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of null (reading '1')\n\n      148 |       for (let index = 0; stryMutAct_9fa48(\"236\") ? index >= count : stryMutAct_9fa48(\"235\") ? index > count : stryMutAct_9fa48(\"234\") ? index <= count : (stryCov_9fa48(\"234\", \"235\", \"236\"), index < count); stryMutAct_9fa48(\"239\") ? index = 0 : stryMutAct_9fa48(\"238\") ? index += 2 : stryMutAct_9fa48(\"237\") ? index-- : (stryCov_9fa48(\"237\", \"238\", \"239\"), index++)) {\n      149 |         const prop = ctx[this.regex.props[index]];\n    > 150 |         if (stryMutAct_9fa48(\"242\") ? prop !== null && match[index + 1] === prop : stryMutAct_9fa48(\"241\") ? prop !== undefined && match[index + 1] === prop : stryMutAct_9fa48(\"240\") ? prop === null || match[index + 1] !== prop : (stryCov_9fa48(\"240\", \"241\", \"242\"), prop === undefined || match[index + 1] !== prop)) {\n          |                                                                                                                                                                                                                                                                                                       ^\n      151 |           return false;\n      152 |         }\n      153 |       }\n\n      at Rule.matches (src/rule.ts:150:295)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       9 failed, 29 passed, 38 total\nSnapshots:   0 total\nTime:        2.359 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":61},"start":{"column":9,"line":61}}},{"id":"227","mutatorName":"PrecomputedMutator","replacement":"match.length === 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n\n  ● rule › matches paths correctly\n\n    TypeError: Cannot read properties of null (reading 'length')\n\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n      139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n    > 140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n          |                                         ^\n      141 |       return false;\n      142 |     }\n      143 |     const count = this.regex.props.length;\n\n      at Rule.matches (src/rule.ts:140:41)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of null (reading 'length')\n\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n      139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n    > 140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n          |                                         ^\n      141 |       return false;\n      142 |     }\n      143 |     const count = this.regex.props.length;\n\n      at Rule.matches (src/rule.ts:140:41)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    TypeError: Cannot read properties of null (reading 'length')\n\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n      139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n    > 140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n          |                                         ^\n      141 |       return false;\n      142 |     }\n      143 |     const count = this.regex.props.length;\n\n      at Rule.matches (src/rule.ts:140:41)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › clones itself correctly\n\n    TypeError: Cannot read properties of null (reading 'length')\n\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n      139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n    > 140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n          |                                         ^\n      141 |       return false;\n      142 |     }\n      143 |     const count = this.regex.props.length;\n\n      at Rule.matches (src/rule.ts:140:41)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (2 ms)\n\n    ✕ answers queries correctly (1 ms)\n\n\n  ● policymap › matches queries correctly\n\n    TypeError: Cannot read properties of null (reading 'length')\n\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n      139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n    > 140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n          |                                         ^\n      141 |       return false;\n      142 |     }\n      143 |     const count = this.regex.props.length;\n\n      at Rule.matches (src/rule.ts:140:41)\n      at Policy.matches (src/policy.ts:95:429)\n      at PolicyMap.matches (src/policymap.ts:85:367)\n      at Object.<anonymous> (test/policymap.ts:45:23)\n\n  ● policymap › answers queries correctly\n\n    TypeError: Cannot read properties of null (reading 'length')\n\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n      139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n    > 140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n          |                                         ^\n      141 |       return false;\n      142 |     }\n      143 |     const count = this.regex.props.length;\n\n      at Rule.matches (src/rule.ts:140:41)\n      at Rule.query (src/rule.ts:129:578)\n      at Policy.query (src/policy.ts:79:176)\n      at PolicyMap.query (src/policymap.ts:76:276)\n      at Object.<anonymous> (test/policymap.ts:87:23)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly\n\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✕ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly\n    ✕ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches paths correctly\n\n    TypeError: Cannot read properties of null (reading 'length')\n\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n      139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n    > 140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n          |                                         ^\n      141 |       return false;\n      142 |     }\n      143 |     const count = this.regex.props.length;\n\n      at Rule.matches (src/rule.ts:140:41)\n      at Policy.matches (src/policy.ts:95:429)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of null (reading 'length')\n\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n      139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n    > 140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n          |                                         ^\n      141 |       return false;\n      142 |     }\n      143 |     const count = this.regex.props.length;\n\n      at Rule.matches (src/rule.ts:140:41)\n      at Policy.matches (src/policy.ts:95:429)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    TypeError: Cannot read properties of null (reading 'length')\n\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n      139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n    > 140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n          |                                         ^\n      141 |       return false;\n      142 |     }\n      143 |     const count = this.regex.props.length;\n\n      at Rule.matches (src/rule.ts:140:41)\n      at Policy.matches (src/policy.ts:95:429)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › prioritises deny over allow\n\n    TypeError: Cannot read properties of null (reading 'length')\n\n      138 |   matches(path: string, ctx?: QueryContext): boolean {\n      139 |     const match = stryMutAct_9fa48(\"221\") ? path.replace(this.regex) : stryMutAct_9fa48(\"220\") ? path.split(this.regex) : stryMutAct_9fa48(\"219\") ? path.search(this.regex) : (stryCov_9fa48(\"219\", \"220\", \"221\"), path.match(stryMutAct_9fa48(\"224\") ? this.regex.exec(path) : stryMutAct_9fa48(\"223\") ? path.match(this.regex) : stryMutAct_9fa48(\"222\") ? this.regex.test(path) : (stryCov_9fa48(\"222\", \"223\", \"224\"), this.regex)));\n    > 140 |     if (stryMutAct_9fa48(\"227\") ? match.length === 0 : stryMutAct_9fa48(\"226\") ? match === undefined : stryMutAct_9fa48(\"225\") ? match !== null : (stryCov_9fa48(\"225\", \"226\", \"227\"), match === null)) {\n          |                                         ^\n      141 |       return false;\n      142 |     }\n      143 |     const count = this.regex.props.length;\n\n      at Rule.matches (src/rule.ts:140:41)\n      at Policy.matches (src/policy.ts:95:429)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:109:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       10 failed, 28 passed, 38 total\nSnapshots:   0 total\nTime:        2.37 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":23,"line":61},"start":{"column":9,"line":61}}},{"id":"228","mutatorName":"PrecomputedMutator","replacement":"count < 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (9 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments (1 ms)\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (2 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (5 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.453 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":18,"line":65},"start":{"column":9,"line":65}}},{"id":"229","mutatorName":"PrecomputedMutator","replacement":"count === 0","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✕ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n    ✕ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:11:5)\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for rule '/test'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:57:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n  ● rule › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      null\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      101 |   })\n      102 |   it('prioritises deny over allow', () => {\n    > 103 |     strictEqual(\n          |                ^\n      104 |       Rule\n      105 |         .for('/test')\n      106 |         .deny('foo')\n\n      at Object.<anonymous> (test/rule.ts:103:16)\n\n  ● rule › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/yeah'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:119:5)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✕ matches paths correctly (7 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✕ answers queries correctly (3 ms)\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✕ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'dynamic'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:19:5)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'without context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:56:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n  ● policy › prioritises deny over allow\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'deny first'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:100:5)\n\n  ● policy › clones itself correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/test') for policy 'original'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:129:5)\n\n\nFAIL test/policymap.ts\n  policymap\n\n    ✕ matches queries correctly (4 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths (1 ms)\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards (1 ms)\n\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       13 failed, 25 passed, 38 total\nSnapshots:   0 total\nTime:        2.522 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":18,"line":65},"start":{"column":9,"line":65}}},{"id":"230","mutatorName":"PrecomputedMutator","replacement":"count !== 0","status":"Survived","testsCompleted":1,"location":{"end":{"column":18,"line":65},"start":{"column":9,"line":65}}},{"id":"231","mutatorName":"PrecomputedMutator","replacement":"ctx !== undefined","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (6 ms)\n    ✕ answers queries correctly (4 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      147 |       }\n      148 |       for (let index = 0; stryMutAct_9fa48(\"236\") ? index >= count : stryMutAct_9fa48(\"235\") ? index > count : stryMutAct_9fa48(\"234\") ? index <= count : (stryCov_9fa48(\"234\", \"235\", \"236\"), index < count); stryMutAct_9fa48(\"239\") ? index = 0 : stryMutAct_9fa48(\"238\") ? index += 2 : stryMutAct_9fa48(\"237\") ? index-- : (stryCov_9fa48(\"237\", \"238\", \"239\"), index++)) {\n    > 149 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      150 |         if (stryMutAct_9fa48(\"242\") ? prop !== null && match[index + 1] === prop : stryMutAct_9fa48(\"241\") ? prop !== undefined && match[index + 1] === prop : stryMutAct_9fa48(\"240\") ? prop === null || match[index + 1] !== prop : (stryCov_9fa48(\"240\", \"241\", \"242\"), prop === undefined || match[index + 1] !== prop)) {\n      151 |           return false;\n      152 |         }\n\n      at Rule.matches (src/rule.ts:149:25)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      147 |       }\n      148 |       for (let index = 0; stryMutAct_9fa48(\"236\") ? index >= count : stryMutAct_9fa48(\"235\") ? index > count : stryMutAct_9fa48(\"234\") ? index <= count : (stryCov_9fa48(\"234\", \"235\", \"236\"), index < count); stryMutAct_9fa48(\"239\") ? index = 0 : stryMutAct_9fa48(\"238\") ? index += 2 : stryMutAct_9fa48(\"237\") ? index-- : (stryCov_9fa48(\"237\", \"238\", \"239\"), index++)) {\n    > 149 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      150 |         if (stryMutAct_9fa48(\"242\") ? prop !== null && match[index + 1] === prop : stryMutAct_9fa48(\"241\") ? prop !== undefined && match[index + 1] === prop : stryMutAct_9fa48(\"240\") ? prop === null || match[index + 1] !== prop : (stryCov_9fa48(\"240\", \"241\", \"242\"), prop === undefined || match[index + 1] !== prop)) {\n      151 |           return false;\n      152 |         }\n\n      at Rule.matches (src/rule.ts:149:25)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✕ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (2 ms)\n\n    ✕ answers context-dependent queries correctly (3 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      147 |       }\n      148 |       for (let index = 0; stryMutAct_9fa48(\"236\") ? index >= count : stryMutAct_9fa48(\"235\") ? index > count : stryMutAct_9fa48(\"234\") ? index <= count : (stryCov_9fa48(\"234\", \"235\", \"236\"), index < count); stryMutAct_9fa48(\"239\") ? index = 0 : stryMutAct_9fa48(\"238\") ? index += 2 : stryMutAct_9fa48(\"237\") ? index-- : (stryCov_9fa48(\"237\", \"238\", \"239\"), index++)) {\n    > 149 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      150 |         if (stryMutAct_9fa48(\"242\") ? prop !== null && match[index + 1] === prop : stryMutAct_9fa48(\"241\") ? prop !== undefined && match[index + 1] === prop : stryMutAct_9fa48(\"240\") ? prop === null || match[index + 1] !== prop : (stryCov_9fa48(\"240\", \"241\", \"242\"), prop === undefined || match[index + 1] !== prop)) {\n      151 |           return false;\n      152 |         }\n\n      at Rule.matches (src/rule.ts:149:25)\n      at Policy.matches (src/policy.ts:95:429)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.302 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":66},"start":{"column":11,"line":66}}},{"id":"232","mutatorName":"PrecomputedMutator","replacement":"!ctx","status":"Survived","testsCompleted":1,"location":{"end":{"column":28,"line":66},"start":{"column":11,"line":66}}},{"id":"233","mutatorName":"PrecomputedMutator","replacement":"ctx && ctx.props","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      147 |       }\n      148 |       for (let index = 0; stryMutAct_9fa48(\"236\") ? index >= count : stryMutAct_9fa48(\"235\") ? index > count : stryMutAct_9fa48(\"234\") ? index <= count : (stryCov_9fa48(\"234\", \"235\", \"236\"), index < count); stryMutAct_9fa48(\"239\") ? index = 0 : stryMutAct_9fa48(\"238\") ? index += 2 : stryMutAct_9fa48(\"237\") ? index-- : (stryCov_9fa48(\"237\", \"238\", \"239\"), index++)) {\n    > 149 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      150 |         if (stryMutAct_9fa48(\"242\") ? prop !== null && match[index + 1] === prop : stryMutAct_9fa48(\"241\") ? prop !== undefined && match[index + 1] === prop : stryMutAct_9fa48(\"240\") ? prop === null || match[index + 1] !== prop : (stryCov_9fa48(\"240\", \"241\", \"242\"), prop === undefined || match[index + 1] !== prop)) {\n      151 |           return false;\n      152 |         }\n\n      at Rule.matches (src/rule.ts:149:25)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:37:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      147 |       }\n      148 |       for (let index = 0; stryMutAct_9fa48(\"236\") ? index >= count : stryMutAct_9fa48(\"235\") ? index > count : stryMutAct_9fa48(\"234\") ? index <= count : (stryCov_9fa48(\"234\", \"235\", \"236\"), index < count); stryMutAct_9fa48(\"239\") ? index = 0 : stryMutAct_9fa48(\"238\") ? index += 2 : stryMutAct_9fa48(\"237\") ? index-- : (stryCov_9fa48(\"237\", \"238\", \"239\"), index++)) {\n    > 149 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      150 |         if (stryMutAct_9fa48(\"242\") ? prop !== null && match[index + 1] === prop : stryMutAct_9fa48(\"241\") ? prop !== undefined && match[index + 1] === prop : stryMutAct_9fa48(\"240\") ? prop === null || match[index + 1] !== prop : (stryCov_9fa48(\"240\", \"241\", \"242\"), prop === undefined || match[index + 1] !== prop)) {\n      151 |           return false;\n      152 |         }\n\n      at Rule.matches (src/rule.ts:149:25)\n      at runTests (test/rule.ts:151:27)\n      at Object.<anonymous> (test/rule.ts:73:5)\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches context-dependent paths correctly\n\n    TypeError: Cannot read properties of undefined (reading 'maybe')\n\n      147 |       }\n      148 |       for (let index = 0; stryMutAct_9fa48(\"236\") ? index >= count : stryMutAct_9fa48(\"235\") ? index > count : stryMutAct_9fa48(\"234\") ? index <= count : (stryCov_9fa48(\"234\", \"235\", \"236\"), index < count); stryMutAct_9fa48(\"239\") ? index = 0 : stryMutAct_9fa48(\"238\") ? index += 2 : stryMutAct_9fa48(\"237\") ? index-- : (stryCov_9fa48(\"237\", \"238\", \"239\"), index++)) {\n    > 149 |         const prop = ctx[this.regex.props[index]];\n          |                         ^\n      150 |         if (stryMutAct_9fa48(\"242\") ? prop !== null && match[index + 1] === prop : stryMutAct_9fa48(\"241\") ? prop !== undefined && match[index + 1] === prop : stryMutAct_9fa48(\"240\") ? prop === null || match[index + 1] !== prop : (stryCov_9fa48(\"240\", \"241\", \"242\"), prop === undefined || match[index + 1] !== prop)) {\n      151 |           return false;\n      152 |         }\n\n      at Rule.matches (src/rule.ts:149:25)\n      at Policy.matches (src/policy.ts:95:429)\n      at runTests (test/policy.ts:170:29)\n      at Object.<anonymous> (test/policy.ts:32:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (4 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       3 failed, 35 passed, 38 total\nSnapshots:   0 total\nTime:        2.372 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":28,"line":66},"start":{"column":11,"line":66}}},{"id":"234","mutatorName":"PrecomputedMutator","replacement":"index <= count","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (4 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (5 ms)\n    ✓ answers queries correctly (4 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✕ answers queries correctly (2 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.349 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":69},"start":{"column":27,"line":69}}},{"id":"235","mutatorName":"PrecomputedMutator","replacement":"index > count","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (5 ms)\n\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (5 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters (1 ms)\n\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (5 ms)\n    ✓ answers queries correctly (2 ms)\n\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (4 ms)\n\n    ✓ answers queries correctly\n\n    ✕ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.593 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":69},"start":{"column":27,"line":69}}},{"id":"236","mutatorName":"PrecomputedMutator","replacement":"index >= count","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (8 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (5 ms)\n\n    ✕ matches context-dependent paths correctly (3 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly (1 ms)\n\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      null\n    Received:\n      true\n\n    Message:\n      unexpected result from query('/foo', 'bar') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received boolean.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow\n\n    ✓ clones itself correctly\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (2 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes (1 ms)\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       5 failed, 33 passed, 38 total\nSnapshots:   0 total\nTime:        2.624 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":40,"line":69},"start":{"column":27,"line":69}}},{"id":"237","mutatorName":"PrecomputedMutator","replacement":"index--","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (4 ms)\n    ✓ matches match-one-or-none wildcard segments correctly (5 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (2 ms)\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (5 ms)\n    ✕ matches context-dependent paths correctly (6 ms)\n    ✓ answers queries correctly (2 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✓ clones itself correctly\n\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/foo') for policy 'test'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (8 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('/yeah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nFAIL test/policymap.ts\n\n  policymap\n    ✕ matches queries correctly (4 ms)\n    ✕ answers queries correctly (1 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      unexpected result from matches('context', '/nah/yeah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.437 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":49,"line":69},"start":{"column":42,"line":69}}},{"id":"238","mutatorName":"PrecomputedMutator","replacement":"index += 2","status":"Survived","testsCompleted":1,"location":{"end":{"column":49,"line":69},"start":{"column":42,"line":69}}},{"id":"239","mutatorName":"PrecomputedMutator","replacement":"index = 0","status":"Timeout","location":{"end":{"column":49,"line":69},"start":{"column":42,"line":69}}},{"id":"240","mutatorName":"PrecomputedMutator","replacement":"prop === null || match[index + 1] !== prop","status":"Survived","testsCompleted":1,"location":{"end":{"column":60,"line":71},"start":{"column":13,"line":71}}},{"id":"241","mutatorName":"PrecomputedMutator","replacement":"prop !== undefined && match[index + 1] === prop","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n\n  policymap\n\n    ✕ matches queries correctly (10 ms)\n\n    ✕ answers queries correctly (4 ms)\n\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (31 ms)\n\n    ✕ matches context-dependent paths correctly (4 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards (1 ms)\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (1 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.987 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":60,"line":71},"start":{"column":13,"line":71}}},{"id":"242","mutatorName":"PrecomputedMutator","replacement":"prop !== null && match[index + 1] === prop","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policymap.ts\n  policymap\n    ✕ matches queries correctly (10 ms)\n    ✕ answers queries correctly (3 ms)\n\n  ● policymap › matches queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('context', '/nah')\n\n      43 |     ]\n      44 |     for (const test of tests) {\n    > 45 |       strictEqual(map.matches(test[0], test[1], ctx), test[2],\n         |                  ^\n      46 |         `unexpected result from matches('${test[0]}', '${test[1]}')`)\n      47 |     }\n      48 |   })\n\n      at Object.<anonymous> (test/policymap.ts:45:18)\n\n  ● policymap › answers queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('context', '/nah/yeah', 'get')\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      85 |     ]\n      86 |     for (const test of tests) {\n    > 87 |       strictEqual(map.query(test[0], test[1], test[2], ctx), test[3],\n         |                  ^\n      88 |         `unexpected result from query('${test[0]}', '${test[1]}', '${test[2]}')`)\n      89 |     }\n      90 |   })\n\n      at Object.<anonymous> (test/policymap.ts:87:18)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (3 ms)\n\n    ✕ matches context-dependent paths correctly (2 ms)\n\n    ✓ answers queries correctly (1 ms)\n\n    ✕ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✓ clones itself correctly\n\n\n  ● rule › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:44:5)\n\n  ● rule › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for rule '/:maybe'\n\n      149 | }): void {\n      150 |   for (const test of opts.tests) {\n    > 151 |     strictEqual(opts.rule.matches(test[0], opts.ctx), test[1],\n          |                ^\n      152 |       `unexpected result from matches('${test[0]}') for rule '${opts.rule.regex.spec}'`)\n      153 |     if (test.length === 4 && typeof test[2] === 'string') {\n      154 |       strictEqual(opts.rule.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/rule.ts:151:16)\n      at Object.<anonymous> (test/rule.ts:84:5)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✕ matches context-dependent paths correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n    ✕ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✓ clones itself correctly (1 ms)\n\n  ● policy › matches context-dependent paths correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      false\n    Received:\n      true\n\n    Message:\n      unexpected result from matches('/nah') for policy 'with context'\n\n      168 | }): void {\n      169 |   for (const test of opts.tests) {\n    > 170 |     strictEqual(opts.policy.matches(test[0], opts.ctx), test[1],\n          |                ^\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n      173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n\n      at runTests (test/policy.ts:170:16)\n      at Object.<anonymous> (test/policy.ts:40:5)\n\n  ● policy › answers context-dependent queries correctly\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      true\n    Received:\n      null\n\n    Message:\n      unexpected result from query('/foo', 'foo') for policy 'test'\n\n    Difference:\n\n      Comparing two different types of values. Expected boolean but received null.\n\n      171 |       `unexpected result from matches('${test[0]}') for policy '${opts.policy.name}'`)\n      172 |     if (test.length === 4 && typeof test[2] === 'string') {\n    > 173 |       strictEqual(opts.policy.query(test[0], test[2], opts.ctx), test[3],\n          |                  ^\n      174 |         `unexpected result from query('${test[0]}', '${test[2]}') for policy '${opts.policy.name}'`)\n      175 |     }\n      176 |   }\n\n      at runTests (test/policy.ts:173:18)\n      at Object.<anonymous> (test/policy.ts:78:5)\n\n\nTest Suites: 3 failed, 1 passed, 4 total\nTests:       6 failed, 32 passed, 38 total\nSnapshots:   0 total\nTime:        2.781 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":60,"line":71},"start":{"column":13,"line":71}}},{"id":"243","mutatorName":"PrecomputedMutator","replacement":"for (const verb2 in this.verbs) {\n  rule.verbs[verb] = this.verbs[verb];\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (9 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\nFAIL test/rule.ts\n\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (2 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (2 ms)\n\n  ● rule › clones itself correctly\n\n    ReferenceError: verb is not defined\n\n      174 |     } else if (stryMutAct_9fa48(\"243\")) {\n      175 |       for (const verb2 in this.verbs) {\n    > 176 |         rule.verbs[verb] = this.verbs[verb];\n          |                    ^\n      177 |       }\n      178 |     } else {\n      179 |       stryCov_9fa48(\"243\", \"244\", \"245\", \"246\");\n\n      at Rule.clone (src/rule.ts:176:20)\n      at Object.<anonymous> (test/rule.ts:124:10)\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (3 ms)\n\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (2 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › clones itself correctly\n\n    ReferenceError: verb is not defined\n\n      174 |     } else if (stryMutAct_9fa48(\"243\")) {\n      175 |       for (const verb2 in this.verbs) {\n    > 176 |         rule.verbs[verb] = this.verbs[verb];\n          |                    ^\n      177 |       }\n      178 |     } else {\n      179 |       stryCov_9fa48(\"243\", \"244\", \"245\", \"246\");\n\n      at Rule.clone (src/rule.ts:176:20)\n      at src/policy.ts:106:297\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:50)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (1 ms)\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.562 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":85},"start":{"column":5,"line":83}}},{"id":"244","mutatorName":"PrecomputedMutator","replacement":"for (const verbs in this.verbs) {\n  rule.verbs[verb] = this.verbs[verb];\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n\n    ✓ answers queries correctly (3 ms)\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n  ● policy › clones itself correctly\n\n    ReferenceError: verb is not defined\n\n      170 |     } else if (stryMutAct_9fa48(\"244\")) {\n      171 |       for (const verbs in this.verbs) {\n    > 172 |         rule.verbs[verb] = this.verbs[verb];\n          |                    ^\n      173 |       }\n      174 |     } else if (stryMutAct_9fa48(\"243\")) {\n      175 |       for (const verb2 in this.verbs) {\n\n      at Rule.clone (src/rule.ts:172:20)\n      at src/policy.ts:106:297\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:50)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › clones itself correctly\n\n    ReferenceError: verb is not defined\n\n      170 |     } else if (stryMutAct_9fa48(\"244\")) {\n      171 |       for (const verbs in this.verbs) {\n    > 172 |         rule.verbs[verb] = this.verbs[verb];\n          |                    ^\n      173 |       }\n      174 |     } else if (stryMutAct_9fa48(\"243\")) {\n      175 |       for (const verb2 in this.verbs) {\n\n      at Rule.clone (src/rule.ts:172:20)\n      at Object.<anonymous> (test/rule.ts:124:10)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly (1 ms)\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly\n    ✓ matches match-many wildcard segments correctly (1 ms)\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.479 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":85},"start":{"column":5,"line":83}}},{"id":"245","mutatorName":"PrecomputedMutator","replacement":"for (const verb of this.verbs) {\n  rule.verbs[verb] = this.verbs[verb];\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n\n  policymap\n\n    ✓ matches queries correctly (4 ms)\n\n    ✓ answers queries correctly (2 ms)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (9 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n\n    ✓ rejects paths with trailing slashes (1 ms)\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures (1 ms)\n    ✓ compiles literal path segments correctly (1 ms)\n\n    ✓ compiles match-one wildcard segments correctly\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (1 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly\n\n  ● rule › clones itself correctly\n\n    TypeError: this.verbs is not iterable\n\n      165 |       }\n      166 |     } else if (stryMutAct_9fa48(\"245\")) {\n    > 167 |       for (const verb of this.verbs) {\n          |                               ^\n      168 |         rule.verbs[verb] = this.verbs[verb];\n      169 |       }\n      170 |     } else if (stryMutAct_9fa48(\"244\")) {\n\n      at Rule.clone (src/rule.ts:167:31)\n      at Object.<anonymous> (test/rule.ts:124:10)\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow\n    ✕ clones itself correctly (1 ms)\n\n\n  ● policy › clones itself correctly\n\n    TypeError: this.verbs is not iterable\n\n      165 |       }\n      166 |     } else if (stryMutAct_9fa48(\"245\")) {\n    > 167 |       for (const verb of this.verbs) {\n          |                               ^\n      168 |         rule.verbs[verb] = this.verbs[verb];\n      169 |       }\n      170 |     } else if (stryMutAct_9fa48(\"244\")) {\n\n      at Rule.clone (src/rule.ts:167:31)\n      at src/policy.ts:106:297\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:50)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.534 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":85},"start":{"column":5,"line":83}}},{"id":"246","mutatorName":"PrecomputedMutator","replacement":"for (const verb in this.verbs.keys()) {\n  rule.verbs[verb] = this.verbs[verb];\n}","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nPASS test/policymap.ts\n  policymap\n    ✓ matches queries correctly (4 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (3 ms)\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly (1 ms)\n\n\n  ● rule › clones itself correctly\n\n    TypeError: this.verbs.keys is not a function\n\n      161 |     const rule = new Rule(spec);\n      162 |     if (stryMutAct_9fa48(\"246\")) {\n    > 163 |       for (const verb in this.verbs.keys()) {\n          |                                     ^\n      164 |         rule.verbs[verb] = this.verbs[verb];\n      165 |       }\n      166 |     } else if (stryMutAct_9fa48(\"245\")) {\n\n      at Rule.clone (src/rule.ts:163:37)\n      at Object.<anonymous> (test/rule.ts:124:10)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (4 ms)\n\n    ✓ rejects empty paths\n\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n\n    ✓ rejects paths with empty segments\n\n    ✓ rejects paths with invalid characters\n\n    ✓ rejects paths with malformed wildcards (1 ms)\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (2 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly (1 ms)\n\n    ✓ matches literal path segments correctly (1 ms)\n\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (2 ms)\n    ✓ matches capture segments correctly\n\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (2 ms)\n\n  ● policy › clones itself correctly\n\n    TypeError: this.verbs.keys is not a function\n\n      161 |     const rule = new Rule(spec);\n      162 |     if (stryMutAct_9fa48(\"246\")) {\n    > 163 |       for (const verb in this.verbs.keys()) {\n          |                                     ^\n      164 |         rule.verbs[verb] = this.verbs[verb];\n      165 |       }\n      166 |     } else if (stryMutAct_9fa48(\"245\")) {\n\n      at Rule.clone (src/rule.ts:163:37)\n      at src/policy.ts:106:297\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:50)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.722 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":6,"line":85},"start":{"column":5,"line":83}}},{"id":"247","mutatorName":"PrecomputedMutator","replacement":"this.verbs.slice()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/policy.ts\n\n  policy\n\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › clones itself correctly\n\n    TypeError: this.verbs.slice is not a function\n\n      178 |     } else {\n      179 |       stryCov_9fa48(\"243\", \"244\", \"245\", \"246\");\n    > 180 |       for (const verb in stryMutAct_9fa48(\"249\") ? this.verbs.filter(Boolean) : stryMutAct_9fa48(\"248\") ? this.verbs.concat() : stryMutAct_9fa48(\"247\") ? this.verbs.slice() : (stryCov_9fa48(\"247\", \"248\", \"249\"), this.verbs)) {\n          |                                                                                                                                                                      ^\n      181 |         rule.verbs[verb] = this.verbs[verb];\n      182 |       }\n      183 |     }\n\n      at Rule.clone (src/rule.ts:180:166)\n      at src/policy.ts:106:297\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:50)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nPASS test/policymap.ts\n  policymap\n\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (2 ms)\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly\n\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n\n  ● rule › clones itself correctly\n\n    TypeError: this.verbs.slice is not a function\n\n      178 |     } else {\n      179 |       stryCov_9fa48(\"243\", \"244\", \"245\", \"246\");\n    > 180 |       for (const verb in stryMutAct_9fa48(\"249\") ? this.verbs.filter(Boolean) : stryMutAct_9fa48(\"248\") ? this.verbs.concat() : stryMutAct_9fa48(\"247\") ? this.verbs.slice() : (stryCov_9fa48(\"247\", \"248\", \"249\"), this.verbs)) {\n          |                                                                                                                                                                      ^\n      181 |         rule.verbs[verb] = this.verbs[verb];\n      182 |       }\n      183 |     }\n\n      at Rule.clone (src/rule.ts:180:166)\n      at Object.<anonymous> (test/rule.ts:124:10)\n\n\nPASS test/matcher.ts\n\n  matcher\n    ✓ accepts valid paths (3 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly (1 ms)\n    ✓ compiles capture segments correctly\n\n    ✓ matches literal path segments correctly (1 ms)\n    ✓ matches match-one wildcard segments correctly\n\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly\n\n    ✓ matches combinations of wildcard segments correctly (1 ms)\n    ✓ matches capture segments correctly\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n\n      ✓ rejects specs with match-many-or-none wildcards\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        2.884 s, estimated 3 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":83},"start":{"column":24,"line":83}}},{"id":"248","mutatorName":"PrecomputedMutator","replacement":"this.verbs.concat()","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n  rule\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly (1 ms)\n\n  ● rule › clones itself correctly\n\n    TypeError: this.verbs.concat is not a function\n\n      178 |     } else {\n      179 |       stryCov_9fa48(\"243\", \"244\", \"245\", \"246\");\n    > 180 |       for (const verb in stryMutAct_9fa48(\"249\") ? this.verbs.filter(Boolean) : stryMutAct_9fa48(\"248\") ? this.verbs.concat() : stryMutAct_9fa48(\"247\") ? this.verbs.slice() : (stryCov_9fa48(\"247\", \"248\", \"249\"), this.verbs)) {\n          |                                                                                                                      ^\n      181 |         rule.verbs[verb] = this.verbs[verb];\n      182 |       }\n      183 |     }\n\n      at Rule.clone (src/rule.ts:180:118)\n      at Object.<anonymous> (test/rule.ts:124:10)\n\n\nFAIL test/policy.ts\n  policy\n    ✓ matches paths correctly (4 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n    ✓ answers context-dependent queries correctly (1 ms)\n    ✓ prioritises deny over allow (1 ms)\n    ✕ clones itself correctly\n\n  ● policy › clones itself correctly\n\n    TypeError: this.verbs.concat is not a function\n\n      178 |     } else {\n      179 |       stryCov_9fa48(\"243\", \"244\", \"245\", \"246\");\n    > 180 |       for (const verb in stryMutAct_9fa48(\"249\") ? this.verbs.filter(Boolean) : stryMutAct_9fa48(\"248\") ? this.verbs.concat() : stryMutAct_9fa48(\"247\") ? this.verbs.slice() : (stryCov_9fa48(\"247\", \"248\", \"249\"), this.verbs)) {\n          |                                                                                                                      ^\n      181 |         rule.verbs[verb] = this.verbs[verb];\n      182 |       }\n      183 |     }\n\n      at Rule.clone (src/rule.ts:180:118)\n      at src/policy.ts:106:297\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:50)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes (2 ms)\n    ✓ rejects paths with empty segments (1 ms)\n    ✓ rejects paths with invalid characters\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n    ✓ compiles match-many wildcard segments correctly\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly (1 ms)\n    ✓ matches literal path segments correctly\n    ✓ matches match-one wildcard segments correctly (1 ms)\n\n    ✓ matches match-many wildcard segments correctly\n    ✓ matches match-one-or-none wildcard segments correctly\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        3.308 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":83},"start":{"column":24,"line":83}}},{"id":"249","mutatorName":"PrecomputedMutator","replacement":"this.verbs.filter(Boolean)","statusReason":"\n> @spacl/core@1.2.1 test\n> jest test/*.ts\n\n\nFAIL test/rule.ts\n\n  rule\n\n    ✓ matches paths correctly (2 ms)\n\n    ✓ matches context-dependent paths correctly\n    ✓ answers queries correctly\n    ✓ answers context-dependent queries correctly (1 ms)\n\n    ✓ prioritises deny over allow\n\n    ✕ clones itself correctly (1 ms)\n\n\n\n  ● rule › clones itself correctly\n\n    TypeError: this.verbs.filter is not a function\n\n      178 |     } else {\n      179 |       stryCov_9fa48(\"243\", \"244\", \"245\", \"246\");\n    > 180 |       for (const verb in stryMutAct_9fa48(\"249\") ? this.verbs.filter(Boolean) : stryMutAct_9fa48(\"248\") ? this.verbs.concat() : stryMutAct_9fa48(\"247\") ? this.verbs.slice() : (stryCov_9fa48(\"247\", \"248\", \"249\"), this.verbs)) {\n          |                                                               ^\n      181 |         rule.verbs[verb] = this.verbs[verb];\n      182 |       }\n      183 |     }\n\n      at Rule.clone (src/rule.ts:180:63)\n      at Object.<anonymous> (test/rule.ts:124:10)\n\n\nPASS test/matcher.ts\n\n  matcher\n\n    ✓ accepts valid paths (5 ms)\n    ✓ rejects empty paths\n    ✓ rejects paths without leading slashes\n    ✓ rejects paths with trailing slashes\n    ✓ rejects paths with empty segments\n    ✓ rejects paths with invalid characters (1 ms)\n    ✓ rejects paths with malformed wildcards\n    ✓ rejects paths with malformed captures\n    ✓ compiles literal path segments correctly (1 ms)\n    ✓ compiles match-one wildcard segments correctly (1 ms)\n\n    ✓ compiles match-many wildcard segments correctly\n\n    ✓ compiles match-one-or-none wildcard segments correctly\n    ✓ compiles match-many-or-none wildcard segments correctly\n    ✓ compiles combinations of wildcard segments correctly\n    ✓ compiles capture segments correctly\n    ✓ matches literal path segments correctly\n\n    ✓ matches match-one wildcard segments correctly (1 ms)\n    ✓ matches match-many wildcard segments correctly (1 ms)\n\n    ✓ matches match-one-or-none wildcard segments correctly (1 ms)\n    ✓ matches match-many-or-none wildcard segments correctly (1 ms)\n    ✓ matches combinations of wildcard segments correctly\n    ✓ matches capture segments correctly (1 ms)\n    when using version 1\n      ✓ rejects specs with match-one-or-none wildcards\n      ✓ rejects specs with match-many-or-none wildcards\n\n\n\nFAIL test/policy.ts\n\n  policy\n    ✓ matches paths correctly (2 ms)\n    ✓ matches context-dependent paths correctly (1 ms)\n    ✓ answers queries correctly (1 ms)\n\n    ✓ answers context-dependent queries correctly\n    ✓ prioritises deny over allow (1 ms)\n\n    ✕ clones itself correctly\n\n\n  ● policy › clones itself correctly\n\n    TypeError: this.verbs.filter is not a function\n\n      178 |     } else {\n      179 |       stryCov_9fa48(\"243\", \"244\", \"245\", \"246\");\n    > 180 |       for (const verb in stryMutAct_9fa48(\"249\") ? this.verbs.filter(Boolean) : stryMutAct_9fa48(\"248\") ? this.verbs.concat() : stryMutAct_9fa48(\"247\") ? this.verbs.slice() : (stryCov_9fa48(\"247\", \"248\", \"249\"), this.verbs)) {\n          |                                                               ^\n      181 |         rule.verbs[verb] = this.verbs[verb];\n      182 |       }\n      183 |     }\n\n      at Rule.clone (src/rule.ts:180:63)\n      at src/policy.ts:106:297\n          at Array.map (<anonymous>)\n      at Policy.clone (src/policy.ts:106:50)\n      at Object.<anonymous> (test/policy.ts:123:27)\n\n\nPASS test/policymap.ts\n\n  policymap\n    ✓ matches queries correctly (3 ms)\n    ✓ answers queries correctly (1 ms)\n\n\nTest Suites: 2 failed, 2 passed, 4 total\nTests:       2 failed, 36 passed, 38 total\nSnapshots:   0 total\nTime:        3.334 s\nRan all test suites matching /test\\/matcher.ts|test\\/policy.ts|test\\/policymap.ts|test\\/rule.ts/i.\n","status":"Killed","testsCompleted":1,"killedBy":["0"],"location":{"end":{"column":34,"line":83},"start":{"column":24,"line":83}}}],"source":"import { Matcher } from './matcher'\nimport { Queryable, QueryContext } from './queryable'\n\n/** Access-control rule for a single path. */\nexport class Rule implements Queryable {\n  /** Pattern for determining which paths are governed by this rule. */\n  readonly regex: Matcher\n  /** Set of verbs governed by this rule; allowed verbs\n    * are marked as `true`, denied verbs as `false`. */\n  readonly verbs: { [index: string]: boolean } = {}\n\n  /** @param spec Path specification or pre-compiled matcher for\n    *             determining which paths this rule will apply to. */\n  constructor (spec: string | Matcher) {\n    this.regex = spec instanceof Matcher\n      ? spec\n      : new Matcher(spec)\n  }\n\n  /** Mark one or more verbs as allowed.\n    * @note Deny overrides allow within SPACL policies;\n    *       this method will have no effect on verbs\n    *       previously marked as denied. */\n  allow (...verbs: string[]): Rule {\n    for (const verb of verbs) {\n      if (!(verb in this.verbs)) {\n        this.verbs[verb] = true\n      }\n    }\n    return this\n  }\n\n  /** Mark one or more verbs as denied. */\n  deny (...verbs: string[]): Rule {\n    for (const verb of verbs) {\n      this.verbs[verb] = false\n    }\n    return this\n  }\n\n  /** Check whether an action is allowed on a path.\n    * @param path Path to be acted on.\n    * @param verb Action to be performed.\n    * @param ctx Query context for resolving context-dependent paths.\n    * @returns Returns `true` if the action is explicitly allowed,\n    *          `false` if the action is explicitly denied, or\n    *          `null` if the combination of path and action\n    *          is not governed by this rule. */\n  query (path: string, verb: string, ctx?: QueryContext): boolean | null {\n    if (this.matches(path, ctx) && verb in this.verbs) {\n      return this.verbs[verb]\n    }\n    return null\n  }\n\n  /** Check whether a path is governed by this rule.\n    * @param path Path to be checked.\n    * @param ctx Query context for resolving context-dependent paths. */\n  matches (path: string, ctx?: QueryContext): boolean {\n    const match = path.match(this.regex)\n    if (match === null) {\n      return false\n    }\n    const count = this.regex.props.length\n    if (count > 0) {\n      if (ctx === undefined) {\n        return false\n      }\n      for (let index = 0; index < count; index++) {\n        const prop = ctx[this.regex.props[index]]\n        if (prop === undefined || match[index + 1] !== prop) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  /** Create clone of a rule.\n    * @param spec Replacement path specification for the new rule. */\n  clone (spec: string | Matcher = this.regex): Rule {\n    const rule = new Rule(spec)\n    for (const verb in this.verbs) {\n      rule.verbs[verb] = this.verbs[verb]\n    }\n    return rule\n  }\n\n  /** Static constructor function; returns a new Rule.\n    * @param spec Path specification or pre-compiled matcher for\n    *             determining which paths this rule will apply to. */\n  static for (spec: string | Matcher): Rule {\n    return new Rule(spec)\n  }\n}\n"}},"schemaVersion":"1.0","thresholds":{"high":80,"low":60,"break":null},"testFiles":{"":{"tests":[{"id":"0","name":"All tests"}]}},"projectRoot":"/Users/jon/Documents/NEU/Projects/llm-mutation-testing/projects/spacl-core","config":{"concurrency":1,"usePrecomputed":true,"mutate":["src/index.ts","src/matcher.ts","src/policy.ts","src/policymap.ts","src/queryable.ts","src/rule.ts"],"reporters":["json","html","progress"],"allowConsoleColors":true,"checkers":[],"checkerNodeArgs":[],"commandRunner":{"command":"npm test"},"coverageAnalysis":"perTest","clearTextReporter":{"allowColor":true,"allowEmojis":false,"logTests":true,"maxTestsToLog":3,"reportTests":true,"reportMutants":true,"reportScoreTable":true},"dashboard":{"baseUrl":"https://dashboard.stryker-mutator.io/api/reports","reportType":"full"},"dryRunOnly":false,"eventReporter":{"baseDir":"reports/mutation/events"},"ignorePatterns":[],"ignoreStatic":false,"incremental":false,"incrementalFile":"reports/stryker-incremental.json","force":false,"fileLogLevel":"off","inPlace":false,"logLevel":"info","maxConcurrentTestRunners":9007199254740991,"maxTestRunnerReuse":0,"mutator":{"plugins":null,"excludedMutations":[]},"plugins":["@stryker-mutator/*"],"appendPlugins":[],"htmlReporter":{"fileName":"reports/mutation/mutation.html"},"jsonReporter":{"fileName":"reports/mutation/mutation.json"},"disableTypeChecks":true,"symlinkNodeModules":true,"tempDirName":".stryker-tmp","cleanTempDir":true,"testRunner":"command","testRunnerNodeArgs":[],"thresholds":{"high":80,"low":60,"break":null},"timeoutFactor":1.5,"timeoutMS":5000,"dryRunTimeoutMinutes":5,"tsconfigFile":"tsconfig.json","warnings":true,"disableBail":false,"allowEmpty":false,"ignorers":[],"cucumber":{},"jest":{"projectType":"custom","enableFindRelatedTests":true},"mochaOptions":{},"tap":{"testFiles":["{**/@(test|tests|__test__|__tests__)/**,**/*.@(test|tests|spec)}.@(cjs|mjs|js|jsx|ts|tsx|mts|cts)"],"nodeArgs":["-r","{{hookFile}}","{{testFile}}"],"forceBail":true},"vitest":{}},"framework":{"name":"StrykerJS","version":"8.2.5","branding":{"homepageUrl":"https://stryker-mutator.io","imageUrl":"data:image/svg+xml;utf8,%3Csvg viewBox='0 0 1458 1458' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' clip-rule='evenodd' stroke-linejoin='round' stroke-miterlimit='2'%3E%3Cpath fill='none' d='M0 0h1458v1458H0z'/%3E%3CclipPath id='a'%3E%3Cpath d='M0 0h1458v1458H0z'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23a)'%3E%3Cpath d='M1458 729c0 402.655-326.345 729-729 729S0 1131.655 0 729C0 326.445 326.345 0 729 0s729 326.345 729 729' fill='%23e74c3c' fill-rule='nonzero'/%3E%3Cpath d='M778.349 1456.15L576.6 1254.401l233-105 85-78.668v-64.332l-257-257-44-187-50-208 251.806-82.793L1076.6 389.401l380.14 379.15c-19.681 367.728-311.914 663.049-678.391 687.599z' fill-opacity='.3'/%3E%3Cpath d='M753.4 329.503c41.79 0 74.579 7.83 97.925 25.444 23.571 18.015 41.69 43.956 55.167 77.097l11.662 28.679 165.733-58.183-14.137-32.13c-26.688-60.655-64.896-108.61-114.191-144.011-49.329-35.423-117.458-54.302-204.859-54.302-50.78 0-95.646 7.376-134.767 21.542-40.093 14.671-74.09 34.79-102.239 60.259-28.84 26.207-50.646 57.06-65.496 92.701-14.718 35.052-22.101 72.538-22.101 112.401 0 72.536 20.667 133.294 61.165 182.704 38.624 47.255 98.346 88.037 179.861 121.291 42.257 17.475 78.715 33.125 109.227 46.994 27.193 12.361 49.294 26.124 66.157 41.751 15.309 14.186 26.497 30.584 33.63 49.258 7.721 20.214 11.16 45.69 11.16 76.402 0 28.021-4.251 51.787-13.591 71.219-8.832 18.374-20.171 33.178-34.523 44.219-14.787 11.374-31.193 19.591-49.393 24.466-19.68 5.359-39.14 7.993-58.69 7.993-29.359 0-54.387-3.407-75.182-10.747-20.112-7.013-37.144-16.144-51.259-27.486-13.618-11.009-24.971-23.766-33.744-38.279-9.64-15.8-17.272-31.924-23.032-48.408l-10.965-31.376-161.669 60.585 10.734 30.124c10.191 28.601 24.197 56.228 42.059 82.748 18.208 27.144 41.322 51.369 69.525 72.745 27.695 21.075 60.904 38.218 99.481 51.041 37.777 12.664 82.004 19.159 132.552 19.159 49.998 0 95.818-8.321 137.611-24.622 42.228-16.471 78.436-38.992 108.835-67.291 30.719-28.597 54.631-62.103 71.834-100.642 17.263-38.56 25.923-79.392 25.923-122.248 0-54.339-8.368-100.37-24.208-138.32-16.29-38.759-38.252-71.661-65.948-98.797-26.965-26.418-58.269-48.835-93.858-67.175-33.655-17.241-69.196-33.11-106.593-47.533-35.934-13.429-65.822-26.601-89.948-39.525-22.153-11.868-40.009-24.21-53.547-37.309-11.429-11.13-19.83-23.678-24.718-37.664-5.413-15.49-7.98-33.423-7.98-53.577 0-40.883 11.293-71.522 37.086-90.539 28.443-20.825 64.985-30.658 109.311-30.658z' fill='%23f1c40f' fill-rule='nonzero'/%3E%3Cpath d='M720 0h18v113h-18zM1458 738v-18h-113v18h113zM720 1345h18v113h-18zM113 738v-18H0v18h113z'/%3E%3C/g%3E%3C/svg%3E"},"dependencies":{"@stryker-mutator/mocha-runner":"8.2.5","@stryker-mutator/karma-runner":"8.2.5","@stryker-mutator/jasmine-runner":"8.2.5","@stryker-mutator/jest-runner":"8.2.5","mocha":"10.4.0","jasmine-core":"5.1.2","jest":"27.5.1","typescript":"4.9.5","ts-jest":"27.1.5"}}}